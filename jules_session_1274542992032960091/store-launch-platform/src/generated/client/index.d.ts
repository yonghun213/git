
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Store
 * 
 */
export type Store = $Result.DefaultSelection<Prisma.$StorePayload>
/**
 * Model Template
 * 
 */
export type Template = $Result.DefaultSelection<Prisma.$TemplatePayload>
/**
 * Model TemplatePhase
 * 
 */
export type TemplatePhase = $Result.DefaultSelection<Prisma.$TemplatePhasePayload>
/**
 * Model TemplateTask
 * 
 */
export type TemplateTask = $Result.DefaultSelection<Prisma.$TemplateTaskPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskDependency
 * 
 */
export type TaskDependency = $Result.DefaultSelection<Prisma.$TaskDependencyPayload>
/**
 * Model Milestone
 * 
 */
export type Milestone = $Result.DefaultSelection<Prisma.$MilestonePayload>
/**
 * Model Issue
 * 
 */
export type Issue = $Result.DefaultSelection<Prisma.$IssuePayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Ingredient
 * 
 */
export type Ingredient = $Result.DefaultSelection<Prisma.$IngredientPayload>
/**
 * Model GroceryPrice
 * 
 */
export type GroceryPrice = $Result.DefaultSelection<Prisma.$GroceryPricePayload>
/**
 * Model PriceHistory
 * 
 */
export type PriceHistory = $Result.DefaultSelection<Prisma.$PriceHistoryPayload>
/**
 * Model Recipe
 * 
 */
export type Recipe = $Result.DefaultSelection<Prisma.$RecipePayload>
/**
 * Model RecipeLine
 * 
 */
export type RecipeLine = $Result.DefaultSelection<Prisma.$RecipeLinePayload>
/**
 * Model CompetitorPrice
 * 
 */
export type CompetitorPrice = $Result.DefaultSelection<Prisma.$CompetitorPricePayload>
/**
 * Model FXRate
 * 
 */
export type FXRate = $Result.DefaultSelection<Prisma.$FXRatePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model NotificationLog
 * 
 */
export type NotificationLog = $Result.DefaultSelection<Prisma.$NotificationLogPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.store`: Exposes CRUD operations for the **Store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.StoreDelegate<ExtArgs>;

  /**
   * `prisma.template`: Exposes CRUD operations for the **Template** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Templates
    * const templates = await prisma.template.findMany()
    * ```
    */
  get template(): Prisma.TemplateDelegate<ExtArgs>;

  /**
   * `prisma.templatePhase`: Exposes CRUD operations for the **TemplatePhase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplatePhases
    * const templatePhases = await prisma.templatePhase.findMany()
    * ```
    */
  get templatePhase(): Prisma.TemplatePhaseDelegate<ExtArgs>;

  /**
   * `prisma.templateTask`: Exposes CRUD operations for the **TemplateTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateTasks
    * const templateTasks = await prisma.templateTask.findMany()
    * ```
    */
  get templateTask(): Prisma.TemplateTaskDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.taskDependency`: Exposes CRUD operations for the **TaskDependency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskDependencies
    * const taskDependencies = await prisma.taskDependency.findMany()
    * ```
    */
  get taskDependency(): Prisma.TaskDependencyDelegate<ExtArgs>;

  /**
   * `prisma.milestone`: Exposes CRUD operations for the **Milestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Milestones
    * const milestones = await prisma.milestone.findMany()
    * ```
    */
  get milestone(): Prisma.MilestoneDelegate<ExtArgs>;

  /**
   * `prisma.issue`: Exposes CRUD operations for the **Issue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Issues
    * const issues = await prisma.issue.findMany()
    * ```
    */
  get issue(): Prisma.IssueDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.ingredient`: Exposes CRUD operations for the **Ingredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ingredients
    * const ingredients = await prisma.ingredient.findMany()
    * ```
    */
  get ingredient(): Prisma.IngredientDelegate<ExtArgs>;

  /**
   * `prisma.groceryPrice`: Exposes CRUD operations for the **GroceryPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroceryPrices
    * const groceryPrices = await prisma.groceryPrice.findMany()
    * ```
    */
  get groceryPrice(): Prisma.GroceryPriceDelegate<ExtArgs>;

  /**
   * `prisma.priceHistory`: Exposes CRUD operations for the **PriceHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceHistories
    * const priceHistories = await prisma.priceHistory.findMany()
    * ```
    */
  get priceHistory(): Prisma.PriceHistoryDelegate<ExtArgs>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<ExtArgs>;

  /**
   * `prisma.recipeLine`: Exposes CRUD operations for the **RecipeLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeLines
    * const recipeLines = await prisma.recipeLine.findMany()
    * ```
    */
  get recipeLine(): Prisma.RecipeLineDelegate<ExtArgs>;

  /**
   * `prisma.competitorPrice`: Exposes CRUD operations for the **CompetitorPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompetitorPrices
    * const competitorPrices = await prisma.competitorPrice.findMany()
    * ```
    */
  get competitorPrice(): Prisma.CompetitorPriceDelegate<ExtArgs>;

  /**
   * `prisma.fXRate`: Exposes CRUD operations for the **FXRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FXRates
    * const fXRates = await prisma.fXRate.findMany()
    * ```
    */
  get fXRate(): Prisma.FXRateDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.notificationLog`: Exposes CRUD operations for the **NotificationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationLogs
    * const notificationLogs = await prisma.notificationLog.findMany()
    * ```
    */
  get notificationLog(): Prisma.NotificationLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.10.2
   * Query Engine version: 5a9203d0590c951969e85a7d07215503f4672eb9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Store: 'Store',
    Template: 'Template',
    TemplatePhase: 'TemplatePhase',
    TemplateTask: 'TemplateTask',
    Task: 'Task',
    TaskDependency: 'TaskDependency',
    Milestone: 'Milestone',
    Issue: 'Issue',
    Document: 'Document',
    Ingredient: 'Ingredient',
    GroceryPrice: 'GroceryPrice',
    PriceHistory: 'PriceHistory',
    Recipe: 'Recipe',
    RecipeLine: 'RecipeLine',
    CompetitorPrice: 'CompetitorPrice',
    FXRate: 'FXRate',
    AuditLog: 'AuditLog',
    NotificationLog: 'NotificationLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'store' | 'template' | 'templatePhase' | 'templateTask' | 'task' | 'taskDependency' | 'milestone' | 'issue' | 'document' | 'ingredient' | 'groceryPrice' | 'priceHistory' | 'recipe' | 'recipeLine' | 'competitorPrice' | 'fXRate' | 'auditLog' | 'notificationLog'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Store: {
        payload: Prisma.$StorePayload<ExtArgs>
        fields: Prisma.StoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findFirst: {
            args: Prisma.StoreFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findMany: {
            args: Prisma.StoreFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          create: {
            args: Prisma.StoreCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          delete: {
            args: Prisma.StoreDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          update: {
            args: Prisma.StoreUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          deleteMany: {
            args: Prisma.StoreDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StoreUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StoreUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          aggregate: {
            args: Prisma.StoreAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStore>
          }
          groupBy: {
            args: Prisma.StoreGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreCountArgs<ExtArgs>,
            result: $Utils.Optional<StoreCountAggregateOutputType> | number
          }
        }
      }
      Template: {
        payload: Prisma.$TemplatePayload<ExtArgs>
        fields: Prisma.TemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findFirst: {
            args: Prisma.TemplateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findMany: {
            args: Prisma.TemplateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          create: {
            args: Prisma.TemplateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          delete: {
            args: Prisma.TemplateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          update: {
            args: Prisma.TemplateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          deleteMany: {
            args: Prisma.TemplateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TemplateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          aggregate: {
            args: Prisma.TemplateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTemplate>
          }
          groupBy: {
            args: Prisma.TemplateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateCountArgs<ExtArgs>,
            result: $Utils.Optional<TemplateCountAggregateOutputType> | number
          }
        }
      }
      TemplatePhase: {
        payload: Prisma.$TemplatePhasePayload<ExtArgs>
        fields: Prisma.TemplatePhaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplatePhaseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePhasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplatePhaseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePhasePayload>
          }
          findFirst: {
            args: Prisma.TemplatePhaseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePhasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplatePhaseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePhasePayload>
          }
          findMany: {
            args: Prisma.TemplatePhaseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePhasePayload>[]
          }
          create: {
            args: Prisma.TemplatePhaseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePhasePayload>
          }
          delete: {
            args: Prisma.TemplatePhaseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePhasePayload>
          }
          update: {
            args: Prisma.TemplatePhaseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePhasePayload>
          }
          deleteMany: {
            args: Prisma.TemplatePhaseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TemplatePhaseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TemplatePhaseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePhasePayload>
          }
          aggregate: {
            args: Prisma.TemplatePhaseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTemplatePhase>
          }
          groupBy: {
            args: Prisma.TemplatePhaseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TemplatePhaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplatePhaseCountArgs<ExtArgs>,
            result: $Utils.Optional<TemplatePhaseCountAggregateOutputType> | number
          }
        }
      }
      TemplateTask: {
        payload: Prisma.$TemplateTaskPayload<ExtArgs>
        fields: Prisma.TemplateTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateTaskFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplateTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateTaskFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplateTaskPayload>
          }
          findFirst: {
            args: Prisma.TemplateTaskFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplateTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateTaskFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplateTaskPayload>
          }
          findMany: {
            args: Prisma.TemplateTaskFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplateTaskPayload>[]
          }
          create: {
            args: Prisma.TemplateTaskCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplateTaskPayload>
          }
          delete: {
            args: Prisma.TemplateTaskDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplateTaskPayload>
          }
          update: {
            args: Prisma.TemplateTaskUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplateTaskPayload>
          }
          deleteMany: {
            args: Prisma.TemplateTaskDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateTaskUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TemplateTaskUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplateTaskPayload>
          }
          aggregate: {
            args: Prisma.TemplateTaskAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTemplateTask>
          }
          groupBy: {
            args: Prisma.TemplateTaskGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TemplateTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateTaskCountArgs<ExtArgs>,
            result: $Utils.Optional<TemplateTaskCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>,
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskDependency: {
        payload: Prisma.$TaskDependencyPayload<ExtArgs>
        fields: Prisma.TaskDependencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskDependencyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskDependencyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          findFirst: {
            args: Prisma.TaskDependencyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskDependencyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          findMany: {
            args: Prisma.TaskDependencyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>[]
          }
          create: {
            args: Prisma.TaskDependencyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          delete: {
            args: Prisma.TaskDependencyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          update: {
            args: Prisma.TaskDependencyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          deleteMany: {
            args: Prisma.TaskDependencyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TaskDependencyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TaskDependencyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          aggregate: {
            args: Prisma.TaskDependencyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTaskDependency>
          }
          groupBy: {
            args: Prisma.TaskDependencyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TaskDependencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskDependencyCountArgs<ExtArgs>,
            result: $Utils.Optional<TaskDependencyCountAggregateOutputType> | number
          }
        }
      }
      Milestone: {
        payload: Prisma.$MilestonePayload<ExtArgs>
        fields: Prisma.MilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilestoneFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilestoneFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findFirst: {
            args: Prisma.MilestoneFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilestoneFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findMany: {
            args: Prisma.MilestoneFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          create: {
            args: Prisma.MilestoneCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          delete: {
            args: Prisma.MilestoneDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          update: {
            args: Prisma.MilestoneUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          deleteMany: {
            args: Prisma.MilestoneDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MilestoneUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MilestoneUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          aggregate: {
            args: Prisma.MilestoneAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMilestone>
          }
          groupBy: {
            args: Prisma.MilestoneGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.MilestoneCountArgs<ExtArgs>,
            result: $Utils.Optional<MilestoneCountAggregateOutputType> | number
          }
        }
      }
      Issue: {
        payload: Prisma.$IssuePayload<ExtArgs>
        fields: Prisma.IssueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IssueFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IssuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IssueFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          findFirst: {
            args: Prisma.IssueFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IssuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IssueFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          findMany: {
            args: Prisma.IssueFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>[]
          }
          create: {
            args: Prisma.IssueCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          delete: {
            args: Prisma.IssueDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          update: {
            args: Prisma.IssueUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          deleteMany: {
            args: Prisma.IssueDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.IssueUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.IssueUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          aggregate: {
            args: Prisma.IssueAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIssue>
          }
          groupBy: {
            args: Prisma.IssueGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IssueGroupByOutputType>[]
          }
          count: {
            args: Prisma.IssueCountArgs<ExtArgs>,
            result: $Utils.Optional<IssueCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Ingredient: {
        payload: Prisma.$IngredientPayload<ExtArgs>
        fields: Prisma.IngredientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngredientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngredientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          findFirst: {
            args: Prisma.IngredientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngredientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          findMany: {
            args: Prisma.IngredientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>[]
          }
          create: {
            args: Prisma.IngredientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          delete: {
            args: Prisma.IngredientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          update: {
            args: Prisma.IngredientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          deleteMany: {
            args: Prisma.IngredientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.IngredientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.IngredientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          aggregate: {
            args: Prisma.IngredientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIngredient>
          }
          groupBy: {
            args: Prisma.IngredientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IngredientGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngredientCountArgs<ExtArgs>,
            result: $Utils.Optional<IngredientCountAggregateOutputType> | number
          }
        }
      }
      GroceryPrice: {
        payload: Prisma.$GroceryPricePayload<ExtArgs>
        fields: Prisma.GroceryPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroceryPriceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroceryPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroceryPriceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroceryPricePayload>
          }
          findFirst: {
            args: Prisma.GroceryPriceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroceryPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroceryPriceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroceryPricePayload>
          }
          findMany: {
            args: Prisma.GroceryPriceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroceryPricePayload>[]
          }
          create: {
            args: Prisma.GroceryPriceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroceryPricePayload>
          }
          delete: {
            args: Prisma.GroceryPriceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroceryPricePayload>
          }
          update: {
            args: Prisma.GroceryPriceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroceryPricePayload>
          }
          deleteMany: {
            args: Prisma.GroceryPriceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GroceryPriceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GroceryPriceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroceryPricePayload>
          }
          aggregate: {
            args: Prisma.GroceryPriceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGroceryPrice>
          }
          groupBy: {
            args: Prisma.GroceryPriceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GroceryPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroceryPriceCountArgs<ExtArgs>,
            result: $Utils.Optional<GroceryPriceCountAggregateOutputType> | number
          }
        }
      }
      PriceHistory: {
        payload: Prisma.$PriceHistoryPayload<ExtArgs>
        fields: Prisma.PriceHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          findFirst: {
            args: Prisma.PriceHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          findMany: {
            args: Prisma.PriceHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]
          }
          create: {
            args: Prisma.PriceHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          delete: {
            args: Prisma.PriceHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          update: {
            args: Prisma.PriceHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PriceHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PriceHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PriceHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          aggregate: {
            args: Prisma.PriceHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePriceHistory>
          }
          groupBy: {
            args: Prisma.PriceHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PriceHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<PriceHistoryCountAggregateOutputType> | number
          }
        }
      }
      Recipe: {
        payload: Prisma.$RecipePayload<ExtArgs>
        fields: Prisma.RecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findFirst: {
            args: Prisma.RecipeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findMany: {
            args: Prisma.RecipeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          create: {
            args: Prisma.RecipeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          delete: {
            args: Prisma.RecipeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          update: {
            args: Prisma.RecipeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          deleteMany: {
            args: Prisma.RecipeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RecipeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          aggregate: {
            args: Prisma.RecipeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecipe>
          }
          groupBy: {
            args: Prisma.RecipeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeCountArgs<ExtArgs>,
            result: $Utils.Optional<RecipeCountAggregateOutputType> | number
          }
        }
      }
      RecipeLine: {
        payload: Prisma.$RecipeLinePayload<ExtArgs>
        fields: Prisma.RecipeLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeLineFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeLineFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeLinePayload>
          }
          findFirst: {
            args: Prisma.RecipeLineFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeLineFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeLinePayload>
          }
          findMany: {
            args: Prisma.RecipeLineFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeLinePayload>[]
          }
          create: {
            args: Prisma.RecipeLineCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeLinePayload>
          }
          delete: {
            args: Prisma.RecipeLineDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeLinePayload>
          }
          update: {
            args: Prisma.RecipeLineUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeLinePayload>
          }
          deleteMany: {
            args: Prisma.RecipeLineDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeLineUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RecipeLineUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeLinePayload>
          }
          aggregate: {
            args: Prisma.RecipeLineAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecipeLine>
          }
          groupBy: {
            args: Prisma.RecipeLineGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RecipeLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeLineCountArgs<ExtArgs>,
            result: $Utils.Optional<RecipeLineCountAggregateOutputType> | number
          }
        }
      }
      CompetitorPrice: {
        payload: Prisma.$CompetitorPricePayload<ExtArgs>
        fields: Prisma.CompetitorPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompetitorPriceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompetitorPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompetitorPriceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompetitorPricePayload>
          }
          findFirst: {
            args: Prisma.CompetitorPriceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompetitorPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompetitorPriceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompetitorPricePayload>
          }
          findMany: {
            args: Prisma.CompetitorPriceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompetitorPricePayload>[]
          }
          create: {
            args: Prisma.CompetitorPriceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompetitorPricePayload>
          }
          delete: {
            args: Prisma.CompetitorPriceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompetitorPricePayload>
          }
          update: {
            args: Prisma.CompetitorPriceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompetitorPricePayload>
          }
          deleteMany: {
            args: Prisma.CompetitorPriceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CompetitorPriceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CompetitorPriceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompetitorPricePayload>
          }
          aggregate: {
            args: Prisma.CompetitorPriceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompetitorPrice>
          }
          groupBy: {
            args: Prisma.CompetitorPriceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CompetitorPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompetitorPriceCountArgs<ExtArgs>,
            result: $Utils.Optional<CompetitorPriceCountAggregateOutputType> | number
          }
        }
      }
      FXRate: {
        payload: Prisma.$FXRatePayload<ExtArgs>
        fields: Prisma.FXRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FXRateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FXRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FXRateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FXRatePayload>
          }
          findFirst: {
            args: Prisma.FXRateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FXRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FXRateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FXRatePayload>
          }
          findMany: {
            args: Prisma.FXRateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FXRatePayload>[]
          }
          create: {
            args: Prisma.FXRateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FXRatePayload>
          }
          delete: {
            args: Prisma.FXRateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FXRatePayload>
          }
          update: {
            args: Prisma.FXRateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FXRatePayload>
          }
          deleteMany: {
            args: Prisma.FXRateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FXRateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FXRateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FXRatePayload>
          }
          aggregate: {
            args: Prisma.FXRateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFXRate>
          }
          groupBy: {
            args: Prisma.FXRateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FXRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.FXRateCountArgs<ExtArgs>,
            result: $Utils.Optional<FXRateCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>,
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      NotificationLog: {
        payload: Prisma.$NotificationLogPayload<ExtArgs>
        fields: Prisma.NotificationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findFirst: {
            args: Prisma.NotificationLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findMany: {
            args: Prisma.NotificationLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          create: {
            args: Prisma.NotificationLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          delete: {
            args: Prisma.NotificationLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          update: {
            args: Prisma.NotificationLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          deleteMany: {
            args: Prisma.NotificationLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          aggregate: {
            args: Prisma.NotificationLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotificationLog>
          }
          groupBy: {
            args: Prisma.NotificationLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationLogCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    tasks_owned: number
    tasks_collaborating: number
    audit_logs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks_owned?: boolean | UserCountOutputTypeCountTasks_ownedArgs
    tasks_collaborating?: boolean | UserCountOutputTypeCountTasks_collaboratingArgs
    audit_logs?: boolean | UserCountOutputTypeCountAudit_logsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasks_ownedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasks_collaboratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAudit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }



  /**
   * Count Type StoreCountOutputType
   */

  export type StoreCountOutputType = {
    tasks: number
    milestones: number
    issues: number
    documents: number
  }

  export type StoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | StoreCountOutputTypeCountTasksArgs
    milestones?: boolean | StoreCountOutputTypeCountMilestonesArgs
    issues?: boolean | StoreCountOutputTypeCountIssuesArgs
    documents?: boolean | StoreCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCountOutputType
     */
    select?: StoreCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
  }


  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueWhereInput
  }


  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }



  /**
   * Count Type TemplateCountOutputType
   */

  export type TemplateCountOutputType = {
    phases: number
  }

  export type TemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phases?: boolean | TemplateCountOutputTypeCountPhasesArgs
  }

  // Custom InputTypes

  /**
   * TemplateCountOutputType without action
   */
  export type TemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateCountOutputType
     */
    select?: TemplateCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TemplateCountOutputType without action
   */
  export type TemplateCountOutputTypeCountPhasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplatePhaseWhereInput
  }



  /**
   * Count Type TemplatePhaseCountOutputType
   */

  export type TemplatePhaseCountOutputType = {
    tasks: number
  }

  export type TemplatePhaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | TemplatePhaseCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes

  /**
   * TemplatePhaseCountOutputType without action
   */
  export type TemplatePhaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePhaseCountOutputType
     */
    select?: TemplatePhaseCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TemplatePhaseCountOutputType without action
   */
  export type TemplatePhaseCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateTaskWhereInput
  }



  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    dependencies: number
    dependents: number
    collaborators: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dependencies?: boolean | TaskCountOutputTypeCountDependenciesArgs
    dependents?: boolean | TaskCountOutputTypeCountDependentsArgs
    collaborators?: boolean | TaskCountOutputTypeCountCollaboratorsArgs
  }

  // Custom InputTypes

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountDependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDependencyWhereInput
  }


  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountDependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDependencyWhereInput
  }


  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCollaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }



  /**
   * Count Type IngredientCountOutputType
   */

  export type IngredientCountOutputType = {
    prices: number
    recipe_lines: number
  }

  export type IngredientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prices?: boolean | IngredientCountOutputTypeCountPricesArgs
    recipe_lines?: boolean | IngredientCountOutputTypeCountRecipe_linesArgs
  }

  // Custom InputTypes

  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientCountOutputType
     */
    select?: IngredientCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeCountPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroceryPriceWhereInput
  }


  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeCountRecipe_linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeLineWhereInput
  }



  /**
   * Count Type GroceryPriceCountOutputType
   */

  export type GroceryPriceCountOutputType = {
    history: number
  }

  export type GroceryPriceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | GroceryPriceCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes

  /**
   * GroceryPriceCountOutputType without action
   */
  export type GroceryPriceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroceryPriceCountOutputType
     */
    select?: GroceryPriceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GroceryPriceCountOutputType without action
   */
  export type GroceryPriceCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceHistoryWhereInput
  }



  /**
   * Count Type RecipeCountOutputType
   */

  export type RecipeCountOutputType = {
    lines: number
  }

  export type RecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | RecipeCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     */
    select?: RecipeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeLineWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password_hash: string | null
    role: string | null
    created_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password_hash: string | null
    role: string | null
    created_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password_hash: number
    role: number
    created_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password_hash?: true
    role?: true
    created_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password_hash?: true
    role?: true
    created_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password_hash?: true
    role?: true
    created_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    password_hash: string
    role: string
    created_at: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password_hash?: boolean
    role?: boolean
    created_at?: boolean
    tasks_owned?: boolean | User$tasks_ownedArgs<ExtArgs>
    tasks_collaborating?: boolean | User$tasks_collaboratingArgs<ExtArgs>
    audit_logs?: boolean | User$audit_logsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password_hash?: boolean
    role?: boolean
    created_at?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks_owned?: boolean | User$tasks_ownedArgs<ExtArgs>
    tasks_collaborating?: boolean | User$tasks_collaboratingArgs<ExtArgs>
    audit_logs?: boolean | User$audit_logsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tasks_owned: Prisma.$TaskPayload<ExtArgs>[]
      tasks_collaborating: Prisma.$TaskPayload<ExtArgs>[]
      audit_logs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      password_hash: string
      role: string
      created_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tasks_owned<T extends User$tasks_ownedArgs<ExtArgs> = {}>(args?: Subset<T, User$tasks_ownedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findMany'> | Null>;

    tasks_collaborating<T extends User$tasks_collaboratingArgs<ExtArgs> = {}>(args?: Subset<T, User$tasks_collaboratingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findMany'> | Null>;

    audit_logs<T extends User$audit_logsArgs<ExtArgs> = {}>(args?: Subset<T, User$audit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.tasks_owned
   */
  export type User$tasks_ownedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }


  /**
   * User.tasks_collaborating
   */
  export type User$tasks_collaboratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }


  /**
   * User.audit_logs
   */
  export type User$audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Store
   */

  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreMinAggregateOutputType = {
    id: string | null
    name: string | null
    country: string | null
    city: string | null
    address: string | null
    timezone: string | null
    status: string | null
    planned_open_date: Date | null
    actual_open_date: Date | null
    contract_signed_date: Date | null
    template_version: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StoreMaxAggregateOutputType = {
    id: string | null
    name: string | null
    country: string | null
    city: string | null
    address: string | null
    timezone: string | null
    status: string | null
    planned_open_date: Date | null
    actual_open_date: Date | null
    contract_signed_date: Date | null
    template_version: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StoreCountAggregateOutputType = {
    id: number
    name: number
    country: number
    city: number
    address: number
    timezone: number
    status: number
    planned_open_date: number
    actual_open_date: number
    contract_signed_date: number
    template_version: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StoreMinAggregateInputType = {
    id?: true
    name?: true
    country?: true
    city?: true
    address?: true
    timezone?: true
    status?: true
    planned_open_date?: true
    actual_open_date?: true
    contract_signed_date?: true
    template_version?: true
    created_at?: true
    updated_at?: true
  }

  export type StoreMaxAggregateInputType = {
    id?: true
    name?: true
    country?: true
    city?: true
    address?: true
    timezone?: true
    status?: true
    planned_open_date?: true
    actual_open_date?: true
    contract_signed_date?: true
    template_version?: true
    created_at?: true
    updated_at?: true
  }

  export type StoreCountAggregateInputType = {
    id?: true
    name?: true
    country?: true
    city?: true
    address?: true
    timezone?: true
    status?: true
    planned_open_date?: true
    actual_open_date?: true
    contract_signed_date?: true
    template_version?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Store to aggregate.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type StoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithAggregationInput | StoreOrderByWithAggregationInput[]
    by: StoreScalarFieldEnum[] | StoreScalarFieldEnum
    having?: StoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }

  export type StoreGroupByOutputType = {
    id: string
    name: string
    country: string
    city: string
    address: string | null
    timezone: string
    status: string
    planned_open_date: Date | null
    actual_open_date: Date | null
    contract_signed_date: Date | null
    template_version: string
    created_at: Date
    updated_at: Date
    _count: StoreCountAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends StoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type StoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    country?: boolean
    city?: boolean
    address?: boolean
    timezone?: boolean
    status?: boolean
    planned_open_date?: boolean
    actual_open_date?: boolean
    contract_signed_date?: boolean
    template_version?: boolean
    created_at?: boolean
    updated_at?: boolean
    tasks?: boolean | Store$tasksArgs<ExtArgs>
    milestones?: boolean | Store$milestonesArgs<ExtArgs>
    issues?: boolean | Store$issuesArgs<ExtArgs>
    documents?: boolean | Store$documentsArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectScalar = {
    id?: boolean
    name?: boolean
    country?: boolean
    city?: boolean
    address?: boolean
    timezone?: boolean
    status?: boolean
    planned_open_date?: boolean
    actual_open_date?: boolean
    contract_signed_date?: boolean
    template_version?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type StoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | Store$tasksArgs<ExtArgs>
    milestones?: boolean | Store$milestonesArgs<ExtArgs>
    issues?: boolean | Store$issuesArgs<ExtArgs>
    documents?: boolean | Store$documentsArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Store"
    objects: {
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      milestones: Prisma.$MilestonePayload<ExtArgs>[]
      issues: Prisma.$IssuePayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      country: string
      city: string
      address: string | null
      timezone: string
      status: string
      planned_open_date: Date | null
      actual_open_date: Date | null
      contract_signed_date: Date | null
      template_version: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["store"]>
    composites: {}
  }


  type StoreGetPayload<S extends boolean | null | undefined | StoreDefaultArgs> = $Result.GetResult<Prisma.$StorePayload, S>

  type StoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface StoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Store'], meta: { name: 'Store' } }
    /**
     * Find zero or one Store that matches the filter.
     * @param {StoreFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StoreFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StoreFindUniqueArgs<ExtArgs>>
    ): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Store that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StoreFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StoreFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StoreFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StoreFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StoreFindFirstArgs<ExtArgs>>
    ): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StoreFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StoreFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeWithIdOnly = await prisma.store.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StoreFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StoreFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Store.
     * @param {StoreCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
    **/
    create<T extends StoreCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StoreCreateArgs<ExtArgs>>
    ): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Store.
     * @param {StoreDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
    **/
    delete<T extends StoreDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StoreDeleteArgs<ExtArgs>>
    ): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Store.
     * @param {StoreUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StoreUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StoreUpdateArgs<ExtArgs>>
    ): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Stores.
     * @param {StoreDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StoreDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StoreDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StoreUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StoreUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Store.
     * @param {StoreUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
    **/
    upsert<T extends StoreUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StoreUpsertArgs<ExtArgs>>
    ): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoreCountArgs>(
      args?: Subset<T, StoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreGroupByArgs['orderBy'] }
        : { orderBy?: StoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Store model
   */
  readonly fields: StoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tasks<T extends Store$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Store$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findMany'> | Null>;

    milestones<T extends Store$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, Store$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'findMany'> | Null>;

    issues<T extends Store$issuesArgs<ExtArgs> = {}>(args?: Subset<T, Store$issuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'findMany'> | Null>;

    documents<T extends Store$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Store$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Store model
   */ 
  interface StoreFieldRefs {
    readonly id: FieldRef<"Store", 'String'>
    readonly name: FieldRef<"Store", 'String'>
    readonly country: FieldRef<"Store", 'String'>
    readonly city: FieldRef<"Store", 'String'>
    readonly address: FieldRef<"Store", 'String'>
    readonly timezone: FieldRef<"Store", 'String'>
    readonly status: FieldRef<"Store", 'String'>
    readonly planned_open_date: FieldRef<"Store", 'DateTime'>
    readonly actual_open_date: FieldRef<"Store", 'DateTime'>
    readonly contract_signed_date: FieldRef<"Store", 'DateTime'>
    readonly template_version: FieldRef<"Store", 'String'>
    readonly created_at: FieldRef<"Store", 'DateTime'>
    readonly updated_at: FieldRef<"Store", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Store findUnique
   */
  export type StoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }


  /**
   * Store findUniqueOrThrow
   */
  export type StoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }


  /**
   * Store findFirst
   */
  export type StoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }


  /**
   * Store findFirstOrThrow
   */
  export type StoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }


  /**
   * Store findMany
   */
  export type StoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }


  /**
   * Store create
   */
  export type StoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Store.
     */
    data: XOR<StoreCreateInput, StoreUncheckedCreateInput>
  }


  /**
   * Store update
   */
  export type StoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Store.
     */
    data: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
    /**
     * Choose, which Store to update.
     */
    where: StoreWhereUniqueInput
  }


  /**
   * Store updateMany
   */
  export type StoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
  }


  /**
   * Store upsert
   */
  export type StoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Store to update in case it exists.
     */
    where: StoreWhereUniqueInput
    /**
     * In case the Store found by the `where` argument doesn't exist, create a new Store with this data.
     */
    create: XOR<StoreCreateInput, StoreUncheckedCreateInput>
    /**
     * In case the Store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
  }


  /**
   * Store delete
   */
  export type StoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter which Store to delete.
     */
    where: StoreWhereUniqueInput
  }


  /**
   * Store deleteMany
   */
  export type StoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoreWhereInput
  }


  /**
   * Store.tasks
   */
  export type Store$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }


  /**
   * Store.milestones
   */
  export type Store$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    cursor?: MilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }


  /**
   * Store.issues
   */
  export type Store$issuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IssueInclude<ExtArgs> | null
    where?: IssueWhereInput
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    cursor?: IssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }


  /**
   * Store.documents
   */
  export type Store$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Store without action
   */
  export type StoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude<ExtArgs> | null
  }



  /**
   * Model Template
   */

  export type AggregateTemplate = {
    _count: TemplateCountAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  export type TemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    version: string | null
    is_active: boolean | null
    created_at: Date | null
  }

  export type TemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    version: string | null
    is_active: boolean | null
    created_at: Date | null
  }

  export type TemplateCountAggregateOutputType = {
    id: number
    name: number
    version: number
    is_active: number
    created_at: number
    _all: number
  }


  export type TemplateMinAggregateInputType = {
    id?: true
    name?: true
    version?: true
    is_active?: true
    created_at?: true
  }

  export type TemplateMaxAggregateInputType = {
    id?: true
    name?: true
    version?: true
    is_active?: true
    created_at?: true
  }

  export type TemplateCountAggregateInputType = {
    id?: true
    name?: true
    version?: true
    is_active?: true
    created_at?: true
    _all?: true
  }

  export type TemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Template to aggregate.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Templates
    **/
    _count?: true | TemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateMaxAggregateInputType
  }

  export type GetTemplateAggregateType<T extends TemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplate[P]>
      : GetScalarType<T[P], AggregateTemplate[P]>
  }




  export type TemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithAggregationInput | TemplateOrderByWithAggregationInput[]
    by: TemplateScalarFieldEnum[] | TemplateScalarFieldEnum
    having?: TemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateCountAggregateInputType | true
    _min?: TemplateMinAggregateInputType
    _max?: TemplateMaxAggregateInputType
  }

  export type TemplateGroupByOutputType = {
    id: string
    name: string
    version: string
    is_active: boolean
    created_at: Date
    _count: TemplateCountAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  type GetTemplateGroupByPayload<T extends TemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    is_active?: boolean
    created_at?: boolean
    phases?: boolean | Template$phasesArgs<ExtArgs>
    _count?: boolean | TemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectScalar = {
    id?: boolean
    name?: boolean
    version?: boolean
    is_active?: boolean
    created_at?: boolean
  }

  export type TemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phases?: boolean | Template$phasesArgs<ExtArgs>
    _count?: boolean | TemplateCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Template"
    objects: {
      phases: Prisma.$TemplatePhasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      version: string
      is_active: boolean
      created_at: Date
    }, ExtArgs["result"]["template"]>
    composites: {}
  }


  type TemplateGetPayload<S extends boolean | null | undefined | TemplateDefaultArgs> = $Result.GetResult<Prisma.$TemplatePayload, S>

  type TemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplateCountAggregateInputType | true
    }

  export interface TemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Template'], meta: { name: 'Template' } }
    /**
     * Find zero or one Template that matches the filter.
     * @param {TemplateFindUniqueArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TemplateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateFindUniqueArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Template that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TemplateFindUniqueOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TemplateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Template that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TemplateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateFindFirstArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Template that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TemplateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Templates
     * const templates = await prisma.template.findMany()
     * 
     * // Get first 10 Templates
     * const templates = await prisma.template.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateWithIdOnly = await prisma.template.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TemplateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Template.
     * @param {TemplateCreateArgs} args - Arguments to create a Template.
     * @example
     * // Create one Template
     * const Template = await prisma.template.create({
     *   data: {
     *     // ... data to create a Template
     *   }
     * })
     * 
    **/
    create<T extends TemplateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateCreateArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Template.
     * @param {TemplateDeleteArgs} args - Arguments to delete one Template.
     * @example
     * // Delete one Template
     * const Template = await prisma.template.delete({
     *   where: {
     *     // ... filter to delete one Template
     *   }
     * })
     * 
    **/
    delete<T extends TemplateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateDeleteArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Template.
     * @param {TemplateUpdateArgs} args - Arguments to update one Template.
     * @example
     * // Update one Template
     * const template = await prisma.template.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TemplateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateUpdateArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Templates.
     * @param {TemplateDeleteManyArgs} args - Arguments to filter Templates to delete.
     * @example
     * // Delete a few Templates
     * const { count } = await prisma.template.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TemplateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TemplateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Template.
     * @param {TemplateUpsertArgs} args - Arguments to update or create a Template.
     * @example
     * // Update or create a Template
     * const template = await prisma.template.upsert({
     *   create: {
     *     // ... data to create a Template
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Template we want to update
     *   }
     * })
    **/
    upsert<T extends TemplateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateUpsertArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCountArgs} args - Arguments to filter Templates to count.
     * @example
     * // Count the number of Templates
     * const count = await prisma.template.count({
     *   where: {
     *     // ... the filter for the Templates we want to count
     *   }
     * })
    **/
    count<T extends TemplateCountArgs>(
      args?: Subset<T, TemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateAggregateArgs>(args: Subset<T, TemplateAggregateArgs>): Prisma.PrismaPromise<GetTemplateAggregateType<T>>

    /**
     * Group by Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateGroupByArgs['orderBy'] }
        : { orderBy?: TemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Template model
   */
  readonly fields: TemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Template.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    phases<T extends Template$phasesArgs<ExtArgs> = {}>(args?: Subset<T, Template$phasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePhasePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Template model
   */ 
  interface TemplateFieldRefs {
    readonly id: FieldRef<"Template", 'String'>
    readonly name: FieldRef<"Template", 'String'>
    readonly version: FieldRef<"Template", 'String'>
    readonly is_active: FieldRef<"Template", 'Boolean'>
    readonly created_at: FieldRef<"Template", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Template findUnique
   */
  export type TemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }


  /**
   * Template findUniqueOrThrow
   */
  export type TemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }


  /**
   * Template findFirst
   */
  export type TemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }


  /**
   * Template findFirstOrThrow
   */
  export type TemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }


  /**
   * Template findMany
   */
  export type TemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Templates to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }


  /**
   * Template create
   */
  export type TemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a Template.
     */
    data: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
  }


  /**
   * Template update
   */
  export type TemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a Template.
     */
    data: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
    /**
     * Choose, which Template to update.
     */
    where: TemplateWhereUniqueInput
  }


  /**
   * Template updateMany
   */
  export type TemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
  }


  /**
   * Template upsert
   */
  export type TemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the Template to update in case it exists.
     */
    where: TemplateWhereUniqueInput
    /**
     * In case the Template found by the `where` argument doesn't exist, create a new Template with this data.
     */
    create: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
    /**
     * In case the Template was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
  }


  /**
   * Template delete
   */
  export type TemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter which Template to delete.
     */
    where: TemplateWhereUniqueInput
  }


  /**
   * Template deleteMany
   */
  export type TemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Templates to delete
     */
    where?: TemplateWhereInput
  }


  /**
   * Template.phases
   */
  export type Template$phasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePhase
     */
    select?: TemplatePhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatePhaseInclude<ExtArgs> | null
    where?: TemplatePhaseWhereInput
    orderBy?: TemplatePhaseOrderByWithRelationInput | TemplatePhaseOrderByWithRelationInput[]
    cursor?: TemplatePhaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplatePhaseScalarFieldEnum | TemplatePhaseScalarFieldEnum[]
  }


  /**
   * Template without action
   */
  export type TemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
  }



  /**
   * Model TemplatePhase
   */

  export type AggregateTemplatePhase = {
    _count: TemplatePhaseCountAggregateOutputType | null
    _avg: TemplatePhaseAvgAggregateOutputType | null
    _sum: TemplatePhaseSumAggregateOutputType | null
    _min: TemplatePhaseMinAggregateOutputType | null
    _max: TemplatePhaseMaxAggregateOutputType | null
  }

  export type TemplatePhaseAvgAggregateOutputType = {
    order: number | null
  }

  export type TemplatePhaseSumAggregateOutputType = {
    order: number | null
  }

  export type TemplatePhaseMinAggregateOutputType = {
    id: string | null
    template_id: string | null
    name: string | null
    order: number | null
  }

  export type TemplatePhaseMaxAggregateOutputType = {
    id: string | null
    template_id: string | null
    name: string | null
    order: number | null
  }

  export type TemplatePhaseCountAggregateOutputType = {
    id: number
    template_id: number
    name: number
    order: number
    _all: number
  }


  export type TemplatePhaseAvgAggregateInputType = {
    order?: true
  }

  export type TemplatePhaseSumAggregateInputType = {
    order?: true
  }

  export type TemplatePhaseMinAggregateInputType = {
    id?: true
    template_id?: true
    name?: true
    order?: true
  }

  export type TemplatePhaseMaxAggregateInputType = {
    id?: true
    template_id?: true
    name?: true
    order?: true
  }

  export type TemplatePhaseCountAggregateInputType = {
    id?: true
    template_id?: true
    name?: true
    order?: true
    _all?: true
  }

  export type TemplatePhaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplatePhase to aggregate.
     */
    where?: TemplatePhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatePhases to fetch.
     */
    orderBy?: TemplatePhaseOrderByWithRelationInput | TemplatePhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplatePhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatePhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatePhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplatePhases
    **/
    _count?: true | TemplatePhaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplatePhaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplatePhaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplatePhaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplatePhaseMaxAggregateInputType
  }

  export type GetTemplatePhaseAggregateType<T extends TemplatePhaseAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplatePhase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplatePhase[P]>
      : GetScalarType<T[P], AggregateTemplatePhase[P]>
  }




  export type TemplatePhaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplatePhaseWhereInput
    orderBy?: TemplatePhaseOrderByWithAggregationInput | TemplatePhaseOrderByWithAggregationInput[]
    by: TemplatePhaseScalarFieldEnum[] | TemplatePhaseScalarFieldEnum
    having?: TemplatePhaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplatePhaseCountAggregateInputType | true
    _avg?: TemplatePhaseAvgAggregateInputType
    _sum?: TemplatePhaseSumAggregateInputType
    _min?: TemplatePhaseMinAggregateInputType
    _max?: TemplatePhaseMaxAggregateInputType
  }

  export type TemplatePhaseGroupByOutputType = {
    id: string
    template_id: string
    name: string
    order: number
    _count: TemplatePhaseCountAggregateOutputType | null
    _avg: TemplatePhaseAvgAggregateOutputType | null
    _sum: TemplatePhaseSumAggregateOutputType | null
    _min: TemplatePhaseMinAggregateOutputType | null
    _max: TemplatePhaseMaxAggregateOutputType | null
  }

  type GetTemplatePhaseGroupByPayload<T extends TemplatePhaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplatePhaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplatePhaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplatePhaseGroupByOutputType[P]>
            : GetScalarType<T[P], TemplatePhaseGroupByOutputType[P]>
        }
      >
    >


  export type TemplatePhaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    template_id?: boolean
    name?: boolean
    order?: boolean
    template?: boolean | TemplateDefaultArgs<ExtArgs>
    tasks?: boolean | TemplatePhase$tasksArgs<ExtArgs>
    _count?: boolean | TemplatePhaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templatePhase"]>

  export type TemplatePhaseSelectScalar = {
    id?: boolean
    template_id?: boolean
    name?: boolean
    order?: boolean
  }

  export type TemplatePhaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | TemplateDefaultArgs<ExtArgs>
    tasks?: boolean | TemplatePhase$tasksArgs<ExtArgs>
    _count?: boolean | TemplatePhaseCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TemplatePhasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplatePhase"
    objects: {
      template: Prisma.$TemplatePayload<ExtArgs>
      tasks: Prisma.$TemplateTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      template_id: string
      name: string
      order: number
    }, ExtArgs["result"]["templatePhase"]>
    composites: {}
  }


  type TemplatePhaseGetPayload<S extends boolean | null | undefined | TemplatePhaseDefaultArgs> = $Result.GetResult<Prisma.$TemplatePhasePayload, S>

  type TemplatePhaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplatePhaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplatePhaseCountAggregateInputType | true
    }

  export interface TemplatePhaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplatePhase'], meta: { name: 'TemplatePhase' } }
    /**
     * Find zero or one TemplatePhase that matches the filter.
     * @param {TemplatePhaseFindUniqueArgs} args - Arguments to find a TemplatePhase
     * @example
     * // Get one TemplatePhase
     * const templatePhase = await prisma.templatePhase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TemplatePhaseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TemplatePhaseFindUniqueArgs<ExtArgs>>
    ): Prisma__TemplatePhaseClient<$Result.GetResult<Prisma.$TemplatePhasePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TemplatePhase that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TemplatePhaseFindUniqueOrThrowArgs} args - Arguments to find a TemplatePhase
     * @example
     * // Get one TemplatePhase
     * const templatePhase = await prisma.templatePhase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TemplatePhaseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplatePhaseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TemplatePhaseClient<$Result.GetResult<Prisma.$TemplatePhasePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TemplatePhase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatePhaseFindFirstArgs} args - Arguments to find a TemplatePhase
     * @example
     * // Get one TemplatePhase
     * const templatePhase = await prisma.templatePhase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TemplatePhaseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplatePhaseFindFirstArgs<ExtArgs>>
    ): Prisma__TemplatePhaseClient<$Result.GetResult<Prisma.$TemplatePhasePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TemplatePhase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatePhaseFindFirstOrThrowArgs} args - Arguments to find a TemplatePhase
     * @example
     * // Get one TemplatePhase
     * const templatePhase = await prisma.templatePhase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TemplatePhaseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplatePhaseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TemplatePhaseClient<$Result.GetResult<Prisma.$TemplatePhasePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TemplatePhases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatePhaseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplatePhases
     * const templatePhases = await prisma.templatePhase.findMany()
     * 
     * // Get first 10 TemplatePhases
     * const templatePhases = await prisma.templatePhase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templatePhaseWithIdOnly = await prisma.templatePhase.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TemplatePhaseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplatePhaseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePhasePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TemplatePhase.
     * @param {TemplatePhaseCreateArgs} args - Arguments to create a TemplatePhase.
     * @example
     * // Create one TemplatePhase
     * const TemplatePhase = await prisma.templatePhase.create({
     *   data: {
     *     // ... data to create a TemplatePhase
     *   }
     * })
     * 
    **/
    create<T extends TemplatePhaseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TemplatePhaseCreateArgs<ExtArgs>>
    ): Prisma__TemplatePhaseClient<$Result.GetResult<Prisma.$TemplatePhasePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a TemplatePhase.
     * @param {TemplatePhaseDeleteArgs} args - Arguments to delete one TemplatePhase.
     * @example
     * // Delete one TemplatePhase
     * const TemplatePhase = await prisma.templatePhase.delete({
     *   where: {
     *     // ... filter to delete one TemplatePhase
     *   }
     * })
     * 
    **/
    delete<T extends TemplatePhaseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TemplatePhaseDeleteArgs<ExtArgs>>
    ): Prisma__TemplatePhaseClient<$Result.GetResult<Prisma.$TemplatePhasePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TemplatePhase.
     * @param {TemplatePhaseUpdateArgs} args - Arguments to update one TemplatePhase.
     * @example
     * // Update one TemplatePhase
     * const templatePhase = await prisma.templatePhase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TemplatePhaseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TemplatePhaseUpdateArgs<ExtArgs>>
    ): Prisma__TemplatePhaseClient<$Result.GetResult<Prisma.$TemplatePhasePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TemplatePhases.
     * @param {TemplatePhaseDeleteManyArgs} args - Arguments to filter TemplatePhases to delete.
     * @example
     * // Delete a few TemplatePhases
     * const { count } = await prisma.templatePhase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TemplatePhaseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplatePhaseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplatePhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatePhaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplatePhases
     * const templatePhase = await prisma.templatePhase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TemplatePhaseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TemplatePhaseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplatePhase.
     * @param {TemplatePhaseUpsertArgs} args - Arguments to update or create a TemplatePhase.
     * @example
     * // Update or create a TemplatePhase
     * const templatePhase = await prisma.templatePhase.upsert({
     *   create: {
     *     // ... data to create a TemplatePhase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplatePhase we want to update
     *   }
     * })
    **/
    upsert<T extends TemplatePhaseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TemplatePhaseUpsertArgs<ExtArgs>>
    ): Prisma__TemplatePhaseClient<$Result.GetResult<Prisma.$TemplatePhasePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TemplatePhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatePhaseCountArgs} args - Arguments to filter TemplatePhases to count.
     * @example
     * // Count the number of TemplatePhases
     * const count = await prisma.templatePhase.count({
     *   where: {
     *     // ... the filter for the TemplatePhases we want to count
     *   }
     * })
    **/
    count<T extends TemplatePhaseCountArgs>(
      args?: Subset<T, TemplatePhaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplatePhaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplatePhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatePhaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplatePhaseAggregateArgs>(args: Subset<T, TemplatePhaseAggregateArgs>): Prisma.PrismaPromise<GetTemplatePhaseAggregateType<T>>

    /**
     * Group by TemplatePhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatePhaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplatePhaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplatePhaseGroupByArgs['orderBy'] }
        : { orderBy?: TemplatePhaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplatePhaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplatePhaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplatePhase model
   */
  readonly fields: TemplatePhaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplatePhase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplatePhaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    template<T extends TemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TemplateDefaultArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    tasks<T extends TemplatePhase$tasksArgs<ExtArgs> = {}>(args?: Subset<T, TemplatePhase$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateTaskPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TemplatePhase model
   */ 
  interface TemplatePhaseFieldRefs {
    readonly id: FieldRef<"TemplatePhase", 'String'>
    readonly template_id: FieldRef<"TemplatePhase", 'String'>
    readonly name: FieldRef<"TemplatePhase", 'String'>
    readonly order: FieldRef<"TemplatePhase", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * TemplatePhase findUnique
   */
  export type TemplatePhaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePhase
     */
    select?: TemplatePhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatePhaseInclude<ExtArgs> | null
    /**
     * Filter, which TemplatePhase to fetch.
     */
    where: TemplatePhaseWhereUniqueInput
  }


  /**
   * TemplatePhase findUniqueOrThrow
   */
  export type TemplatePhaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePhase
     */
    select?: TemplatePhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatePhaseInclude<ExtArgs> | null
    /**
     * Filter, which TemplatePhase to fetch.
     */
    where: TemplatePhaseWhereUniqueInput
  }


  /**
   * TemplatePhase findFirst
   */
  export type TemplatePhaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePhase
     */
    select?: TemplatePhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatePhaseInclude<ExtArgs> | null
    /**
     * Filter, which TemplatePhase to fetch.
     */
    where?: TemplatePhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatePhases to fetch.
     */
    orderBy?: TemplatePhaseOrderByWithRelationInput | TemplatePhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplatePhases.
     */
    cursor?: TemplatePhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatePhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatePhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplatePhases.
     */
    distinct?: TemplatePhaseScalarFieldEnum | TemplatePhaseScalarFieldEnum[]
  }


  /**
   * TemplatePhase findFirstOrThrow
   */
  export type TemplatePhaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePhase
     */
    select?: TemplatePhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatePhaseInclude<ExtArgs> | null
    /**
     * Filter, which TemplatePhase to fetch.
     */
    where?: TemplatePhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatePhases to fetch.
     */
    orderBy?: TemplatePhaseOrderByWithRelationInput | TemplatePhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplatePhases.
     */
    cursor?: TemplatePhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatePhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatePhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplatePhases.
     */
    distinct?: TemplatePhaseScalarFieldEnum | TemplatePhaseScalarFieldEnum[]
  }


  /**
   * TemplatePhase findMany
   */
  export type TemplatePhaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePhase
     */
    select?: TemplatePhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatePhaseInclude<ExtArgs> | null
    /**
     * Filter, which TemplatePhases to fetch.
     */
    where?: TemplatePhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplatePhases to fetch.
     */
    orderBy?: TemplatePhaseOrderByWithRelationInput | TemplatePhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplatePhases.
     */
    cursor?: TemplatePhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplatePhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplatePhases.
     */
    skip?: number
    distinct?: TemplatePhaseScalarFieldEnum | TemplatePhaseScalarFieldEnum[]
  }


  /**
   * TemplatePhase create
   */
  export type TemplatePhaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePhase
     */
    select?: TemplatePhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatePhaseInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplatePhase.
     */
    data: XOR<TemplatePhaseCreateInput, TemplatePhaseUncheckedCreateInput>
  }


  /**
   * TemplatePhase update
   */
  export type TemplatePhaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePhase
     */
    select?: TemplatePhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatePhaseInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplatePhase.
     */
    data: XOR<TemplatePhaseUpdateInput, TemplatePhaseUncheckedUpdateInput>
    /**
     * Choose, which TemplatePhase to update.
     */
    where: TemplatePhaseWhereUniqueInput
  }


  /**
   * TemplatePhase updateMany
   */
  export type TemplatePhaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplatePhases.
     */
    data: XOR<TemplatePhaseUpdateManyMutationInput, TemplatePhaseUncheckedUpdateManyInput>
    /**
     * Filter which TemplatePhases to update
     */
    where?: TemplatePhaseWhereInput
  }


  /**
   * TemplatePhase upsert
   */
  export type TemplatePhaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePhase
     */
    select?: TemplatePhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatePhaseInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplatePhase to update in case it exists.
     */
    where: TemplatePhaseWhereUniqueInput
    /**
     * In case the TemplatePhase found by the `where` argument doesn't exist, create a new TemplatePhase with this data.
     */
    create: XOR<TemplatePhaseCreateInput, TemplatePhaseUncheckedCreateInput>
    /**
     * In case the TemplatePhase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplatePhaseUpdateInput, TemplatePhaseUncheckedUpdateInput>
  }


  /**
   * TemplatePhase delete
   */
  export type TemplatePhaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePhase
     */
    select?: TemplatePhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatePhaseInclude<ExtArgs> | null
    /**
     * Filter which TemplatePhase to delete.
     */
    where: TemplatePhaseWhereUniqueInput
  }


  /**
   * TemplatePhase deleteMany
   */
  export type TemplatePhaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplatePhases to delete
     */
    where?: TemplatePhaseWhereInput
  }


  /**
   * TemplatePhase.tasks
   */
  export type TemplatePhase$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateTask
     */
    select?: TemplateTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateTaskInclude<ExtArgs> | null
    where?: TemplateTaskWhereInput
    orderBy?: TemplateTaskOrderByWithRelationInput | TemplateTaskOrderByWithRelationInput[]
    cursor?: TemplateTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateTaskScalarFieldEnum | TemplateTaskScalarFieldEnum[]
  }


  /**
   * TemplatePhase without action
   */
  export type TemplatePhaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplatePhase
     */
    select?: TemplatePhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplatePhaseInclude<ExtArgs> | null
  }



  /**
   * Model TemplateTask
   */

  export type AggregateTemplateTask = {
    _count: TemplateTaskCountAggregateOutputType | null
    _avg: TemplateTaskAvgAggregateOutputType | null
    _sum: TemplateTaskSumAggregateOutputType | null
    _min: TemplateTaskMinAggregateOutputType | null
    _max: TemplateTaskMaxAggregateOutputType | null
  }

  export type TemplateTaskAvgAggregateOutputType = {
    duration_days: number | null
    offset_days: number | null
  }

  export type TemplateTaskSumAggregateOutputType = {
    duration_days: number | null
    offset_days: number | null
  }

  export type TemplateTaskMinAggregateOutputType = {
    id: string | null
    phase_id: string | null
    name: string | null
    description: string | null
    role_responsible: string | null
    duration_days: number | null
    anchor_event: string | null
    offset_days: number | null
    workday_rule: string | null
    is_milestone: boolean | null
    dependency_indices: string | null
  }

  export type TemplateTaskMaxAggregateOutputType = {
    id: string | null
    phase_id: string | null
    name: string | null
    description: string | null
    role_responsible: string | null
    duration_days: number | null
    anchor_event: string | null
    offset_days: number | null
    workday_rule: string | null
    is_milestone: boolean | null
    dependency_indices: string | null
  }

  export type TemplateTaskCountAggregateOutputType = {
    id: number
    phase_id: number
    name: number
    description: number
    role_responsible: number
    duration_days: number
    anchor_event: number
    offset_days: number
    workday_rule: number
    is_milestone: number
    dependency_indices: number
    _all: number
  }


  export type TemplateTaskAvgAggregateInputType = {
    duration_days?: true
    offset_days?: true
  }

  export type TemplateTaskSumAggregateInputType = {
    duration_days?: true
    offset_days?: true
  }

  export type TemplateTaskMinAggregateInputType = {
    id?: true
    phase_id?: true
    name?: true
    description?: true
    role_responsible?: true
    duration_days?: true
    anchor_event?: true
    offset_days?: true
    workday_rule?: true
    is_milestone?: true
    dependency_indices?: true
  }

  export type TemplateTaskMaxAggregateInputType = {
    id?: true
    phase_id?: true
    name?: true
    description?: true
    role_responsible?: true
    duration_days?: true
    anchor_event?: true
    offset_days?: true
    workday_rule?: true
    is_milestone?: true
    dependency_indices?: true
  }

  export type TemplateTaskCountAggregateInputType = {
    id?: true
    phase_id?: true
    name?: true
    description?: true
    role_responsible?: true
    duration_days?: true
    anchor_event?: true
    offset_days?: true
    workday_rule?: true
    is_milestone?: true
    dependency_indices?: true
    _all?: true
  }

  export type TemplateTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateTask to aggregate.
     */
    where?: TemplateTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateTasks to fetch.
     */
    orderBy?: TemplateTaskOrderByWithRelationInput | TemplateTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateTasks
    **/
    _count?: true | TemplateTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateTaskMaxAggregateInputType
  }

  export type GetTemplateTaskAggregateType<T extends TemplateTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateTask[P]>
      : GetScalarType<T[P], AggregateTemplateTask[P]>
  }




  export type TemplateTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateTaskWhereInput
    orderBy?: TemplateTaskOrderByWithAggregationInput | TemplateTaskOrderByWithAggregationInput[]
    by: TemplateTaskScalarFieldEnum[] | TemplateTaskScalarFieldEnum
    having?: TemplateTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateTaskCountAggregateInputType | true
    _avg?: TemplateTaskAvgAggregateInputType
    _sum?: TemplateTaskSumAggregateInputType
    _min?: TemplateTaskMinAggregateInputType
    _max?: TemplateTaskMaxAggregateInputType
  }

  export type TemplateTaskGroupByOutputType = {
    id: string
    phase_id: string
    name: string
    description: string | null
    role_responsible: string
    duration_days: number
    anchor_event: string
    offset_days: number
    workday_rule: string
    is_milestone: boolean
    dependency_indices: string | null
    _count: TemplateTaskCountAggregateOutputType | null
    _avg: TemplateTaskAvgAggregateOutputType | null
    _sum: TemplateTaskSumAggregateOutputType | null
    _min: TemplateTaskMinAggregateOutputType | null
    _max: TemplateTaskMaxAggregateOutputType | null
  }

  type GetTemplateTaskGroupByPayload<T extends TemplateTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateTaskGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateTaskGroupByOutputType[P]>
        }
      >
    >


  export type TemplateTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phase_id?: boolean
    name?: boolean
    description?: boolean
    role_responsible?: boolean
    duration_days?: boolean
    anchor_event?: boolean
    offset_days?: boolean
    workday_rule?: boolean
    is_milestone?: boolean
    dependency_indices?: boolean
    phase?: boolean | TemplatePhaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateTask"]>

  export type TemplateTaskSelectScalar = {
    id?: boolean
    phase_id?: boolean
    name?: boolean
    description?: boolean
    role_responsible?: boolean
    duration_days?: boolean
    anchor_event?: boolean
    offset_days?: boolean
    workday_rule?: boolean
    is_milestone?: boolean
    dependency_indices?: boolean
  }

  export type TemplateTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phase?: boolean | TemplatePhaseDefaultArgs<ExtArgs>
  }


  export type $TemplateTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateTask"
    objects: {
      phase: Prisma.$TemplatePhasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phase_id: string
      name: string
      description: string | null
      role_responsible: string
      duration_days: number
      anchor_event: string
      offset_days: number
      workday_rule: string
      is_milestone: boolean
      dependency_indices: string | null
    }, ExtArgs["result"]["templateTask"]>
    composites: {}
  }


  type TemplateTaskGetPayload<S extends boolean | null | undefined | TemplateTaskDefaultArgs> = $Result.GetResult<Prisma.$TemplateTaskPayload, S>

  type TemplateTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplateTaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplateTaskCountAggregateInputType | true
    }

  export interface TemplateTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateTask'], meta: { name: 'TemplateTask' } }
    /**
     * Find zero or one TemplateTask that matches the filter.
     * @param {TemplateTaskFindUniqueArgs} args - Arguments to find a TemplateTask
     * @example
     * // Get one TemplateTask
     * const templateTask = await prisma.templateTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TemplateTaskFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateTaskFindUniqueArgs<ExtArgs>>
    ): Prisma__TemplateTaskClient<$Result.GetResult<Prisma.$TemplateTaskPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TemplateTask that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TemplateTaskFindUniqueOrThrowArgs} args - Arguments to find a TemplateTask
     * @example
     * // Get one TemplateTask
     * const templateTask = await prisma.templateTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TemplateTaskFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateTaskFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TemplateTaskClient<$Result.GetResult<Prisma.$TemplateTaskPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TemplateTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateTaskFindFirstArgs} args - Arguments to find a TemplateTask
     * @example
     * // Get one TemplateTask
     * const templateTask = await prisma.templateTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TemplateTaskFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateTaskFindFirstArgs<ExtArgs>>
    ): Prisma__TemplateTaskClient<$Result.GetResult<Prisma.$TemplateTaskPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TemplateTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateTaskFindFirstOrThrowArgs} args - Arguments to find a TemplateTask
     * @example
     * // Get one TemplateTask
     * const templateTask = await prisma.templateTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TemplateTaskFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateTaskFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TemplateTaskClient<$Result.GetResult<Prisma.$TemplateTaskPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TemplateTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateTaskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateTasks
     * const templateTasks = await prisma.templateTask.findMany()
     * 
     * // Get first 10 TemplateTasks
     * const templateTasks = await prisma.templateTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateTaskWithIdOnly = await prisma.templateTask.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TemplateTaskFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateTaskFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateTaskPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TemplateTask.
     * @param {TemplateTaskCreateArgs} args - Arguments to create a TemplateTask.
     * @example
     * // Create one TemplateTask
     * const TemplateTask = await prisma.templateTask.create({
     *   data: {
     *     // ... data to create a TemplateTask
     *   }
     * })
     * 
    **/
    create<T extends TemplateTaskCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateTaskCreateArgs<ExtArgs>>
    ): Prisma__TemplateTaskClient<$Result.GetResult<Prisma.$TemplateTaskPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a TemplateTask.
     * @param {TemplateTaskDeleteArgs} args - Arguments to delete one TemplateTask.
     * @example
     * // Delete one TemplateTask
     * const TemplateTask = await prisma.templateTask.delete({
     *   where: {
     *     // ... filter to delete one TemplateTask
     *   }
     * })
     * 
    **/
    delete<T extends TemplateTaskDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateTaskDeleteArgs<ExtArgs>>
    ): Prisma__TemplateTaskClient<$Result.GetResult<Prisma.$TemplateTaskPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TemplateTask.
     * @param {TemplateTaskUpdateArgs} args - Arguments to update one TemplateTask.
     * @example
     * // Update one TemplateTask
     * const templateTask = await prisma.templateTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TemplateTaskUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateTaskUpdateArgs<ExtArgs>>
    ): Prisma__TemplateTaskClient<$Result.GetResult<Prisma.$TemplateTaskPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TemplateTasks.
     * @param {TemplateTaskDeleteManyArgs} args - Arguments to filter TemplateTasks to delete.
     * @example
     * // Delete a few TemplateTasks
     * const { count } = await prisma.templateTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TemplateTaskDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateTaskDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateTasks
     * const templateTask = await prisma.templateTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TemplateTaskUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateTaskUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplateTask.
     * @param {TemplateTaskUpsertArgs} args - Arguments to update or create a TemplateTask.
     * @example
     * // Update or create a TemplateTask
     * const templateTask = await prisma.templateTask.upsert({
     *   create: {
     *     // ... data to create a TemplateTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateTask we want to update
     *   }
     * })
    **/
    upsert<T extends TemplateTaskUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateTaskUpsertArgs<ExtArgs>>
    ): Prisma__TemplateTaskClient<$Result.GetResult<Prisma.$TemplateTaskPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TemplateTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateTaskCountArgs} args - Arguments to filter TemplateTasks to count.
     * @example
     * // Count the number of TemplateTasks
     * const count = await prisma.templateTask.count({
     *   where: {
     *     // ... the filter for the TemplateTasks we want to count
     *   }
     * })
    **/
    count<T extends TemplateTaskCountArgs>(
      args?: Subset<T, TemplateTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateTaskAggregateArgs>(args: Subset<T, TemplateTaskAggregateArgs>): Prisma.PrismaPromise<GetTemplateTaskAggregateType<T>>

    /**
     * Group by TemplateTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateTaskGroupByArgs['orderBy'] }
        : { orderBy?: TemplateTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateTask model
   */
  readonly fields: TemplateTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    phase<T extends TemplatePhaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TemplatePhaseDefaultArgs<ExtArgs>>): Prisma__TemplatePhaseClient<$Result.GetResult<Prisma.$TemplatePhasePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TemplateTask model
   */ 
  interface TemplateTaskFieldRefs {
    readonly id: FieldRef<"TemplateTask", 'String'>
    readonly phase_id: FieldRef<"TemplateTask", 'String'>
    readonly name: FieldRef<"TemplateTask", 'String'>
    readonly description: FieldRef<"TemplateTask", 'String'>
    readonly role_responsible: FieldRef<"TemplateTask", 'String'>
    readonly duration_days: FieldRef<"TemplateTask", 'Int'>
    readonly anchor_event: FieldRef<"TemplateTask", 'String'>
    readonly offset_days: FieldRef<"TemplateTask", 'Int'>
    readonly workday_rule: FieldRef<"TemplateTask", 'String'>
    readonly is_milestone: FieldRef<"TemplateTask", 'Boolean'>
    readonly dependency_indices: FieldRef<"TemplateTask", 'String'>
  }
    

  // Custom InputTypes

  /**
   * TemplateTask findUnique
   */
  export type TemplateTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateTask
     */
    select?: TemplateTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateTaskInclude<ExtArgs> | null
    /**
     * Filter, which TemplateTask to fetch.
     */
    where: TemplateTaskWhereUniqueInput
  }


  /**
   * TemplateTask findUniqueOrThrow
   */
  export type TemplateTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateTask
     */
    select?: TemplateTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateTaskInclude<ExtArgs> | null
    /**
     * Filter, which TemplateTask to fetch.
     */
    where: TemplateTaskWhereUniqueInput
  }


  /**
   * TemplateTask findFirst
   */
  export type TemplateTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateTask
     */
    select?: TemplateTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateTaskInclude<ExtArgs> | null
    /**
     * Filter, which TemplateTask to fetch.
     */
    where?: TemplateTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateTasks to fetch.
     */
    orderBy?: TemplateTaskOrderByWithRelationInput | TemplateTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateTasks.
     */
    cursor?: TemplateTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateTasks.
     */
    distinct?: TemplateTaskScalarFieldEnum | TemplateTaskScalarFieldEnum[]
  }


  /**
   * TemplateTask findFirstOrThrow
   */
  export type TemplateTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateTask
     */
    select?: TemplateTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateTaskInclude<ExtArgs> | null
    /**
     * Filter, which TemplateTask to fetch.
     */
    where?: TemplateTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateTasks to fetch.
     */
    orderBy?: TemplateTaskOrderByWithRelationInput | TemplateTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateTasks.
     */
    cursor?: TemplateTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateTasks.
     */
    distinct?: TemplateTaskScalarFieldEnum | TemplateTaskScalarFieldEnum[]
  }


  /**
   * TemplateTask findMany
   */
  export type TemplateTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateTask
     */
    select?: TemplateTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateTaskInclude<ExtArgs> | null
    /**
     * Filter, which TemplateTasks to fetch.
     */
    where?: TemplateTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateTasks to fetch.
     */
    orderBy?: TemplateTaskOrderByWithRelationInput | TemplateTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateTasks.
     */
    cursor?: TemplateTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateTasks.
     */
    skip?: number
    distinct?: TemplateTaskScalarFieldEnum | TemplateTaskScalarFieldEnum[]
  }


  /**
   * TemplateTask create
   */
  export type TemplateTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateTask
     */
    select?: TemplateTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplateTask.
     */
    data: XOR<TemplateTaskCreateInput, TemplateTaskUncheckedCreateInput>
  }


  /**
   * TemplateTask update
   */
  export type TemplateTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateTask
     */
    select?: TemplateTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplateTask.
     */
    data: XOR<TemplateTaskUpdateInput, TemplateTaskUncheckedUpdateInput>
    /**
     * Choose, which TemplateTask to update.
     */
    where: TemplateTaskWhereUniqueInput
  }


  /**
   * TemplateTask updateMany
   */
  export type TemplateTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateTasks.
     */
    data: XOR<TemplateTaskUpdateManyMutationInput, TemplateTaskUncheckedUpdateManyInput>
    /**
     * Filter which TemplateTasks to update
     */
    where?: TemplateTaskWhereInput
  }


  /**
   * TemplateTask upsert
   */
  export type TemplateTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateTask
     */
    select?: TemplateTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplateTask to update in case it exists.
     */
    where: TemplateTaskWhereUniqueInput
    /**
     * In case the TemplateTask found by the `where` argument doesn't exist, create a new TemplateTask with this data.
     */
    create: XOR<TemplateTaskCreateInput, TemplateTaskUncheckedCreateInput>
    /**
     * In case the TemplateTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateTaskUpdateInput, TemplateTaskUncheckedUpdateInput>
  }


  /**
   * TemplateTask delete
   */
  export type TemplateTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateTask
     */
    select?: TemplateTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateTaskInclude<ExtArgs> | null
    /**
     * Filter which TemplateTask to delete.
     */
    where: TemplateTaskWhereUniqueInput
  }


  /**
   * TemplateTask deleteMany
   */
  export type TemplateTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateTasks to delete
     */
    where?: TemplateTaskWhereInput
  }


  /**
   * TemplateTask without action
   */
  export type TemplateTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateTask
     */
    select?: TemplateTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateTaskInclude<ExtArgs> | null
  }



  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    store_id: string | null
    title: string | null
    description: string | null
    phase: string | null
    status: string | null
    priority: string | null
    start_date: Date | null
    due_date: Date | null
    completed_at: Date | null
    role: string | null
    manual_override: boolean | null
    locked: boolean | null
    reschedule_mode: string | null
    calendar_rule: string | null
    anchor: string | null
    owner_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    store_id: string | null
    title: string | null
    description: string | null
    phase: string | null
    status: string | null
    priority: string | null
    start_date: Date | null
    due_date: Date | null
    completed_at: Date | null
    role: string | null
    manual_override: boolean | null
    locked: boolean | null
    reschedule_mode: string | null
    calendar_rule: string | null
    anchor: string | null
    owner_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    store_id: number
    title: number
    description: number
    phase: number
    status: number
    priority: number
    start_date: number
    due_date: number
    completed_at: number
    role: number
    manual_override: number
    locked: number
    reschedule_mode: number
    calendar_rule: number
    anchor: number
    owner_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    store_id?: true
    title?: true
    description?: true
    phase?: true
    status?: true
    priority?: true
    start_date?: true
    due_date?: true
    completed_at?: true
    role?: true
    manual_override?: true
    locked?: true
    reschedule_mode?: true
    calendar_rule?: true
    anchor?: true
    owner_id?: true
    created_at?: true
    updated_at?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    store_id?: true
    title?: true
    description?: true
    phase?: true
    status?: true
    priority?: true
    start_date?: true
    due_date?: true
    completed_at?: true
    role?: true
    manual_override?: true
    locked?: true
    reschedule_mode?: true
    calendar_rule?: true
    anchor?: true
    owner_id?: true
    created_at?: true
    updated_at?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    store_id?: true
    title?: true
    description?: true
    phase?: true
    status?: true
    priority?: true
    start_date?: true
    due_date?: true
    completed_at?: true
    role?: true
    manual_override?: true
    locked?: true
    reschedule_mode?: true
    calendar_rule?: true
    anchor?: true
    owner_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    store_id: string
    title: string
    description: string | null
    phase: string
    status: string
    priority: string
    start_date: Date | null
    due_date: Date | null
    completed_at: Date | null
    role: string | null
    manual_override: boolean
    locked: boolean
    reschedule_mode: string
    calendar_rule: string
    anchor: string | null
    owner_id: string | null
    created_at: Date
    updated_at: Date
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    title?: boolean
    description?: boolean
    phase?: boolean
    status?: boolean
    priority?: boolean
    start_date?: boolean
    due_date?: boolean
    completed_at?: boolean
    role?: boolean
    manual_override?: boolean
    locked?: boolean
    reschedule_mode?: boolean
    calendar_rule?: boolean
    anchor?: boolean
    owner_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    owner?: boolean | Task$ownerArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    dependencies?: boolean | Task$dependenciesArgs<ExtArgs>
    dependents?: boolean | Task$dependentsArgs<ExtArgs>
    collaborators?: boolean | Task$collaboratorsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    store_id?: boolean
    title?: boolean
    description?: boolean
    phase?: boolean
    status?: boolean
    priority?: boolean
    start_date?: boolean
    due_date?: boolean
    completed_at?: boolean
    role?: boolean
    manual_override?: boolean
    locked?: boolean
    reschedule_mode?: boolean
    calendar_rule?: boolean
    anchor?: boolean
    owner_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Task$ownerArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    dependencies?: boolean | Task$dependenciesArgs<ExtArgs>
    dependents?: boolean | Task$dependentsArgs<ExtArgs>
    collaborators?: boolean | Task$collaboratorsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs> | null
      store: Prisma.$StorePayload<ExtArgs>
      dependencies: Prisma.$TaskDependencyPayload<ExtArgs>[]
      dependents: Prisma.$TaskDependencyPayload<ExtArgs>[]
      collaborators: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      store_id: string
      title: string
      description: string | null
      phase: string
      status: string
      priority: string
      start_date: Date | null
      due_date: Date | null
      completed_at: Date | null
      role: string | null
      manual_override: boolean
      locked: boolean
      reschedule_mode: string
      calendar_rule: string
      anchor: string | null
      owner_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }


  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TaskFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TaskFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TaskFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
    **/
    create<T extends TaskCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TaskCreateArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
    **/
    delete<T extends TaskDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TaskUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TaskDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TaskUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
    **/
    upsert<T extends TaskUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    owner<T extends Task$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Task$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    dependencies<T extends Task$dependenciesArgs<ExtArgs> = {}>(args?: Subset<T, Task$dependenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'findMany'> | Null>;

    dependents<T extends Task$dependentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$dependentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'findMany'> | Null>;

    collaborators<T extends Task$collaboratorsArgs<ExtArgs> = {}>(args?: Subset<T, Task$collaboratorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly store_id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly phase: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'String'>
    readonly priority: FieldRef<"Task", 'String'>
    readonly start_date: FieldRef<"Task", 'DateTime'>
    readonly due_date: FieldRef<"Task", 'DateTime'>
    readonly completed_at: FieldRef<"Task", 'DateTime'>
    readonly role: FieldRef<"Task", 'String'>
    readonly manual_override: FieldRef<"Task", 'Boolean'>
    readonly locked: FieldRef<"Task", 'Boolean'>
    readonly reschedule_mode: FieldRef<"Task", 'String'>
    readonly calendar_rule: FieldRef<"Task", 'String'>
    readonly anchor: FieldRef<"Task", 'String'>
    readonly owner_id: FieldRef<"Task", 'String'>
    readonly created_at: FieldRef<"Task", 'DateTime'>
    readonly updated_at: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }


  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }


  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }


  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }


  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }


  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }


  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }


  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }


  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }


  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }


  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }


  /**
   * Task.owner
   */
  export type Task$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Task.dependencies
   */
  export type Task$dependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    where?: TaskDependencyWhereInput
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    cursor?: TaskDependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[]
  }


  /**
   * Task.dependents
   */
  export type Task$dependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    where?: TaskDependencyWhereInput
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    cursor?: TaskDependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[]
  }


  /**
   * Task.collaborators
   */
  export type Task$collaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
  }



  /**
   * Model TaskDependency
   */

  export type AggregateTaskDependency = {
    _count: TaskDependencyCountAggregateOutputType | null
    _min: TaskDependencyMinAggregateOutputType | null
    _max: TaskDependencyMaxAggregateOutputType | null
  }

  export type TaskDependencyMinAggregateOutputType = {
    task_id: string | null
    depends_on_id: string | null
  }

  export type TaskDependencyMaxAggregateOutputType = {
    task_id: string | null
    depends_on_id: string | null
  }

  export type TaskDependencyCountAggregateOutputType = {
    task_id: number
    depends_on_id: number
    _all: number
  }


  export type TaskDependencyMinAggregateInputType = {
    task_id?: true
    depends_on_id?: true
  }

  export type TaskDependencyMaxAggregateInputType = {
    task_id?: true
    depends_on_id?: true
  }

  export type TaskDependencyCountAggregateInputType = {
    task_id?: true
    depends_on_id?: true
    _all?: true
  }

  export type TaskDependencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDependency to aggregate.
     */
    where?: TaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDependencies to fetch.
     */
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskDependencies
    **/
    _count?: true | TaskDependencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskDependencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskDependencyMaxAggregateInputType
  }

  export type GetTaskDependencyAggregateType<T extends TaskDependencyAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskDependency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskDependency[P]>
      : GetScalarType<T[P], AggregateTaskDependency[P]>
  }




  export type TaskDependencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDependencyWhereInput
    orderBy?: TaskDependencyOrderByWithAggregationInput | TaskDependencyOrderByWithAggregationInput[]
    by: TaskDependencyScalarFieldEnum[] | TaskDependencyScalarFieldEnum
    having?: TaskDependencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskDependencyCountAggregateInputType | true
    _min?: TaskDependencyMinAggregateInputType
    _max?: TaskDependencyMaxAggregateInputType
  }

  export type TaskDependencyGroupByOutputType = {
    task_id: string
    depends_on_id: string
    _count: TaskDependencyCountAggregateOutputType | null
    _min: TaskDependencyMinAggregateOutputType | null
    _max: TaskDependencyMaxAggregateOutputType | null
  }

  type GetTaskDependencyGroupByPayload<T extends TaskDependencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskDependencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskDependencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskDependencyGroupByOutputType[P]>
            : GetScalarType<T[P], TaskDependencyGroupByOutputType[P]>
        }
      >
    >


  export type TaskDependencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    task_id?: boolean
    depends_on_id?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    depends_on?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskDependency"]>

  export type TaskDependencySelectScalar = {
    task_id?: boolean
    depends_on_id?: boolean
  }

  export type TaskDependencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    depends_on?: boolean | TaskDefaultArgs<ExtArgs>
  }


  export type $TaskDependencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskDependency"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      depends_on: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      task_id: string
      depends_on_id: string
    }, ExtArgs["result"]["taskDependency"]>
    composites: {}
  }


  type TaskDependencyGetPayload<S extends boolean | null | undefined | TaskDependencyDefaultArgs> = $Result.GetResult<Prisma.$TaskDependencyPayload, S>

  type TaskDependencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskDependencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskDependencyCountAggregateInputType | true
    }

  export interface TaskDependencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskDependency'], meta: { name: 'TaskDependency' } }
    /**
     * Find zero or one TaskDependency that matches the filter.
     * @param {TaskDependencyFindUniqueArgs} args - Arguments to find a TaskDependency
     * @example
     * // Get one TaskDependency
     * const taskDependency = await prisma.taskDependency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TaskDependencyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TaskDependencyFindUniqueArgs<ExtArgs>>
    ): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TaskDependency that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TaskDependencyFindUniqueOrThrowArgs} args - Arguments to find a TaskDependency
     * @example
     * // Get one TaskDependency
     * const taskDependency = await prisma.taskDependency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TaskDependencyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskDependencyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TaskDependency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyFindFirstArgs} args - Arguments to find a TaskDependency
     * @example
     * // Get one TaskDependency
     * const taskDependency = await prisma.taskDependency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TaskDependencyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskDependencyFindFirstArgs<ExtArgs>>
    ): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TaskDependency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyFindFirstOrThrowArgs} args - Arguments to find a TaskDependency
     * @example
     * // Get one TaskDependency
     * const taskDependency = await prisma.taskDependency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TaskDependencyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskDependencyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TaskDependencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskDependencies
     * const taskDependencies = await prisma.taskDependency.findMany()
     * 
     * // Get first 10 TaskDependencies
     * const taskDependencies = await prisma.taskDependency.findMany({ take: 10 })
     * 
     * // Only select the `task_id`
     * const taskDependencyWithTask_idOnly = await prisma.taskDependency.findMany({ select: { task_id: true } })
     * 
    **/
    findMany<T extends TaskDependencyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskDependencyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TaskDependency.
     * @param {TaskDependencyCreateArgs} args - Arguments to create a TaskDependency.
     * @example
     * // Create one TaskDependency
     * const TaskDependency = await prisma.taskDependency.create({
     *   data: {
     *     // ... data to create a TaskDependency
     *   }
     * })
     * 
    **/
    create<T extends TaskDependencyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TaskDependencyCreateArgs<ExtArgs>>
    ): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a TaskDependency.
     * @param {TaskDependencyDeleteArgs} args - Arguments to delete one TaskDependency.
     * @example
     * // Delete one TaskDependency
     * const TaskDependency = await prisma.taskDependency.delete({
     *   where: {
     *     // ... filter to delete one TaskDependency
     *   }
     * })
     * 
    **/
    delete<T extends TaskDependencyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TaskDependencyDeleteArgs<ExtArgs>>
    ): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TaskDependency.
     * @param {TaskDependencyUpdateArgs} args - Arguments to update one TaskDependency.
     * @example
     * // Update one TaskDependency
     * const taskDependency = await prisma.taskDependency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TaskDependencyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TaskDependencyUpdateArgs<ExtArgs>>
    ): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TaskDependencies.
     * @param {TaskDependencyDeleteManyArgs} args - Arguments to filter TaskDependencies to delete.
     * @example
     * // Delete a few TaskDependencies
     * const { count } = await prisma.taskDependency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TaskDependencyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskDependencyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskDependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskDependencies
     * const taskDependency = await prisma.taskDependency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TaskDependencyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TaskDependencyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskDependency.
     * @param {TaskDependencyUpsertArgs} args - Arguments to update or create a TaskDependency.
     * @example
     * // Update or create a TaskDependency
     * const taskDependency = await prisma.taskDependency.upsert({
     *   create: {
     *     // ... data to create a TaskDependency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskDependency we want to update
     *   }
     * })
    **/
    upsert<T extends TaskDependencyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TaskDependencyUpsertArgs<ExtArgs>>
    ): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TaskDependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyCountArgs} args - Arguments to filter TaskDependencies to count.
     * @example
     * // Count the number of TaskDependencies
     * const count = await prisma.taskDependency.count({
     *   where: {
     *     // ... the filter for the TaskDependencies we want to count
     *   }
     * })
    **/
    count<T extends TaskDependencyCountArgs>(
      args?: Subset<T, TaskDependencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskDependencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskDependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskDependencyAggregateArgs>(args: Subset<T, TaskDependencyAggregateArgs>): Prisma.PrismaPromise<GetTaskDependencyAggregateType<T>>

    /**
     * Group by TaskDependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskDependencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskDependencyGroupByArgs['orderBy'] }
        : { orderBy?: TaskDependencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskDependencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskDependencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskDependency model
   */
  readonly fields: TaskDependencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskDependency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskDependencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    depends_on<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TaskDependency model
   */ 
  interface TaskDependencyFieldRefs {
    readonly task_id: FieldRef<"TaskDependency", 'String'>
    readonly depends_on_id: FieldRef<"TaskDependency", 'String'>
  }
    

  // Custom InputTypes

  /**
   * TaskDependency findUnique
   */
  export type TaskDependencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TaskDependency to fetch.
     */
    where: TaskDependencyWhereUniqueInput
  }


  /**
   * TaskDependency findUniqueOrThrow
   */
  export type TaskDependencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TaskDependency to fetch.
     */
    where: TaskDependencyWhereUniqueInput
  }


  /**
   * TaskDependency findFirst
   */
  export type TaskDependencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TaskDependency to fetch.
     */
    where?: TaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDependencies to fetch.
     */
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDependencies.
     */
    cursor?: TaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDependencies.
     */
    distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[]
  }


  /**
   * TaskDependency findFirstOrThrow
   */
  export type TaskDependencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TaskDependency to fetch.
     */
    where?: TaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDependencies to fetch.
     */
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDependencies.
     */
    cursor?: TaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDependencies.
     */
    distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[]
  }


  /**
   * TaskDependency findMany
   */
  export type TaskDependencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TaskDependencies to fetch.
     */
    where?: TaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDependencies to fetch.
     */
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskDependencies.
     */
    cursor?: TaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDependencies.
     */
    skip?: number
    distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[]
  }


  /**
   * TaskDependency create
   */
  export type TaskDependencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskDependency.
     */
    data: XOR<TaskDependencyCreateInput, TaskDependencyUncheckedCreateInput>
  }


  /**
   * TaskDependency update
   */
  export type TaskDependencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskDependency.
     */
    data: XOR<TaskDependencyUpdateInput, TaskDependencyUncheckedUpdateInput>
    /**
     * Choose, which TaskDependency to update.
     */
    where: TaskDependencyWhereUniqueInput
  }


  /**
   * TaskDependency updateMany
   */
  export type TaskDependencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskDependencies.
     */
    data: XOR<TaskDependencyUpdateManyMutationInput, TaskDependencyUncheckedUpdateManyInput>
    /**
     * Filter which TaskDependencies to update
     */
    where?: TaskDependencyWhereInput
  }


  /**
   * TaskDependency upsert
   */
  export type TaskDependencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskDependency to update in case it exists.
     */
    where: TaskDependencyWhereUniqueInput
    /**
     * In case the TaskDependency found by the `where` argument doesn't exist, create a new TaskDependency with this data.
     */
    create: XOR<TaskDependencyCreateInput, TaskDependencyUncheckedCreateInput>
    /**
     * In case the TaskDependency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskDependencyUpdateInput, TaskDependencyUncheckedUpdateInput>
  }


  /**
   * TaskDependency delete
   */
  export type TaskDependencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter which TaskDependency to delete.
     */
    where: TaskDependencyWhereUniqueInput
  }


  /**
   * TaskDependency deleteMany
   */
  export type TaskDependencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDependencies to delete
     */
    where?: TaskDependencyWhereInput
  }


  /**
   * TaskDependency without action
   */
  export type TaskDependencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskDependencyInclude<ExtArgs> | null
  }



  /**
   * Model Milestone
   */

  export type AggregateMilestone = {
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  export type MilestoneMinAggregateOutputType = {
    id: string | null
    store_id: string | null
    name: string | null
    type: string | null
    date: Date | null
    status: string | null
  }

  export type MilestoneMaxAggregateOutputType = {
    id: string | null
    store_id: string | null
    name: string | null
    type: string | null
    date: Date | null
    status: string | null
  }

  export type MilestoneCountAggregateOutputType = {
    id: number
    store_id: number
    name: number
    type: number
    date: number
    status: number
    _all: number
  }


  export type MilestoneMinAggregateInputType = {
    id?: true
    store_id?: true
    name?: true
    type?: true
    date?: true
    status?: true
  }

  export type MilestoneMaxAggregateInputType = {
    id?: true
    store_id?: true
    name?: true
    type?: true
    date?: true
    status?: true
  }

  export type MilestoneCountAggregateInputType = {
    id?: true
    store_id?: true
    name?: true
    type?: true
    date?: true
    status?: true
    _all?: true
  }

  export type MilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestone to aggregate.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Milestones
    **/
    _count?: true | MilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilestoneMaxAggregateInputType
  }

  export type GetMilestoneAggregateType<T extends MilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilestone[P]>
      : GetScalarType<T[P], AggregateMilestone[P]>
  }




  export type MilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithAggregationInput | MilestoneOrderByWithAggregationInput[]
    by: MilestoneScalarFieldEnum[] | MilestoneScalarFieldEnum
    having?: MilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilestoneCountAggregateInputType | true
    _min?: MilestoneMinAggregateInputType
    _max?: MilestoneMaxAggregateInputType
  }

  export type MilestoneGroupByOutputType = {
    id: string
    store_id: string
    name: string
    type: string
    date: Date
    status: string
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  type GetMilestoneGroupByPayload<T extends MilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
        }
      >
    >


  export type MilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    name?: boolean
    type?: boolean
    date?: boolean
    status?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectScalar = {
    id?: boolean
    store_id?: boolean
    name?: boolean
    type?: boolean
    date?: boolean
    status?: boolean
  }

  export type MilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }


  export type $MilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Milestone"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      store_id: string
      name: string
      type: string
      date: Date
      status: string
    }, ExtArgs["result"]["milestone"]>
    composites: {}
  }


  type MilestoneGetPayload<S extends boolean | null | undefined | MilestoneDefaultArgs> = $Result.GetResult<Prisma.$MilestonePayload, S>

  type MilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MilestoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MilestoneCountAggregateInputType | true
    }

  export interface MilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Milestone'], meta: { name: 'Milestone' } }
    /**
     * Find zero or one Milestone that matches the filter.
     * @param {MilestoneFindUniqueArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MilestoneFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MilestoneFindUniqueArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Milestone that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MilestoneFindUniqueOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MilestoneFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestoneFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Milestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MilestoneFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestoneFindFirstArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Milestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MilestoneFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestoneFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Milestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Milestones
     * const milestones = await prisma.milestone.findMany()
     * 
     * // Get first 10 Milestones
     * const milestones = await prisma.milestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const milestoneWithIdOnly = await prisma.milestone.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MilestoneFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestoneFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Milestone.
     * @param {MilestoneCreateArgs} args - Arguments to create a Milestone.
     * @example
     * // Create one Milestone
     * const Milestone = await prisma.milestone.create({
     *   data: {
     *     // ... data to create a Milestone
     *   }
     * })
     * 
    **/
    create<T extends MilestoneCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MilestoneCreateArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Milestone.
     * @param {MilestoneDeleteArgs} args - Arguments to delete one Milestone.
     * @example
     * // Delete one Milestone
     * const Milestone = await prisma.milestone.delete({
     *   where: {
     *     // ... filter to delete one Milestone
     *   }
     * })
     * 
    **/
    delete<T extends MilestoneDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MilestoneDeleteArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Milestone.
     * @param {MilestoneUpdateArgs} args - Arguments to update one Milestone.
     * @example
     * // Update one Milestone
     * const milestone = await prisma.milestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MilestoneUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MilestoneUpdateArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Milestones.
     * @param {MilestoneDeleteManyArgs} args - Arguments to filter Milestones to delete.
     * @example
     * // Delete a few Milestones
     * const { count } = await prisma.milestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MilestoneDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestoneDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MilestoneUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MilestoneUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Milestone.
     * @param {MilestoneUpsertArgs} args - Arguments to update or create a Milestone.
     * @example
     * // Update or create a Milestone
     * const milestone = await prisma.milestone.upsert({
     *   create: {
     *     // ... data to create a Milestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Milestone we want to update
     *   }
     * })
    **/
    upsert<T extends MilestoneUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MilestoneUpsertArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneCountArgs} args - Arguments to filter Milestones to count.
     * @example
     * // Count the number of Milestones
     * const count = await prisma.milestone.count({
     *   where: {
     *     // ... the filter for the Milestones we want to count
     *   }
     * })
    **/
    count<T extends MilestoneCountArgs>(
      args?: Subset<T, MilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilestoneAggregateArgs>(args: Subset<T, MilestoneAggregateArgs>): Prisma.PrismaPromise<GetMilestoneAggregateType<T>>

    /**
     * Group by Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilestoneGroupByArgs['orderBy'] }
        : { orderBy?: MilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Milestone model
   */
  readonly fields: MilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Milestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Milestone model
   */ 
  interface MilestoneFieldRefs {
    readonly id: FieldRef<"Milestone", 'String'>
    readonly store_id: FieldRef<"Milestone", 'String'>
    readonly name: FieldRef<"Milestone", 'String'>
    readonly type: FieldRef<"Milestone", 'String'>
    readonly date: FieldRef<"Milestone", 'DateTime'>
    readonly status: FieldRef<"Milestone", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Milestone findUnique
   */
  export type MilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }


  /**
   * Milestone findUniqueOrThrow
   */
  export type MilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }


  /**
   * Milestone findFirst
   */
  export type MilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }


  /**
   * Milestone findFirstOrThrow
   */
  export type MilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }


  /**
   * Milestone findMany
   */
  export type MilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestones to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }


  /**
   * Milestone create
   */
  export type MilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Milestone.
     */
    data: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
  }


  /**
   * Milestone update
   */
  export type MilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Milestone.
     */
    data: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
    /**
     * Choose, which Milestone to update.
     */
    where: MilestoneWhereUniqueInput
  }


  /**
   * Milestone updateMany
   */
  export type MilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
  }


  /**
   * Milestone upsert
   */
  export type MilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Milestone to update in case it exists.
     */
    where: MilestoneWhereUniqueInput
    /**
     * In case the Milestone found by the `where` argument doesn't exist, create a new Milestone with this data.
     */
    create: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
    /**
     * In case the Milestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
  }


  /**
   * Milestone delete
   */
  export type MilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter which Milestone to delete.
     */
    where: MilestoneWhereUniqueInput
  }


  /**
   * Milestone deleteMany
   */
  export type MilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestones to delete
     */
    where?: MilestoneWhereInput
  }


  /**
   * Milestone without action
   */
  export type MilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
  }



  /**
   * Model Issue
   */

  export type AggregateIssue = {
    _count: IssueCountAggregateOutputType | null
    _min: IssueMinAggregateOutputType | null
    _max: IssueMaxAggregateOutputType | null
  }

  export type IssueMinAggregateOutputType = {
    id: string | null
    store_id: string | null
    title: string | null
    severity: string | null
    status: string | null
    mitigation: string | null
  }

  export type IssueMaxAggregateOutputType = {
    id: string | null
    store_id: string | null
    title: string | null
    severity: string | null
    status: string | null
    mitigation: string | null
  }

  export type IssueCountAggregateOutputType = {
    id: number
    store_id: number
    title: number
    severity: number
    status: number
    mitigation: number
    _all: number
  }


  export type IssueMinAggregateInputType = {
    id?: true
    store_id?: true
    title?: true
    severity?: true
    status?: true
    mitigation?: true
  }

  export type IssueMaxAggregateInputType = {
    id?: true
    store_id?: true
    title?: true
    severity?: true
    status?: true
    mitigation?: true
  }

  export type IssueCountAggregateInputType = {
    id?: true
    store_id?: true
    title?: true
    severity?: true
    status?: true
    mitigation?: true
    _all?: true
  }

  export type IssueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Issue to aggregate.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Issues
    **/
    _count?: true | IssueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IssueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IssueMaxAggregateInputType
  }

  export type GetIssueAggregateType<T extends IssueAggregateArgs> = {
        [P in keyof T & keyof AggregateIssue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIssue[P]>
      : GetScalarType<T[P], AggregateIssue[P]>
  }




  export type IssueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueWhereInput
    orderBy?: IssueOrderByWithAggregationInput | IssueOrderByWithAggregationInput[]
    by: IssueScalarFieldEnum[] | IssueScalarFieldEnum
    having?: IssueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IssueCountAggregateInputType | true
    _min?: IssueMinAggregateInputType
    _max?: IssueMaxAggregateInputType
  }

  export type IssueGroupByOutputType = {
    id: string
    store_id: string
    title: string
    severity: string
    status: string
    mitigation: string | null
    _count: IssueCountAggregateOutputType | null
    _min: IssueMinAggregateOutputType | null
    _max: IssueMaxAggregateOutputType | null
  }

  type GetIssueGroupByPayload<T extends IssueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IssueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IssueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IssueGroupByOutputType[P]>
            : GetScalarType<T[P], IssueGroupByOutputType[P]>
        }
      >
    >


  export type IssueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    title?: boolean
    severity?: boolean
    status?: boolean
    mitigation?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["issue"]>

  export type IssueSelectScalar = {
    id?: boolean
    store_id?: boolean
    title?: boolean
    severity?: boolean
    status?: boolean
    mitigation?: boolean
  }

  export type IssueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }


  export type $IssuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Issue"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      store_id: string
      title: string
      severity: string
      status: string
      mitigation: string | null
    }, ExtArgs["result"]["issue"]>
    composites: {}
  }


  type IssueGetPayload<S extends boolean | null | undefined | IssueDefaultArgs> = $Result.GetResult<Prisma.$IssuePayload, S>

  type IssueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IssueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IssueCountAggregateInputType | true
    }

  export interface IssueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Issue'], meta: { name: 'Issue' } }
    /**
     * Find zero or one Issue that matches the filter.
     * @param {IssueFindUniqueArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IssueFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, IssueFindUniqueArgs<ExtArgs>>
    ): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Issue that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IssueFindUniqueOrThrowArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IssueFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IssueFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Issue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueFindFirstArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IssueFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, IssueFindFirstArgs<ExtArgs>>
    ): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Issue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueFindFirstOrThrowArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IssueFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IssueFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Issues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Issues
     * const issues = await prisma.issue.findMany()
     * 
     * // Get first 10 Issues
     * const issues = await prisma.issue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const issueWithIdOnly = await prisma.issue.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IssueFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IssueFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Issue.
     * @param {IssueCreateArgs} args - Arguments to create a Issue.
     * @example
     * // Create one Issue
     * const Issue = await prisma.issue.create({
     *   data: {
     *     // ... data to create a Issue
     *   }
     * })
     * 
    **/
    create<T extends IssueCreateArgs<ExtArgs>>(
      args: SelectSubset<T, IssueCreateArgs<ExtArgs>>
    ): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Issue.
     * @param {IssueDeleteArgs} args - Arguments to delete one Issue.
     * @example
     * // Delete one Issue
     * const Issue = await prisma.issue.delete({
     *   where: {
     *     // ... filter to delete one Issue
     *   }
     * })
     * 
    **/
    delete<T extends IssueDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, IssueDeleteArgs<ExtArgs>>
    ): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Issue.
     * @param {IssueUpdateArgs} args - Arguments to update one Issue.
     * @example
     * // Update one Issue
     * const issue = await prisma.issue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IssueUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, IssueUpdateArgs<ExtArgs>>
    ): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Issues.
     * @param {IssueDeleteManyArgs} args - Arguments to filter Issues to delete.
     * @example
     * // Delete a few Issues
     * const { count } = await prisma.issue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IssueDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IssueDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Issues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Issues
     * const issue = await prisma.issue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IssueUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, IssueUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Issue.
     * @param {IssueUpsertArgs} args - Arguments to update or create a Issue.
     * @example
     * // Update or create a Issue
     * const issue = await prisma.issue.upsert({
     *   create: {
     *     // ... data to create a Issue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Issue we want to update
     *   }
     * })
    **/
    upsert<T extends IssueUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, IssueUpsertArgs<ExtArgs>>
    ): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Issues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueCountArgs} args - Arguments to filter Issues to count.
     * @example
     * // Count the number of Issues
     * const count = await prisma.issue.count({
     *   where: {
     *     // ... the filter for the Issues we want to count
     *   }
     * })
    **/
    count<T extends IssueCountArgs>(
      args?: Subset<T, IssueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IssueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Issue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IssueAggregateArgs>(args: Subset<T, IssueAggregateArgs>): Prisma.PrismaPromise<GetIssueAggregateType<T>>

    /**
     * Group by Issue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IssueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IssueGroupByArgs['orderBy'] }
        : { orderBy?: IssueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IssueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIssueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Issue model
   */
  readonly fields: IssueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Issue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IssueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Issue model
   */ 
  interface IssueFieldRefs {
    readonly id: FieldRef<"Issue", 'String'>
    readonly store_id: FieldRef<"Issue", 'String'>
    readonly title: FieldRef<"Issue", 'String'>
    readonly severity: FieldRef<"Issue", 'String'>
    readonly status: FieldRef<"Issue", 'String'>
    readonly mitigation: FieldRef<"Issue", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Issue findUnique
   */
  export type IssueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where: IssueWhereUniqueInput
  }


  /**
   * Issue findUniqueOrThrow
   */
  export type IssueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where: IssueWhereUniqueInput
  }


  /**
   * Issue findFirst
   */
  export type IssueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Issues.
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Issues.
     */
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }


  /**
   * Issue findFirstOrThrow
   */
  export type IssueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Issues.
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Issues.
     */
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }


  /**
   * Issue findMany
   */
  export type IssueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issues to fetch.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Issues.
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }


  /**
   * Issue create
   */
  export type IssueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * The data needed to create a Issue.
     */
    data: XOR<IssueCreateInput, IssueUncheckedCreateInput>
  }


  /**
   * Issue update
   */
  export type IssueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * The data needed to update a Issue.
     */
    data: XOR<IssueUpdateInput, IssueUncheckedUpdateInput>
    /**
     * Choose, which Issue to update.
     */
    where: IssueWhereUniqueInput
  }


  /**
   * Issue updateMany
   */
  export type IssueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Issues.
     */
    data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyInput>
    /**
     * Filter which Issues to update
     */
    where?: IssueWhereInput
  }


  /**
   * Issue upsert
   */
  export type IssueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * The filter to search for the Issue to update in case it exists.
     */
    where: IssueWhereUniqueInput
    /**
     * In case the Issue found by the `where` argument doesn't exist, create a new Issue with this data.
     */
    create: XOR<IssueCreateInput, IssueUncheckedCreateInput>
    /**
     * In case the Issue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IssueUpdateInput, IssueUncheckedUpdateInput>
  }


  /**
   * Issue delete
   */
  export type IssueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter which Issue to delete.
     */
    where: IssueWhereUniqueInput
  }


  /**
   * Issue deleteMany
   */
  export type IssueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Issues to delete
     */
    where?: IssueWhereInput
  }


  /**
   * Issue without action
   */
  export type IssueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IssueInclude<ExtArgs> | null
  }



  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    store_id: string | null
    name: string | null
    url: string | null
    type: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    store_id: string | null
    name: string | null
    url: string | null
    type: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    store_id: number
    name: number
    url: number
    type: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    store_id?: true
    name?: true
    url?: true
    type?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    store_id?: true
    name?: true
    url?: true
    type?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    store_id?: true
    name?: true
    url?: true
    type?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    store_id: string
    name: string
    url: string
    type: string
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    store_id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }


  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      store_id: string
      name: string
      url: string
      type: string
    }, ExtArgs["result"]["document"]>
    composites: {}
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly store_id: FieldRef<"Document", 'String'>
    readonly name: FieldRef<"Document", 'String'>
    readonly url: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
  }



  /**
   * Model Ingredient
   */

  export type AggregateIngredient = {
    _count: IngredientCountAggregateOutputType | null
    _min: IngredientMinAggregateOutputType | null
    _max: IngredientMaxAggregateOutputType | null
  }

  export type IngredientMinAggregateOutputType = {
    id: string | null
    name: string | null
    unit_type: string | null
    category: string | null
  }

  export type IngredientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    unit_type: string | null
    category: string | null
  }

  export type IngredientCountAggregateOutputType = {
    id: number
    name: number
    unit_type: number
    category: number
    _all: number
  }


  export type IngredientMinAggregateInputType = {
    id?: true
    name?: true
    unit_type?: true
    category?: true
  }

  export type IngredientMaxAggregateInputType = {
    id?: true
    name?: true
    unit_type?: true
    category?: true
  }

  export type IngredientCountAggregateInputType = {
    id?: true
    name?: true
    unit_type?: true
    category?: true
    _all?: true
  }

  export type IngredientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ingredient to aggregate.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ingredients
    **/
    _count?: true | IngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientMaxAggregateInputType
  }

  export type GetIngredientAggregateType<T extends IngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredient[P]>
      : GetScalarType<T[P], AggregateIngredient[P]>
  }




  export type IngredientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientWhereInput
    orderBy?: IngredientOrderByWithAggregationInput | IngredientOrderByWithAggregationInput[]
    by: IngredientScalarFieldEnum[] | IngredientScalarFieldEnum
    having?: IngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientCountAggregateInputType | true
    _min?: IngredientMinAggregateInputType
    _max?: IngredientMaxAggregateInputType
  }

  export type IngredientGroupByOutputType = {
    id: string
    name: string
    unit_type: string
    category: string | null
    _count: IngredientCountAggregateOutputType | null
    _min: IngredientMinAggregateOutputType | null
    _max: IngredientMaxAggregateOutputType | null
  }

  type GetIngredientGroupByPayload<T extends IngredientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientGroupByOutputType[P]>
        }
      >
    >


  export type IngredientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    unit_type?: boolean
    category?: boolean
    prices?: boolean | Ingredient$pricesArgs<ExtArgs>
    recipe_lines?: boolean | Ingredient$recipe_linesArgs<ExtArgs>
    _count?: boolean | IngredientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingredient"]>

  export type IngredientSelectScalar = {
    id?: boolean
    name?: boolean
    unit_type?: boolean
    category?: boolean
  }

  export type IngredientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prices?: boolean | Ingredient$pricesArgs<ExtArgs>
    recipe_lines?: boolean | Ingredient$recipe_linesArgs<ExtArgs>
    _count?: boolean | IngredientCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $IngredientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ingredient"
    objects: {
      prices: Prisma.$GroceryPricePayload<ExtArgs>[]
      recipe_lines: Prisma.$RecipeLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      unit_type: string
      category: string | null
    }, ExtArgs["result"]["ingredient"]>
    composites: {}
  }


  type IngredientGetPayload<S extends boolean | null | undefined | IngredientDefaultArgs> = $Result.GetResult<Prisma.$IngredientPayload, S>

  type IngredientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IngredientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IngredientCountAggregateInputType | true
    }

  export interface IngredientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ingredient'], meta: { name: 'Ingredient' } }
    /**
     * Find zero or one Ingredient that matches the filter.
     * @param {IngredientFindUniqueArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IngredientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientFindUniqueArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Ingredient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IngredientFindUniqueOrThrowArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IngredientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Ingredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindFirstArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IngredientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientFindFirstArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Ingredient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindFirstOrThrowArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IngredientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Ingredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ingredients
     * const ingredients = await prisma.ingredient.findMany()
     * 
     * // Get first 10 Ingredients
     * const ingredients = await prisma.ingredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingredientWithIdOnly = await prisma.ingredient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IngredientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Ingredient.
     * @param {IngredientCreateArgs} args - Arguments to create a Ingredient.
     * @example
     * // Create one Ingredient
     * const Ingredient = await prisma.ingredient.create({
     *   data: {
     *     // ... data to create a Ingredient
     *   }
     * })
     * 
    **/
    create<T extends IngredientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientCreateArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Ingredient.
     * @param {IngredientDeleteArgs} args - Arguments to delete one Ingredient.
     * @example
     * // Delete one Ingredient
     * const Ingredient = await prisma.ingredient.delete({
     *   where: {
     *     // ... filter to delete one Ingredient
     *   }
     * })
     * 
    **/
    delete<T extends IngredientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientDeleteArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Ingredient.
     * @param {IngredientUpdateArgs} args - Arguments to update one Ingredient.
     * @example
     * // Update one Ingredient
     * const ingredient = await prisma.ingredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IngredientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUpdateArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Ingredients.
     * @param {IngredientDeleteManyArgs} args - Arguments to filter Ingredients to delete.
     * @example
     * // Delete a few Ingredients
     * const { count } = await prisma.ingredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IngredientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ingredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ingredients
     * const ingredient = await prisma.ingredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IngredientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ingredient.
     * @param {IngredientUpsertArgs} args - Arguments to update or create a Ingredient.
     * @example
     * // Update or create a Ingredient
     * const ingredient = await prisma.ingredient.upsert({
     *   create: {
     *     // ... data to create a Ingredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ingredient we want to update
     *   }
     * })
    **/
    upsert<T extends IngredientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUpsertArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Ingredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientCountArgs} args - Arguments to filter Ingredients to count.
     * @example
     * // Count the number of Ingredients
     * const count = await prisma.ingredient.count({
     *   where: {
     *     // ... the filter for the Ingredients we want to count
     *   }
     * })
    **/
    count<T extends IngredientCountArgs>(
      args?: Subset<T, IngredientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ingredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientAggregateArgs>(args: Subset<T, IngredientAggregateArgs>): Prisma.PrismaPromise<GetIngredientAggregateType<T>>

    /**
     * Group by Ingredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientGroupByArgs['orderBy'] }
        : { orderBy?: IngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ingredient model
   */
  readonly fields: IngredientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ingredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngredientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    prices<T extends Ingredient$pricesArgs<ExtArgs> = {}>(args?: Subset<T, Ingredient$pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroceryPricePayload<ExtArgs>, T, 'findMany'> | Null>;

    recipe_lines<T extends Ingredient$recipe_linesArgs<ExtArgs> = {}>(args?: Subset<T, Ingredient$recipe_linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeLinePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Ingredient model
   */ 
  interface IngredientFieldRefs {
    readonly id: FieldRef<"Ingredient", 'String'>
    readonly name: FieldRef<"Ingredient", 'String'>
    readonly unit_type: FieldRef<"Ingredient", 'String'>
    readonly category: FieldRef<"Ingredient", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Ingredient findUnique
   */
  export type IngredientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient findUniqueOrThrow
   */
  export type IngredientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient findFirst
   */
  export type IngredientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ingredients.
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ingredients.
     */
    distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
  }


  /**
   * Ingredient findFirstOrThrow
   */
  export type IngredientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ingredients.
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ingredients.
     */
    distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
  }


  /**
   * Ingredient findMany
   */
  export type IngredientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredients to fetch.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ingredients.
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
  }


  /**
   * Ingredient create
   */
  export type IngredientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * The data needed to create a Ingredient.
     */
    data: XOR<IngredientCreateInput, IngredientUncheckedCreateInput>
  }


  /**
   * Ingredient update
   */
  export type IngredientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * The data needed to update a Ingredient.
     */
    data: XOR<IngredientUpdateInput, IngredientUncheckedUpdateInput>
    /**
     * Choose, which Ingredient to update.
     */
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient updateMany
   */
  export type IngredientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ingredients.
     */
    data: XOR<IngredientUpdateManyMutationInput, IngredientUncheckedUpdateManyInput>
    /**
     * Filter which Ingredients to update
     */
    where?: IngredientWhereInput
  }


  /**
   * Ingredient upsert
   */
  export type IngredientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * The filter to search for the Ingredient to update in case it exists.
     */
    where: IngredientWhereUniqueInput
    /**
     * In case the Ingredient found by the `where` argument doesn't exist, create a new Ingredient with this data.
     */
    create: XOR<IngredientCreateInput, IngredientUncheckedCreateInput>
    /**
     * In case the Ingredient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngredientUpdateInput, IngredientUncheckedUpdateInput>
  }


  /**
   * Ingredient delete
   */
  export type IngredientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter which Ingredient to delete.
     */
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient deleteMany
   */
  export type IngredientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ingredients to delete
     */
    where?: IngredientWhereInput
  }


  /**
   * Ingredient.prices
   */
  export type Ingredient$pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroceryPrice
     */
    select?: GroceryPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroceryPriceInclude<ExtArgs> | null
    where?: GroceryPriceWhereInput
    orderBy?: GroceryPriceOrderByWithRelationInput | GroceryPriceOrderByWithRelationInput[]
    cursor?: GroceryPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroceryPriceScalarFieldEnum | GroceryPriceScalarFieldEnum[]
  }


  /**
   * Ingredient.recipe_lines
   */
  export type Ingredient$recipe_linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeLine
     */
    select?: RecipeLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeLineInclude<ExtArgs> | null
    where?: RecipeLineWhereInput
    orderBy?: RecipeLineOrderByWithRelationInput | RecipeLineOrderByWithRelationInput[]
    cursor?: RecipeLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeLineScalarFieldEnum | RecipeLineScalarFieldEnum[]
  }


  /**
   * Ingredient without action
   */
  export type IngredientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
  }



  /**
   * Model GroceryPrice
   */

  export type AggregateGroceryPrice = {
    _count: GroceryPriceCountAggregateOutputType | null
    _avg: GroceryPriceAvgAggregateOutputType | null
    _sum: GroceryPriceSumAggregateOutputType | null
    _min: GroceryPriceMinAggregateOutputType | null
    _max: GroceryPriceMaxAggregateOutputType | null
  }

  export type GroceryPriceAvgAggregateOutputType = {
    package_size: number | null
    price: number | null
    normalized_price_per_unit: number | null
  }

  export type GroceryPriceSumAggregateOutputType = {
    package_size: number | null
    price: number | null
    normalized_price_per_unit: number | null
  }

  export type GroceryPriceMinAggregateOutputType = {
    id: string | null
    country: string | null
    retailer: string | null
    ingredient_id: string | null
    package_size: number | null
    package_unit: string | null
    price: number | null
    currency: string | null
    normalized_price_per_unit: number | null
    as_of: Date | null
    source_url: string | null
  }

  export type GroceryPriceMaxAggregateOutputType = {
    id: string | null
    country: string | null
    retailer: string | null
    ingredient_id: string | null
    package_size: number | null
    package_unit: string | null
    price: number | null
    currency: string | null
    normalized_price_per_unit: number | null
    as_of: Date | null
    source_url: string | null
  }

  export type GroceryPriceCountAggregateOutputType = {
    id: number
    country: number
    retailer: number
    ingredient_id: number
    package_size: number
    package_unit: number
    price: number
    currency: number
    normalized_price_per_unit: number
    as_of: number
    source_url: number
    _all: number
  }


  export type GroceryPriceAvgAggregateInputType = {
    package_size?: true
    price?: true
    normalized_price_per_unit?: true
  }

  export type GroceryPriceSumAggregateInputType = {
    package_size?: true
    price?: true
    normalized_price_per_unit?: true
  }

  export type GroceryPriceMinAggregateInputType = {
    id?: true
    country?: true
    retailer?: true
    ingredient_id?: true
    package_size?: true
    package_unit?: true
    price?: true
    currency?: true
    normalized_price_per_unit?: true
    as_of?: true
    source_url?: true
  }

  export type GroceryPriceMaxAggregateInputType = {
    id?: true
    country?: true
    retailer?: true
    ingredient_id?: true
    package_size?: true
    package_unit?: true
    price?: true
    currency?: true
    normalized_price_per_unit?: true
    as_of?: true
    source_url?: true
  }

  export type GroceryPriceCountAggregateInputType = {
    id?: true
    country?: true
    retailer?: true
    ingredient_id?: true
    package_size?: true
    package_unit?: true
    price?: true
    currency?: true
    normalized_price_per_unit?: true
    as_of?: true
    source_url?: true
    _all?: true
  }

  export type GroceryPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroceryPrice to aggregate.
     */
    where?: GroceryPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroceryPrices to fetch.
     */
    orderBy?: GroceryPriceOrderByWithRelationInput | GroceryPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroceryPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroceryPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroceryPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroceryPrices
    **/
    _count?: true | GroceryPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroceryPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroceryPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroceryPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroceryPriceMaxAggregateInputType
  }

  export type GetGroceryPriceAggregateType<T extends GroceryPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateGroceryPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroceryPrice[P]>
      : GetScalarType<T[P], AggregateGroceryPrice[P]>
  }




  export type GroceryPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroceryPriceWhereInput
    orderBy?: GroceryPriceOrderByWithAggregationInput | GroceryPriceOrderByWithAggregationInput[]
    by: GroceryPriceScalarFieldEnum[] | GroceryPriceScalarFieldEnum
    having?: GroceryPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroceryPriceCountAggregateInputType | true
    _avg?: GroceryPriceAvgAggregateInputType
    _sum?: GroceryPriceSumAggregateInputType
    _min?: GroceryPriceMinAggregateInputType
    _max?: GroceryPriceMaxAggregateInputType
  }

  export type GroceryPriceGroupByOutputType = {
    id: string
    country: string
    retailer: string
    ingredient_id: string
    package_size: number
    package_unit: string
    price: number
    currency: string
    normalized_price_per_unit: number
    as_of: Date
    source_url: string | null
    _count: GroceryPriceCountAggregateOutputType | null
    _avg: GroceryPriceAvgAggregateOutputType | null
    _sum: GroceryPriceSumAggregateOutputType | null
    _min: GroceryPriceMinAggregateOutputType | null
    _max: GroceryPriceMaxAggregateOutputType | null
  }

  type GetGroceryPriceGroupByPayload<T extends GroceryPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroceryPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroceryPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroceryPriceGroupByOutputType[P]>
            : GetScalarType<T[P], GroceryPriceGroupByOutputType[P]>
        }
      >
    >


  export type GroceryPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    country?: boolean
    retailer?: boolean
    ingredient_id?: boolean
    package_size?: boolean
    package_unit?: boolean
    price?: boolean
    currency?: boolean
    normalized_price_per_unit?: boolean
    as_of?: boolean
    source_url?: boolean
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    history?: boolean | GroceryPrice$historyArgs<ExtArgs>
    _count?: boolean | GroceryPriceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groceryPrice"]>

  export type GroceryPriceSelectScalar = {
    id?: boolean
    country?: boolean
    retailer?: boolean
    ingredient_id?: boolean
    package_size?: boolean
    package_unit?: boolean
    price?: boolean
    currency?: boolean
    normalized_price_per_unit?: boolean
    as_of?: boolean
    source_url?: boolean
  }

  export type GroceryPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    history?: boolean | GroceryPrice$historyArgs<ExtArgs>
    _count?: boolean | GroceryPriceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $GroceryPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroceryPrice"
    objects: {
      ingredient: Prisma.$IngredientPayload<ExtArgs>
      history: Prisma.$PriceHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      country: string
      retailer: string
      ingredient_id: string
      package_size: number
      package_unit: string
      price: number
      currency: string
      normalized_price_per_unit: number
      as_of: Date
      source_url: string | null
    }, ExtArgs["result"]["groceryPrice"]>
    composites: {}
  }


  type GroceryPriceGetPayload<S extends boolean | null | undefined | GroceryPriceDefaultArgs> = $Result.GetResult<Prisma.$GroceryPricePayload, S>

  type GroceryPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroceryPriceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroceryPriceCountAggregateInputType | true
    }

  export interface GroceryPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroceryPrice'], meta: { name: 'GroceryPrice' } }
    /**
     * Find zero or one GroceryPrice that matches the filter.
     * @param {GroceryPriceFindUniqueArgs} args - Arguments to find a GroceryPrice
     * @example
     * // Get one GroceryPrice
     * const groceryPrice = await prisma.groceryPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroceryPriceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GroceryPriceFindUniqueArgs<ExtArgs>>
    ): Prisma__GroceryPriceClient<$Result.GetResult<Prisma.$GroceryPricePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one GroceryPrice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GroceryPriceFindUniqueOrThrowArgs} args - Arguments to find a GroceryPrice
     * @example
     * // Get one GroceryPrice
     * const groceryPrice = await prisma.groceryPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroceryPriceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GroceryPriceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GroceryPriceClient<$Result.GetResult<Prisma.$GroceryPricePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first GroceryPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroceryPriceFindFirstArgs} args - Arguments to find a GroceryPrice
     * @example
     * // Get one GroceryPrice
     * const groceryPrice = await prisma.groceryPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroceryPriceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GroceryPriceFindFirstArgs<ExtArgs>>
    ): Prisma__GroceryPriceClient<$Result.GetResult<Prisma.$GroceryPricePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first GroceryPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroceryPriceFindFirstOrThrowArgs} args - Arguments to find a GroceryPrice
     * @example
     * // Get one GroceryPrice
     * const groceryPrice = await prisma.groceryPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroceryPriceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GroceryPriceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GroceryPriceClient<$Result.GetResult<Prisma.$GroceryPricePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more GroceryPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroceryPriceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroceryPrices
     * const groceryPrices = await prisma.groceryPrice.findMany()
     * 
     * // Get first 10 GroceryPrices
     * const groceryPrices = await prisma.groceryPrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groceryPriceWithIdOnly = await prisma.groceryPrice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GroceryPriceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroceryPriceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroceryPricePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a GroceryPrice.
     * @param {GroceryPriceCreateArgs} args - Arguments to create a GroceryPrice.
     * @example
     * // Create one GroceryPrice
     * const GroceryPrice = await prisma.groceryPrice.create({
     *   data: {
     *     // ... data to create a GroceryPrice
     *   }
     * })
     * 
    **/
    create<T extends GroceryPriceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GroceryPriceCreateArgs<ExtArgs>>
    ): Prisma__GroceryPriceClient<$Result.GetResult<Prisma.$GroceryPricePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a GroceryPrice.
     * @param {GroceryPriceDeleteArgs} args - Arguments to delete one GroceryPrice.
     * @example
     * // Delete one GroceryPrice
     * const GroceryPrice = await prisma.groceryPrice.delete({
     *   where: {
     *     // ... filter to delete one GroceryPrice
     *   }
     * })
     * 
    **/
    delete<T extends GroceryPriceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GroceryPriceDeleteArgs<ExtArgs>>
    ): Prisma__GroceryPriceClient<$Result.GetResult<Prisma.$GroceryPricePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one GroceryPrice.
     * @param {GroceryPriceUpdateArgs} args - Arguments to update one GroceryPrice.
     * @example
     * // Update one GroceryPrice
     * const groceryPrice = await prisma.groceryPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroceryPriceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GroceryPriceUpdateArgs<ExtArgs>>
    ): Prisma__GroceryPriceClient<$Result.GetResult<Prisma.$GroceryPricePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more GroceryPrices.
     * @param {GroceryPriceDeleteManyArgs} args - Arguments to filter GroceryPrices to delete.
     * @example
     * // Delete a few GroceryPrices
     * const { count } = await prisma.groceryPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroceryPriceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroceryPriceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroceryPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroceryPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroceryPrices
     * const groceryPrice = await prisma.groceryPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroceryPriceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GroceryPriceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroceryPrice.
     * @param {GroceryPriceUpsertArgs} args - Arguments to update or create a GroceryPrice.
     * @example
     * // Update or create a GroceryPrice
     * const groceryPrice = await prisma.groceryPrice.upsert({
     *   create: {
     *     // ... data to create a GroceryPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroceryPrice we want to update
     *   }
     * })
    **/
    upsert<T extends GroceryPriceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GroceryPriceUpsertArgs<ExtArgs>>
    ): Prisma__GroceryPriceClient<$Result.GetResult<Prisma.$GroceryPricePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of GroceryPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroceryPriceCountArgs} args - Arguments to filter GroceryPrices to count.
     * @example
     * // Count the number of GroceryPrices
     * const count = await prisma.groceryPrice.count({
     *   where: {
     *     // ... the filter for the GroceryPrices we want to count
     *   }
     * })
    **/
    count<T extends GroceryPriceCountArgs>(
      args?: Subset<T, GroceryPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroceryPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroceryPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroceryPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroceryPriceAggregateArgs>(args: Subset<T, GroceryPriceAggregateArgs>): Prisma.PrismaPromise<GetGroceryPriceAggregateType<T>>

    /**
     * Group by GroceryPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroceryPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroceryPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroceryPriceGroupByArgs['orderBy'] }
        : { orderBy?: GroceryPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroceryPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroceryPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroceryPrice model
   */
  readonly fields: GroceryPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroceryPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroceryPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ingredient<T extends IngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngredientDefaultArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    history<T extends GroceryPrice$historyArgs<ExtArgs> = {}>(args?: Subset<T, GroceryPrice$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the GroceryPrice model
   */ 
  interface GroceryPriceFieldRefs {
    readonly id: FieldRef<"GroceryPrice", 'String'>
    readonly country: FieldRef<"GroceryPrice", 'String'>
    readonly retailer: FieldRef<"GroceryPrice", 'String'>
    readonly ingredient_id: FieldRef<"GroceryPrice", 'String'>
    readonly package_size: FieldRef<"GroceryPrice", 'Float'>
    readonly package_unit: FieldRef<"GroceryPrice", 'String'>
    readonly price: FieldRef<"GroceryPrice", 'Float'>
    readonly currency: FieldRef<"GroceryPrice", 'String'>
    readonly normalized_price_per_unit: FieldRef<"GroceryPrice", 'Float'>
    readonly as_of: FieldRef<"GroceryPrice", 'DateTime'>
    readonly source_url: FieldRef<"GroceryPrice", 'String'>
  }
    

  // Custom InputTypes

  /**
   * GroceryPrice findUnique
   */
  export type GroceryPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroceryPrice
     */
    select?: GroceryPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroceryPriceInclude<ExtArgs> | null
    /**
     * Filter, which GroceryPrice to fetch.
     */
    where: GroceryPriceWhereUniqueInput
  }


  /**
   * GroceryPrice findUniqueOrThrow
   */
  export type GroceryPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroceryPrice
     */
    select?: GroceryPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroceryPriceInclude<ExtArgs> | null
    /**
     * Filter, which GroceryPrice to fetch.
     */
    where: GroceryPriceWhereUniqueInput
  }


  /**
   * GroceryPrice findFirst
   */
  export type GroceryPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroceryPrice
     */
    select?: GroceryPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroceryPriceInclude<ExtArgs> | null
    /**
     * Filter, which GroceryPrice to fetch.
     */
    where?: GroceryPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroceryPrices to fetch.
     */
    orderBy?: GroceryPriceOrderByWithRelationInput | GroceryPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroceryPrices.
     */
    cursor?: GroceryPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroceryPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroceryPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroceryPrices.
     */
    distinct?: GroceryPriceScalarFieldEnum | GroceryPriceScalarFieldEnum[]
  }


  /**
   * GroceryPrice findFirstOrThrow
   */
  export type GroceryPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroceryPrice
     */
    select?: GroceryPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroceryPriceInclude<ExtArgs> | null
    /**
     * Filter, which GroceryPrice to fetch.
     */
    where?: GroceryPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroceryPrices to fetch.
     */
    orderBy?: GroceryPriceOrderByWithRelationInput | GroceryPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroceryPrices.
     */
    cursor?: GroceryPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroceryPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroceryPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroceryPrices.
     */
    distinct?: GroceryPriceScalarFieldEnum | GroceryPriceScalarFieldEnum[]
  }


  /**
   * GroceryPrice findMany
   */
  export type GroceryPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroceryPrice
     */
    select?: GroceryPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroceryPriceInclude<ExtArgs> | null
    /**
     * Filter, which GroceryPrices to fetch.
     */
    where?: GroceryPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroceryPrices to fetch.
     */
    orderBy?: GroceryPriceOrderByWithRelationInput | GroceryPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroceryPrices.
     */
    cursor?: GroceryPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroceryPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroceryPrices.
     */
    skip?: number
    distinct?: GroceryPriceScalarFieldEnum | GroceryPriceScalarFieldEnum[]
  }


  /**
   * GroceryPrice create
   */
  export type GroceryPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroceryPrice
     */
    select?: GroceryPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroceryPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a GroceryPrice.
     */
    data: XOR<GroceryPriceCreateInput, GroceryPriceUncheckedCreateInput>
  }


  /**
   * GroceryPrice update
   */
  export type GroceryPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroceryPrice
     */
    select?: GroceryPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroceryPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a GroceryPrice.
     */
    data: XOR<GroceryPriceUpdateInput, GroceryPriceUncheckedUpdateInput>
    /**
     * Choose, which GroceryPrice to update.
     */
    where: GroceryPriceWhereUniqueInput
  }


  /**
   * GroceryPrice updateMany
   */
  export type GroceryPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroceryPrices.
     */
    data: XOR<GroceryPriceUpdateManyMutationInput, GroceryPriceUncheckedUpdateManyInput>
    /**
     * Filter which GroceryPrices to update
     */
    where?: GroceryPriceWhereInput
  }


  /**
   * GroceryPrice upsert
   */
  export type GroceryPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroceryPrice
     */
    select?: GroceryPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroceryPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the GroceryPrice to update in case it exists.
     */
    where: GroceryPriceWhereUniqueInput
    /**
     * In case the GroceryPrice found by the `where` argument doesn't exist, create a new GroceryPrice with this data.
     */
    create: XOR<GroceryPriceCreateInput, GroceryPriceUncheckedCreateInput>
    /**
     * In case the GroceryPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroceryPriceUpdateInput, GroceryPriceUncheckedUpdateInput>
  }


  /**
   * GroceryPrice delete
   */
  export type GroceryPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroceryPrice
     */
    select?: GroceryPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroceryPriceInclude<ExtArgs> | null
    /**
     * Filter which GroceryPrice to delete.
     */
    where: GroceryPriceWhereUniqueInput
  }


  /**
   * GroceryPrice deleteMany
   */
  export type GroceryPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroceryPrices to delete
     */
    where?: GroceryPriceWhereInput
  }


  /**
   * GroceryPrice.history
   */
  export type GroceryPrice$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    where?: PriceHistoryWhereInput
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    cursor?: PriceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }


  /**
   * GroceryPrice without action
   */
  export type GroceryPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroceryPrice
     */
    select?: GroceryPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroceryPriceInclude<ExtArgs> | null
  }



  /**
   * Model PriceHistory
   */

  export type AggregatePriceHistory = {
    _count: PriceHistoryCountAggregateOutputType | null
    _avg: PriceHistoryAvgAggregateOutputType | null
    _sum: PriceHistorySumAggregateOutputType | null
    _min: PriceHistoryMinAggregateOutputType | null
    _max: PriceHistoryMaxAggregateOutputType | null
  }

  export type PriceHistoryAvgAggregateOutputType = {
    price: number | null
  }

  export type PriceHistorySumAggregateOutputType = {
    price: number | null
  }

  export type PriceHistoryMinAggregateOutputType = {
    id: string | null
    grocery_price_id: string | null
    price: number | null
    changed_at: Date | null
    changed_by: string | null
    reason: string | null
  }

  export type PriceHistoryMaxAggregateOutputType = {
    id: string | null
    grocery_price_id: string | null
    price: number | null
    changed_at: Date | null
    changed_by: string | null
    reason: string | null
  }

  export type PriceHistoryCountAggregateOutputType = {
    id: number
    grocery_price_id: number
    price: number
    changed_at: number
    changed_by: number
    reason: number
    _all: number
  }


  export type PriceHistoryAvgAggregateInputType = {
    price?: true
  }

  export type PriceHistorySumAggregateInputType = {
    price?: true
  }

  export type PriceHistoryMinAggregateInputType = {
    id?: true
    grocery_price_id?: true
    price?: true
    changed_at?: true
    changed_by?: true
    reason?: true
  }

  export type PriceHistoryMaxAggregateInputType = {
    id?: true
    grocery_price_id?: true
    price?: true
    changed_at?: true
    changed_by?: true
    reason?: true
  }

  export type PriceHistoryCountAggregateInputType = {
    id?: true
    grocery_price_id?: true
    price?: true
    changed_at?: true
    changed_by?: true
    reason?: true
    _all?: true
  }

  export type PriceHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceHistory to aggregate.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceHistories
    **/
    _count?: true | PriceHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceHistoryMaxAggregateInputType
  }

  export type GetPriceHistoryAggregateType<T extends PriceHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceHistory[P]>
      : GetScalarType<T[P], AggregatePriceHistory[P]>
  }




  export type PriceHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceHistoryWhereInput
    orderBy?: PriceHistoryOrderByWithAggregationInput | PriceHistoryOrderByWithAggregationInput[]
    by: PriceHistoryScalarFieldEnum[] | PriceHistoryScalarFieldEnum
    having?: PriceHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceHistoryCountAggregateInputType | true
    _avg?: PriceHistoryAvgAggregateInputType
    _sum?: PriceHistorySumAggregateInputType
    _min?: PriceHistoryMinAggregateInputType
    _max?: PriceHistoryMaxAggregateInputType
  }

  export type PriceHistoryGroupByOutputType = {
    id: string
    grocery_price_id: string
    price: number
    changed_at: Date
    changed_by: string | null
    reason: string | null
    _count: PriceHistoryCountAggregateOutputType | null
    _avg: PriceHistoryAvgAggregateOutputType | null
    _sum: PriceHistorySumAggregateOutputType | null
    _min: PriceHistoryMinAggregateOutputType | null
    _max: PriceHistoryMaxAggregateOutputType | null
  }

  type GetPriceHistoryGroupByPayload<T extends PriceHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PriceHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PriceHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grocery_price_id?: boolean
    price?: boolean
    changed_at?: boolean
    changed_by?: boolean
    reason?: boolean
    grocery_price?: boolean | GroceryPriceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceHistory"]>

  export type PriceHistorySelectScalar = {
    id?: boolean
    grocery_price_id?: boolean
    price?: boolean
    changed_at?: boolean
    changed_by?: boolean
    reason?: boolean
  }

  export type PriceHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grocery_price?: boolean | GroceryPriceDefaultArgs<ExtArgs>
  }


  export type $PriceHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceHistory"
    objects: {
      grocery_price: Prisma.$GroceryPricePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      grocery_price_id: string
      price: number
      changed_at: Date
      changed_by: string | null
      reason: string | null
    }, ExtArgs["result"]["priceHistory"]>
    composites: {}
  }


  type PriceHistoryGetPayload<S extends boolean | null | undefined | PriceHistoryDefaultArgs> = $Result.GetResult<Prisma.$PriceHistoryPayload, S>

  type PriceHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PriceHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PriceHistoryCountAggregateInputType | true
    }

  export interface PriceHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceHistory'], meta: { name: 'PriceHistory' } }
    /**
     * Find zero or one PriceHistory that matches the filter.
     * @param {PriceHistoryFindUniqueArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PriceHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PriceHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PriceHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PriceHistoryFindUniqueOrThrowArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PriceHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PriceHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PriceHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindFirstArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PriceHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PriceHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PriceHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindFirstOrThrowArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PriceHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PriceHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PriceHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceHistories
     * const priceHistories = await prisma.priceHistory.findMany()
     * 
     * // Get first 10 PriceHistories
     * const priceHistories = await prisma.priceHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceHistoryWithIdOnly = await prisma.priceHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PriceHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PriceHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PriceHistory.
     * @param {PriceHistoryCreateArgs} args - Arguments to create a PriceHistory.
     * @example
     * // Create one PriceHistory
     * const PriceHistory = await prisma.priceHistory.create({
     *   data: {
     *     // ... data to create a PriceHistory
     *   }
     * })
     * 
    **/
    create<T extends PriceHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PriceHistoryCreateArgs<ExtArgs>>
    ): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a PriceHistory.
     * @param {PriceHistoryDeleteArgs} args - Arguments to delete one PriceHistory.
     * @example
     * // Delete one PriceHistory
     * const PriceHistory = await prisma.priceHistory.delete({
     *   where: {
     *     // ... filter to delete one PriceHistory
     *   }
     * })
     * 
    **/
    delete<T extends PriceHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PriceHistoryDeleteArgs<ExtArgs>>
    ): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PriceHistory.
     * @param {PriceHistoryUpdateArgs} args - Arguments to update one PriceHistory.
     * @example
     * // Update one PriceHistory
     * const priceHistory = await prisma.priceHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PriceHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PriceHistoryUpdateArgs<ExtArgs>>
    ): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PriceHistories.
     * @param {PriceHistoryDeleteManyArgs} args - Arguments to filter PriceHistories to delete.
     * @example
     * // Delete a few PriceHistories
     * const { count } = await prisma.priceHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PriceHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PriceHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceHistories
     * const priceHistory = await prisma.priceHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PriceHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PriceHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PriceHistory.
     * @param {PriceHistoryUpsertArgs} args - Arguments to update or create a PriceHistory.
     * @example
     * // Update or create a PriceHistory
     * const priceHistory = await prisma.priceHistory.upsert({
     *   create: {
     *     // ... data to create a PriceHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceHistory we want to update
     *   }
     * })
    **/
    upsert<T extends PriceHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PriceHistoryUpsertArgs<ExtArgs>>
    ): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryCountArgs} args - Arguments to filter PriceHistories to count.
     * @example
     * // Count the number of PriceHistories
     * const count = await prisma.priceHistory.count({
     *   where: {
     *     // ... the filter for the PriceHistories we want to count
     *   }
     * })
    **/
    count<T extends PriceHistoryCountArgs>(
      args?: Subset<T, PriceHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceHistoryAggregateArgs>(args: Subset<T, PriceHistoryAggregateArgs>): Prisma.PrismaPromise<GetPriceHistoryAggregateType<T>>

    /**
     * Group by PriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PriceHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceHistory model
   */
  readonly fields: PriceHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    grocery_price<T extends GroceryPriceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroceryPriceDefaultArgs<ExtArgs>>): Prisma__GroceryPriceClient<$Result.GetResult<Prisma.$GroceryPricePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PriceHistory model
   */ 
  interface PriceHistoryFieldRefs {
    readonly id: FieldRef<"PriceHistory", 'String'>
    readonly grocery_price_id: FieldRef<"PriceHistory", 'String'>
    readonly price: FieldRef<"PriceHistory", 'Float'>
    readonly changed_at: FieldRef<"PriceHistory", 'DateTime'>
    readonly changed_by: FieldRef<"PriceHistory", 'String'>
    readonly reason: FieldRef<"PriceHistory", 'String'>
  }
    

  // Custom InputTypes

  /**
   * PriceHistory findUnique
   */
  export type PriceHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where: PriceHistoryWhereUniqueInput
  }


  /**
   * PriceHistory findUniqueOrThrow
   */
  export type PriceHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where: PriceHistoryWhereUniqueInput
  }


  /**
   * PriceHistory findFirst
   */
  export type PriceHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceHistories.
     */
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }


  /**
   * PriceHistory findFirstOrThrow
   */
  export type PriceHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceHistories.
     */
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }


  /**
   * PriceHistory findMany
   */
  export type PriceHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistories to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }


  /**
   * PriceHistory create
   */
  export type PriceHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceHistory.
     */
    data: XOR<PriceHistoryCreateInput, PriceHistoryUncheckedCreateInput>
  }


  /**
   * PriceHistory update
   */
  export type PriceHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceHistory.
     */
    data: XOR<PriceHistoryUpdateInput, PriceHistoryUncheckedUpdateInput>
    /**
     * Choose, which PriceHistory to update.
     */
    where: PriceHistoryWhereUniqueInput
  }


  /**
   * PriceHistory updateMany
   */
  export type PriceHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceHistories.
     */
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PriceHistories to update
     */
    where?: PriceHistoryWhereInput
  }


  /**
   * PriceHistory upsert
   */
  export type PriceHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceHistory to update in case it exists.
     */
    where: PriceHistoryWhereUniqueInput
    /**
     * In case the PriceHistory found by the `where` argument doesn't exist, create a new PriceHistory with this data.
     */
    create: XOR<PriceHistoryCreateInput, PriceHistoryUncheckedCreateInput>
    /**
     * In case the PriceHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceHistoryUpdateInput, PriceHistoryUncheckedUpdateInput>
  }


  /**
   * PriceHistory delete
   */
  export type PriceHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter which PriceHistory to delete.
     */
    where: PriceHistoryWhereUniqueInput
  }


  /**
   * PriceHistory deleteMany
   */
  export type PriceHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceHistories to delete
     */
    where?: PriceHistoryWhereInput
  }


  /**
   * PriceHistory without action
   */
  export type PriceHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
  }



  /**
   * Model Recipe
   */

  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeAvgAggregateOutputType = {
    yield_count: number | null
    target_cost_pct: number | null
    manual_price: number | null
  }

  export type RecipeSumAggregateOutputType = {
    yield_count: number | null
    target_cost_pct: number | null
    manual_price: number | null
  }

  export type RecipeMinAggregateOutputType = {
    id: string | null
    name: string | null
    menu_item: string | null
    version: string | null
    country: string | null
    yield_count: number | null
    target_cost_pct: number | null
    manual_price: number | null
    created_at: Date | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    menu_item: string | null
    version: string | null
    country: string | null
    yield_count: number | null
    target_cost_pct: number | null
    manual_price: number | null
    created_at: Date | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    name: number
    menu_item: number
    version: number
    country: number
    yield_count: number
    target_cost_pct: number
    manual_price: number
    created_at: number
    _all: number
  }


  export type RecipeAvgAggregateInputType = {
    yield_count?: true
    target_cost_pct?: true
    manual_price?: true
  }

  export type RecipeSumAggregateInputType = {
    yield_count?: true
    target_cost_pct?: true
    manual_price?: true
  }

  export type RecipeMinAggregateInputType = {
    id?: true
    name?: true
    menu_item?: true
    version?: true
    country?: true
    yield_count?: true
    target_cost_pct?: true
    manual_price?: true
    created_at?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    name?: true
    menu_item?: true
    version?: true
    country?: true
    yield_count?: true
    target_cost_pct?: true
    manual_price?: true
    created_at?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    name?: true
    menu_item?: true
    version?: true
    country?: true
    yield_count?: true
    target_cost_pct?: true
    manual_price?: true
    created_at?: true
    _all?: true
  }

  export type RecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipe to aggregate.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithAggregationInput | RecipeOrderByWithAggregationInput[]
    by: RecipeScalarFieldEnum[] | RecipeScalarFieldEnum
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _avg?: RecipeAvgAggregateInputType
    _sum?: RecipeSumAggregateInputType
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }

  export type RecipeGroupByOutputType = {
    id: string
    name: string
    menu_item: string
    version: string
    country: string | null
    yield_count: number
    target_cost_pct: number
    manual_price: number | null
    created_at: Date
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    menu_item?: boolean
    version?: boolean
    country?: boolean
    yield_count?: boolean
    target_cost_pct?: boolean
    manual_price?: boolean
    created_at?: boolean
    lines?: boolean | Recipe$linesArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectScalar = {
    id?: boolean
    name?: boolean
    menu_item?: boolean
    version?: boolean
    country?: boolean
    yield_count?: boolean
    target_cost_pct?: boolean
    manual_price?: boolean
    created_at?: boolean
  }

  export type RecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | Recipe$linesArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipe"
    objects: {
      lines: Prisma.$RecipeLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      menu_item: string
      version: string
      country: string | null
      yield_count: number
      target_cost_pct: number
      manual_price: number | null
      created_at: Date
    }, ExtArgs["result"]["recipe"]>
    composites: {}
  }


  type RecipeGetPayload<S extends boolean | null | undefined | RecipeDefaultArgs> = $Result.GetResult<Prisma.$RecipePayload, S>

  type RecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipeCountAggregateInputType | true
    }

  export interface RecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipe'], meta: { name: 'Recipe' } }
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeFindUniqueArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Recipe that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindFirstArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Recipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecipeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
    **/
    create<T extends RecipeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeCreateArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
    **/
    delete<T extends RecipeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeDeleteArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeUpdateArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeUpsertArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): Prisma.PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipe model
   */
  readonly fields: RecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    lines<T extends Recipe$linesArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeLinePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Recipe model
   */ 
  interface RecipeFieldRefs {
    readonly id: FieldRef<"Recipe", 'String'>
    readonly name: FieldRef<"Recipe", 'String'>
    readonly menu_item: FieldRef<"Recipe", 'String'>
    readonly version: FieldRef<"Recipe", 'String'>
    readonly country: FieldRef<"Recipe", 'String'>
    readonly yield_count: FieldRef<"Recipe", 'Float'>
    readonly target_cost_pct: FieldRef<"Recipe", 'Float'>
    readonly manual_price: FieldRef<"Recipe", 'Float'>
    readonly created_at: FieldRef<"Recipe", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Recipe findUnique
   */
  export type RecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe findFirst
   */
  export type RecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * Recipe findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipes to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * Recipe create
   */
  export type RecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a Recipe.
     */
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }


  /**
   * Recipe update
   */
  export type RecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a Recipe.
     */
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
  }


  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     */
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     */
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }


  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter which Recipe to delete.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipes to delete
     */
    where?: RecipeWhereInput
  }


  /**
   * Recipe.lines
   */
  export type Recipe$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeLine
     */
    select?: RecipeLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeLineInclude<ExtArgs> | null
    where?: RecipeLineWhereInput
    orderBy?: RecipeLineOrderByWithRelationInput | RecipeLineOrderByWithRelationInput[]
    cursor?: RecipeLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeLineScalarFieldEnum | RecipeLineScalarFieldEnum[]
  }


  /**
   * Recipe without action
   */
  export type RecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
  }



  /**
   * Model RecipeLine
   */

  export type AggregateRecipeLine = {
    _count: RecipeLineCountAggregateOutputType | null
    _avg: RecipeLineAvgAggregateOutputType | null
    _sum: RecipeLineSumAggregateOutputType | null
    _min: RecipeLineMinAggregateOutputType | null
    _max: RecipeLineMaxAggregateOutputType | null
  }

  export type RecipeLineAvgAggregateOutputType = {
    quantity: number | null
  }

  export type RecipeLineSumAggregateOutputType = {
    quantity: number | null
  }

  export type RecipeLineMinAggregateOutputType = {
    id: string | null
    recipe_id: string | null
    ingredient_id: string | null
    quantity: number | null
    unit: string | null
  }

  export type RecipeLineMaxAggregateOutputType = {
    id: string | null
    recipe_id: string | null
    ingredient_id: string | null
    quantity: number | null
    unit: string | null
  }

  export type RecipeLineCountAggregateOutputType = {
    id: number
    recipe_id: number
    ingredient_id: number
    quantity: number
    unit: number
    _all: number
  }


  export type RecipeLineAvgAggregateInputType = {
    quantity?: true
  }

  export type RecipeLineSumAggregateInputType = {
    quantity?: true
  }

  export type RecipeLineMinAggregateInputType = {
    id?: true
    recipe_id?: true
    ingredient_id?: true
    quantity?: true
    unit?: true
  }

  export type RecipeLineMaxAggregateInputType = {
    id?: true
    recipe_id?: true
    ingredient_id?: true
    quantity?: true
    unit?: true
  }

  export type RecipeLineCountAggregateInputType = {
    id?: true
    recipe_id?: true
    ingredient_id?: true
    quantity?: true
    unit?: true
    _all?: true
  }

  export type RecipeLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeLine to aggregate.
     */
    where?: RecipeLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeLines to fetch.
     */
    orderBy?: RecipeLineOrderByWithRelationInput | RecipeLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeLines
    **/
    _count?: true | RecipeLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeLineMaxAggregateInputType
  }

  export type GetRecipeLineAggregateType<T extends RecipeLineAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeLine[P]>
      : GetScalarType<T[P], AggregateRecipeLine[P]>
  }




  export type RecipeLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeLineWhereInput
    orderBy?: RecipeLineOrderByWithAggregationInput | RecipeLineOrderByWithAggregationInput[]
    by: RecipeLineScalarFieldEnum[] | RecipeLineScalarFieldEnum
    having?: RecipeLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeLineCountAggregateInputType | true
    _avg?: RecipeLineAvgAggregateInputType
    _sum?: RecipeLineSumAggregateInputType
    _min?: RecipeLineMinAggregateInputType
    _max?: RecipeLineMaxAggregateInputType
  }

  export type RecipeLineGroupByOutputType = {
    id: string
    recipe_id: string
    ingredient_id: string
    quantity: number
    unit: string
    _count: RecipeLineCountAggregateOutputType | null
    _avg: RecipeLineAvgAggregateOutputType | null
    _sum: RecipeLineSumAggregateOutputType | null
    _min: RecipeLineMinAggregateOutputType | null
    _max: RecipeLineMaxAggregateOutputType | null
  }

  type GetRecipeLineGroupByPayload<T extends RecipeLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeLineGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeLineGroupByOutputType[P]>
        }
      >
    >


  export type RecipeLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipe_id?: boolean
    ingredient_id?: boolean
    quantity?: boolean
    unit?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeLine"]>

  export type RecipeLineSelectScalar = {
    id?: boolean
    recipe_id?: boolean
    ingredient_id?: boolean
    quantity?: boolean
    unit?: boolean
  }

  export type RecipeLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
  }


  export type $RecipeLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeLine"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
      ingredient: Prisma.$IngredientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipe_id: string
      ingredient_id: string
      quantity: number
      unit: string
    }, ExtArgs["result"]["recipeLine"]>
    composites: {}
  }


  type RecipeLineGetPayload<S extends boolean | null | undefined | RecipeLineDefaultArgs> = $Result.GetResult<Prisma.$RecipeLinePayload, S>

  type RecipeLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipeLineCountAggregateInputType | true
    }

  export interface RecipeLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeLine'], meta: { name: 'RecipeLine' } }
    /**
     * Find zero or one RecipeLine that matches the filter.
     * @param {RecipeLineFindUniqueArgs} args - Arguments to find a RecipeLine
     * @example
     * // Get one RecipeLine
     * const recipeLine = await prisma.recipeLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeLineFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeLineFindUniqueArgs<ExtArgs>>
    ): Prisma__RecipeLineClient<$Result.GetResult<Prisma.$RecipeLinePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RecipeLine that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RecipeLineFindUniqueOrThrowArgs} args - Arguments to find a RecipeLine
     * @example
     * // Get one RecipeLine
     * const recipeLine = await prisma.recipeLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeLineFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeLineFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeLineClient<$Result.GetResult<Prisma.$RecipeLinePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RecipeLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeLineFindFirstArgs} args - Arguments to find a RecipeLine
     * @example
     * // Get one RecipeLine
     * const recipeLine = await prisma.recipeLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeLineFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeLineFindFirstArgs<ExtArgs>>
    ): Prisma__RecipeLineClient<$Result.GetResult<Prisma.$RecipeLinePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RecipeLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeLineFindFirstOrThrowArgs} args - Arguments to find a RecipeLine
     * @example
     * // Get one RecipeLine
     * const recipeLine = await prisma.recipeLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeLineFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeLineFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeLineClient<$Result.GetResult<Prisma.$RecipeLinePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RecipeLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeLineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeLines
     * const recipeLines = await prisma.recipeLine.findMany()
     * 
     * // Get first 10 RecipeLines
     * const recipeLines = await prisma.recipeLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeLineWithIdOnly = await prisma.recipeLine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecipeLineFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeLineFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeLinePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RecipeLine.
     * @param {RecipeLineCreateArgs} args - Arguments to create a RecipeLine.
     * @example
     * // Create one RecipeLine
     * const RecipeLine = await prisma.recipeLine.create({
     *   data: {
     *     // ... data to create a RecipeLine
     *   }
     * })
     * 
    **/
    create<T extends RecipeLineCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeLineCreateArgs<ExtArgs>>
    ): Prisma__RecipeLineClient<$Result.GetResult<Prisma.$RecipeLinePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a RecipeLine.
     * @param {RecipeLineDeleteArgs} args - Arguments to delete one RecipeLine.
     * @example
     * // Delete one RecipeLine
     * const RecipeLine = await prisma.recipeLine.delete({
     *   where: {
     *     // ... filter to delete one RecipeLine
     *   }
     * })
     * 
    **/
    delete<T extends RecipeLineDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeLineDeleteArgs<ExtArgs>>
    ): Prisma__RecipeLineClient<$Result.GetResult<Prisma.$RecipeLinePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RecipeLine.
     * @param {RecipeLineUpdateArgs} args - Arguments to update one RecipeLine.
     * @example
     * // Update one RecipeLine
     * const recipeLine = await prisma.recipeLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeLineUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeLineUpdateArgs<ExtArgs>>
    ): Prisma__RecipeLineClient<$Result.GetResult<Prisma.$RecipeLinePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RecipeLines.
     * @param {RecipeLineDeleteManyArgs} args - Arguments to filter RecipeLines to delete.
     * @example
     * // Delete a few RecipeLines
     * const { count } = await prisma.recipeLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeLineDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeLineDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeLines
     * const recipeLine = await prisma.recipeLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeLineUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeLineUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeLine.
     * @param {RecipeLineUpsertArgs} args - Arguments to update or create a RecipeLine.
     * @example
     * // Update or create a RecipeLine
     * const recipeLine = await prisma.recipeLine.upsert({
     *   create: {
     *     // ... data to create a RecipeLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeLine we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeLineUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeLineUpsertArgs<ExtArgs>>
    ): Prisma__RecipeLineClient<$Result.GetResult<Prisma.$RecipeLinePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RecipeLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeLineCountArgs} args - Arguments to filter RecipeLines to count.
     * @example
     * // Count the number of RecipeLines
     * const count = await prisma.recipeLine.count({
     *   where: {
     *     // ... the filter for the RecipeLines we want to count
     *   }
     * })
    **/
    count<T extends RecipeLineCountArgs>(
      args?: Subset<T, RecipeLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeLineAggregateArgs>(args: Subset<T, RecipeLineAggregateArgs>): Prisma.PrismaPromise<GetRecipeLineAggregateType<T>>

    /**
     * Group by RecipeLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeLineGroupByArgs['orderBy'] }
        : { orderBy?: RecipeLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeLine model
   */
  readonly fields: RecipeLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ingredient<T extends IngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngredientDefaultArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RecipeLine model
   */ 
  interface RecipeLineFieldRefs {
    readonly id: FieldRef<"RecipeLine", 'String'>
    readonly recipe_id: FieldRef<"RecipeLine", 'String'>
    readonly ingredient_id: FieldRef<"RecipeLine", 'String'>
    readonly quantity: FieldRef<"RecipeLine", 'Float'>
    readonly unit: FieldRef<"RecipeLine", 'String'>
  }
    

  // Custom InputTypes

  /**
   * RecipeLine findUnique
   */
  export type RecipeLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeLine
     */
    select?: RecipeLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeLineInclude<ExtArgs> | null
    /**
     * Filter, which RecipeLine to fetch.
     */
    where: RecipeLineWhereUniqueInput
  }


  /**
   * RecipeLine findUniqueOrThrow
   */
  export type RecipeLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeLine
     */
    select?: RecipeLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeLineInclude<ExtArgs> | null
    /**
     * Filter, which RecipeLine to fetch.
     */
    where: RecipeLineWhereUniqueInput
  }


  /**
   * RecipeLine findFirst
   */
  export type RecipeLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeLine
     */
    select?: RecipeLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeLineInclude<ExtArgs> | null
    /**
     * Filter, which RecipeLine to fetch.
     */
    where?: RecipeLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeLines to fetch.
     */
    orderBy?: RecipeLineOrderByWithRelationInput | RecipeLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeLines.
     */
    cursor?: RecipeLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeLines.
     */
    distinct?: RecipeLineScalarFieldEnum | RecipeLineScalarFieldEnum[]
  }


  /**
   * RecipeLine findFirstOrThrow
   */
  export type RecipeLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeLine
     */
    select?: RecipeLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeLineInclude<ExtArgs> | null
    /**
     * Filter, which RecipeLine to fetch.
     */
    where?: RecipeLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeLines to fetch.
     */
    orderBy?: RecipeLineOrderByWithRelationInput | RecipeLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeLines.
     */
    cursor?: RecipeLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeLines.
     */
    distinct?: RecipeLineScalarFieldEnum | RecipeLineScalarFieldEnum[]
  }


  /**
   * RecipeLine findMany
   */
  export type RecipeLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeLine
     */
    select?: RecipeLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeLineInclude<ExtArgs> | null
    /**
     * Filter, which RecipeLines to fetch.
     */
    where?: RecipeLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeLines to fetch.
     */
    orderBy?: RecipeLineOrderByWithRelationInput | RecipeLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeLines.
     */
    cursor?: RecipeLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeLines.
     */
    skip?: number
    distinct?: RecipeLineScalarFieldEnum | RecipeLineScalarFieldEnum[]
  }


  /**
   * RecipeLine create
   */
  export type RecipeLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeLine
     */
    select?: RecipeLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeLineInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeLine.
     */
    data: XOR<RecipeLineCreateInput, RecipeLineUncheckedCreateInput>
  }


  /**
   * RecipeLine update
   */
  export type RecipeLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeLine
     */
    select?: RecipeLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeLineInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeLine.
     */
    data: XOR<RecipeLineUpdateInput, RecipeLineUncheckedUpdateInput>
    /**
     * Choose, which RecipeLine to update.
     */
    where: RecipeLineWhereUniqueInput
  }


  /**
   * RecipeLine updateMany
   */
  export type RecipeLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeLines.
     */
    data: XOR<RecipeLineUpdateManyMutationInput, RecipeLineUncheckedUpdateManyInput>
    /**
     * Filter which RecipeLines to update
     */
    where?: RecipeLineWhereInput
  }


  /**
   * RecipeLine upsert
   */
  export type RecipeLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeLine
     */
    select?: RecipeLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeLineInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeLine to update in case it exists.
     */
    where: RecipeLineWhereUniqueInput
    /**
     * In case the RecipeLine found by the `where` argument doesn't exist, create a new RecipeLine with this data.
     */
    create: XOR<RecipeLineCreateInput, RecipeLineUncheckedCreateInput>
    /**
     * In case the RecipeLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeLineUpdateInput, RecipeLineUncheckedUpdateInput>
  }


  /**
   * RecipeLine delete
   */
  export type RecipeLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeLine
     */
    select?: RecipeLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeLineInclude<ExtArgs> | null
    /**
     * Filter which RecipeLine to delete.
     */
    where: RecipeLineWhereUniqueInput
  }


  /**
   * RecipeLine deleteMany
   */
  export type RecipeLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeLines to delete
     */
    where?: RecipeLineWhereInput
  }


  /**
   * RecipeLine without action
   */
  export type RecipeLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeLine
     */
    select?: RecipeLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeLineInclude<ExtArgs> | null
  }



  /**
   * Model CompetitorPrice
   */

  export type AggregateCompetitorPrice = {
    _count: CompetitorPriceCountAggregateOutputType | null
    _avg: CompetitorPriceAvgAggregateOutputType | null
    _sum: CompetitorPriceSumAggregateOutputType | null
    _min: CompetitorPriceMinAggregateOutputType | null
    _max: CompetitorPriceMaxAggregateOutputType | null
  }

  export type CompetitorPriceAvgAggregateOutputType = {
    price: number | null
  }

  export type CompetitorPriceSumAggregateOutputType = {
    price: number | null
  }

  export type CompetitorPriceMinAggregateOutputType = {
    id: string | null
    country: string | null
    brand: string | null
    menu_item: string | null
    price: number | null
    currency: string | null
    as_of: Date | null
  }

  export type CompetitorPriceMaxAggregateOutputType = {
    id: string | null
    country: string | null
    brand: string | null
    menu_item: string | null
    price: number | null
    currency: string | null
    as_of: Date | null
  }

  export type CompetitorPriceCountAggregateOutputType = {
    id: number
    country: number
    brand: number
    menu_item: number
    price: number
    currency: number
    as_of: number
    _all: number
  }


  export type CompetitorPriceAvgAggregateInputType = {
    price?: true
  }

  export type CompetitorPriceSumAggregateInputType = {
    price?: true
  }

  export type CompetitorPriceMinAggregateInputType = {
    id?: true
    country?: true
    brand?: true
    menu_item?: true
    price?: true
    currency?: true
    as_of?: true
  }

  export type CompetitorPriceMaxAggregateInputType = {
    id?: true
    country?: true
    brand?: true
    menu_item?: true
    price?: true
    currency?: true
    as_of?: true
  }

  export type CompetitorPriceCountAggregateInputType = {
    id?: true
    country?: true
    brand?: true
    menu_item?: true
    price?: true
    currency?: true
    as_of?: true
    _all?: true
  }

  export type CompetitorPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompetitorPrice to aggregate.
     */
    where?: CompetitorPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorPrices to fetch.
     */
    orderBy?: CompetitorPriceOrderByWithRelationInput | CompetitorPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompetitorPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompetitorPrices
    **/
    _count?: true | CompetitorPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompetitorPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompetitorPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompetitorPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompetitorPriceMaxAggregateInputType
  }

  export type GetCompetitorPriceAggregateType<T extends CompetitorPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateCompetitorPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompetitorPrice[P]>
      : GetScalarType<T[P], AggregateCompetitorPrice[P]>
  }




  export type CompetitorPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompetitorPriceWhereInput
    orderBy?: CompetitorPriceOrderByWithAggregationInput | CompetitorPriceOrderByWithAggregationInput[]
    by: CompetitorPriceScalarFieldEnum[] | CompetitorPriceScalarFieldEnum
    having?: CompetitorPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompetitorPriceCountAggregateInputType | true
    _avg?: CompetitorPriceAvgAggregateInputType
    _sum?: CompetitorPriceSumAggregateInputType
    _min?: CompetitorPriceMinAggregateInputType
    _max?: CompetitorPriceMaxAggregateInputType
  }

  export type CompetitorPriceGroupByOutputType = {
    id: string
    country: string
    brand: string
    menu_item: string
    price: number
    currency: string
    as_of: Date
    _count: CompetitorPriceCountAggregateOutputType | null
    _avg: CompetitorPriceAvgAggregateOutputType | null
    _sum: CompetitorPriceSumAggregateOutputType | null
    _min: CompetitorPriceMinAggregateOutputType | null
    _max: CompetitorPriceMaxAggregateOutputType | null
  }

  type GetCompetitorPriceGroupByPayload<T extends CompetitorPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompetitorPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompetitorPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompetitorPriceGroupByOutputType[P]>
            : GetScalarType<T[P], CompetitorPriceGroupByOutputType[P]>
        }
      >
    >


  export type CompetitorPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    country?: boolean
    brand?: boolean
    menu_item?: boolean
    price?: boolean
    currency?: boolean
    as_of?: boolean
  }, ExtArgs["result"]["competitorPrice"]>

  export type CompetitorPriceSelectScalar = {
    id?: boolean
    country?: boolean
    brand?: boolean
    menu_item?: boolean
    price?: boolean
    currency?: boolean
    as_of?: boolean
  }


  export type $CompetitorPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompetitorPrice"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      country: string
      brand: string
      menu_item: string
      price: number
      currency: string
      as_of: Date
    }, ExtArgs["result"]["competitorPrice"]>
    composites: {}
  }


  type CompetitorPriceGetPayload<S extends boolean | null | undefined | CompetitorPriceDefaultArgs> = $Result.GetResult<Prisma.$CompetitorPricePayload, S>

  type CompetitorPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompetitorPriceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompetitorPriceCountAggregateInputType | true
    }

  export interface CompetitorPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompetitorPrice'], meta: { name: 'CompetitorPrice' } }
    /**
     * Find zero or one CompetitorPrice that matches the filter.
     * @param {CompetitorPriceFindUniqueArgs} args - Arguments to find a CompetitorPrice
     * @example
     * // Get one CompetitorPrice
     * const competitorPrice = await prisma.competitorPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompetitorPriceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CompetitorPriceFindUniqueArgs<ExtArgs>>
    ): Prisma__CompetitorPriceClient<$Result.GetResult<Prisma.$CompetitorPricePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CompetitorPrice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CompetitorPriceFindUniqueOrThrowArgs} args - Arguments to find a CompetitorPrice
     * @example
     * // Get one CompetitorPrice
     * const competitorPrice = await prisma.competitorPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompetitorPriceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompetitorPriceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CompetitorPriceClient<$Result.GetResult<Prisma.$CompetitorPricePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CompetitorPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorPriceFindFirstArgs} args - Arguments to find a CompetitorPrice
     * @example
     * // Get one CompetitorPrice
     * const competitorPrice = await prisma.competitorPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompetitorPriceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CompetitorPriceFindFirstArgs<ExtArgs>>
    ): Prisma__CompetitorPriceClient<$Result.GetResult<Prisma.$CompetitorPricePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CompetitorPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorPriceFindFirstOrThrowArgs} args - Arguments to find a CompetitorPrice
     * @example
     * // Get one CompetitorPrice
     * const competitorPrice = await prisma.competitorPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompetitorPriceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompetitorPriceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CompetitorPriceClient<$Result.GetResult<Prisma.$CompetitorPricePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CompetitorPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorPriceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompetitorPrices
     * const competitorPrices = await prisma.competitorPrice.findMany()
     * 
     * // Get first 10 CompetitorPrices
     * const competitorPrices = await prisma.competitorPrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const competitorPriceWithIdOnly = await prisma.competitorPrice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CompetitorPriceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompetitorPriceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetitorPricePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CompetitorPrice.
     * @param {CompetitorPriceCreateArgs} args - Arguments to create a CompetitorPrice.
     * @example
     * // Create one CompetitorPrice
     * const CompetitorPrice = await prisma.competitorPrice.create({
     *   data: {
     *     // ... data to create a CompetitorPrice
     *   }
     * })
     * 
    **/
    create<T extends CompetitorPriceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CompetitorPriceCreateArgs<ExtArgs>>
    ): Prisma__CompetitorPriceClient<$Result.GetResult<Prisma.$CompetitorPricePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a CompetitorPrice.
     * @param {CompetitorPriceDeleteArgs} args - Arguments to delete one CompetitorPrice.
     * @example
     * // Delete one CompetitorPrice
     * const CompetitorPrice = await prisma.competitorPrice.delete({
     *   where: {
     *     // ... filter to delete one CompetitorPrice
     *   }
     * })
     * 
    **/
    delete<T extends CompetitorPriceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CompetitorPriceDeleteArgs<ExtArgs>>
    ): Prisma__CompetitorPriceClient<$Result.GetResult<Prisma.$CompetitorPricePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CompetitorPrice.
     * @param {CompetitorPriceUpdateArgs} args - Arguments to update one CompetitorPrice.
     * @example
     * // Update one CompetitorPrice
     * const competitorPrice = await prisma.competitorPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompetitorPriceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CompetitorPriceUpdateArgs<ExtArgs>>
    ): Prisma__CompetitorPriceClient<$Result.GetResult<Prisma.$CompetitorPricePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CompetitorPrices.
     * @param {CompetitorPriceDeleteManyArgs} args - Arguments to filter CompetitorPrices to delete.
     * @example
     * // Delete a few CompetitorPrices
     * const { count } = await prisma.competitorPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompetitorPriceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompetitorPriceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompetitorPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompetitorPrices
     * const competitorPrice = await prisma.competitorPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompetitorPriceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CompetitorPriceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompetitorPrice.
     * @param {CompetitorPriceUpsertArgs} args - Arguments to update or create a CompetitorPrice.
     * @example
     * // Update or create a CompetitorPrice
     * const competitorPrice = await prisma.competitorPrice.upsert({
     *   create: {
     *     // ... data to create a CompetitorPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompetitorPrice we want to update
     *   }
     * })
    **/
    upsert<T extends CompetitorPriceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CompetitorPriceUpsertArgs<ExtArgs>>
    ): Prisma__CompetitorPriceClient<$Result.GetResult<Prisma.$CompetitorPricePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CompetitorPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorPriceCountArgs} args - Arguments to filter CompetitorPrices to count.
     * @example
     * // Count the number of CompetitorPrices
     * const count = await prisma.competitorPrice.count({
     *   where: {
     *     // ... the filter for the CompetitorPrices we want to count
     *   }
     * })
    **/
    count<T extends CompetitorPriceCountArgs>(
      args?: Subset<T, CompetitorPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompetitorPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompetitorPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompetitorPriceAggregateArgs>(args: Subset<T, CompetitorPriceAggregateArgs>): Prisma.PrismaPromise<GetCompetitorPriceAggregateType<T>>

    /**
     * Group by CompetitorPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompetitorPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompetitorPriceGroupByArgs['orderBy'] }
        : { orderBy?: CompetitorPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompetitorPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompetitorPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompetitorPrice model
   */
  readonly fields: CompetitorPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompetitorPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompetitorPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CompetitorPrice model
   */ 
  interface CompetitorPriceFieldRefs {
    readonly id: FieldRef<"CompetitorPrice", 'String'>
    readonly country: FieldRef<"CompetitorPrice", 'String'>
    readonly brand: FieldRef<"CompetitorPrice", 'String'>
    readonly menu_item: FieldRef<"CompetitorPrice", 'String'>
    readonly price: FieldRef<"CompetitorPrice", 'Float'>
    readonly currency: FieldRef<"CompetitorPrice", 'String'>
    readonly as_of: FieldRef<"CompetitorPrice", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CompetitorPrice findUnique
   */
  export type CompetitorPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorPrice
     */
    select?: CompetitorPriceSelect<ExtArgs> | null
    /**
     * Filter, which CompetitorPrice to fetch.
     */
    where: CompetitorPriceWhereUniqueInput
  }


  /**
   * CompetitorPrice findUniqueOrThrow
   */
  export type CompetitorPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorPrice
     */
    select?: CompetitorPriceSelect<ExtArgs> | null
    /**
     * Filter, which CompetitorPrice to fetch.
     */
    where: CompetitorPriceWhereUniqueInput
  }


  /**
   * CompetitorPrice findFirst
   */
  export type CompetitorPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorPrice
     */
    select?: CompetitorPriceSelect<ExtArgs> | null
    /**
     * Filter, which CompetitorPrice to fetch.
     */
    where?: CompetitorPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorPrices to fetch.
     */
    orderBy?: CompetitorPriceOrderByWithRelationInput | CompetitorPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompetitorPrices.
     */
    cursor?: CompetitorPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompetitorPrices.
     */
    distinct?: CompetitorPriceScalarFieldEnum | CompetitorPriceScalarFieldEnum[]
  }


  /**
   * CompetitorPrice findFirstOrThrow
   */
  export type CompetitorPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorPrice
     */
    select?: CompetitorPriceSelect<ExtArgs> | null
    /**
     * Filter, which CompetitorPrice to fetch.
     */
    where?: CompetitorPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorPrices to fetch.
     */
    orderBy?: CompetitorPriceOrderByWithRelationInput | CompetitorPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompetitorPrices.
     */
    cursor?: CompetitorPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompetitorPrices.
     */
    distinct?: CompetitorPriceScalarFieldEnum | CompetitorPriceScalarFieldEnum[]
  }


  /**
   * CompetitorPrice findMany
   */
  export type CompetitorPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorPrice
     */
    select?: CompetitorPriceSelect<ExtArgs> | null
    /**
     * Filter, which CompetitorPrices to fetch.
     */
    where?: CompetitorPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorPrices to fetch.
     */
    orderBy?: CompetitorPriceOrderByWithRelationInput | CompetitorPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompetitorPrices.
     */
    cursor?: CompetitorPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorPrices.
     */
    skip?: number
    distinct?: CompetitorPriceScalarFieldEnum | CompetitorPriceScalarFieldEnum[]
  }


  /**
   * CompetitorPrice create
   */
  export type CompetitorPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorPrice
     */
    select?: CompetitorPriceSelect<ExtArgs> | null
    /**
     * The data needed to create a CompetitorPrice.
     */
    data: XOR<CompetitorPriceCreateInput, CompetitorPriceUncheckedCreateInput>
  }


  /**
   * CompetitorPrice update
   */
  export type CompetitorPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorPrice
     */
    select?: CompetitorPriceSelect<ExtArgs> | null
    /**
     * The data needed to update a CompetitorPrice.
     */
    data: XOR<CompetitorPriceUpdateInput, CompetitorPriceUncheckedUpdateInput>
    /**
     * Choose, which CompetitorPrice to update.
     */
    where: CompetitorPriceWhereUniqueInput
  }


  /**
   * CompetitorPrice updateMany
   */
  export type CompetitorPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompetitorPrices.
     */
    data: XOR<CompetitorPriceUpdateManyMutationInput, CompetitorPriceUncheckedUpdateManyInput>
    /**
     * Filter which CompetitorPrices to update
     */
    where?: CompetitorPriceWhereInput
  }


  /**
   * CompetitorPrice upsert
   */
  export type CompetitorPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorPrice
     */
    select?: CompetitorPriceSelect<ExtArgs> | null
    /**
     * The filter to search for the CompetitorPrice to update in case it exists.
     */
    where: CompetitorPriceWhereUniqueInput
    /**
     * In case the CompetitorPrice found by the `where` argument doesn't exist, create a new CompetitorPrice with this data.
     */
    create: XOR<CompetitorPriceCreateInput, CompetitorPriceUncheckedCreateInput>
    /**
     * In case the CompetitorPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompetitorPriceUpdateInput, CompetitorPriceUncheckedUpdateInput>
  }


  /**
   * CompetitorPrice delete
   */
  export type CompetitorPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorPrice
     */
    select?: CompetitorPriceSelect<ExtArgs> | null
    /**
     * Filter which CompetitorPrice to delete.
     */
    where: CompetitorPriceWhereUniqueInput
  }


  /**
   * CompetitorPrice deleteMany
   */
  export type CompetitorPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompetitorPrices to delete
     */
    where?: CompetitorPriceWhereInput
  }


  /**
   * CompetitorPrice without action
   */
  export type CompetitorPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorPrice
     */
    select?: CompetitorPriceSelect<ExtArgs> | null
  }



  /**
   * Model FXRate
   */

  export type AggregateFXRate = {
    _count: FXRateCountAggregateOutputType | null
    _avg: FXRateAvgAggregateOutputType | null
    _sum: FXRateSumAggregateOutputType | null
    _min: FXRateMinAggregateOutputType | null
    _max: FXRateMaxAggregateOutputType | null
  }

  export type FXRateAvgAggregateOutputType = {
    rate: number | null
  }

  export type FXRateSumAggregateOutputType = {
    rate: number | null
  }

  export type FXRateMinAggregateOutputType = {
    id: string | null
    from_currency: string | null
    to_currency: string | null
    rate: number | null
    date: Date | null
  }

  export type FXRateMaxAggregateOutputType = {
    id: string | null
    from_currency: string | null
    to_currency: string | null
    rate: number | null
    date: Date | null
  }

  export type FXRateCountAggregateOutputType = {
    id: number
    from_currency: number
    to_currency: number
    rate: number
    date: number
    _all: number
  }


  export type FXRateAvgAggregateInputType = {
    rate?: true
  }

  export type FXRateSumAggregateInputType = {
    rate?: true
  }

  export type FXRateMinAggregateInputType = {
    id?: true
    from_currency?: true
    to_currency?: true
    rate?: true
    date?: true
  }

  export type FXRateMaxAggregateInputType = {
    id?: true
    from_currency?: true
    to_currency?: true
    rate?: true
    date?: true
  }

  export type FXRateCountAggregateInputType = {
    id?: true
    from_currency?: true
    to_currency?: true
    rate?: true
    date?: true
    _all?: true
  }

  export type FXRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FXRate to aggregate.
     */
    where?: FXRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FXRates to fetch.
     */
    orderBy?: FXRateOrderByWithRelationInput | FXRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FXRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FXRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FXRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FXRates
    **/
    _count?: true | FXRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FXRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FXRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FXRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FXRateMaxAggregateInputType
  }

  export type GetFXRateAggregateType<T extends FXRateAggregateArgs> = {
        [P in keyof T & keyof AggregateFXRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFXRate[P]>
      : GetScalarType<T[P], AggregateFXRate[P]>
  }




  export type FXRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FXRateWhereInput
    orderBy?: FXRateOrderByWithAggregationInput | FXRateOrderByWithAggregationInput[]
    by: FXRateScalarFieldEnum[] | FXRateScalarFieldEnum
    having?: FXRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FXRateCountAggregateInputType | true
    _avg?: FXRateAvgAggregateInputType
    _sum?: FXRateSumAggregateInputType
    _min?: FXRateMinAggregateInputType
    _max?: FXRateMaxAggregateInputType
  }

  export type FXRateGroupByOutputType = {
    id: string
    from_currency: string
    to_currency: string
    rate: number
    date: Date
    _count: FXRateCountAggregateOutputType | null
    _avg: FXRateAvgAggregateOutputType | null
    _sum: FXRateSumAggregateOutputType | null
    _min: FXRateMinAggregateOutputType | null
    _max: FXRateMaxAggregateOutputType | null
  }

  type GetFXRateGroupByPayload<T extends FXRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FXRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FXRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FXRateGroupByOutputType[P]>
            : GetScalarType<T[P], FXRateGroupByOutputType[P]>
        }
      >
    >


  export type FXRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from_currency?: boolean
    to_currency?: boolean
    rate?: boolean
    date?: boolean
  }, ExtArgs["result"]["fXRate"]>

  export type FXRateSelectScalar = {
    id?: boolean
    from_currency?: boolean
    to_currency?: boolean
    rate?: boolean
    date?: boolean
  }


  export type $FXRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FXRate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      from_currency: string
      to_currency: string
      rate: number
      date: Date
    }, ExtArgs["result"]["fXRate"]>
    composites: {}
  }


  type FXRateGetPayload<S extends boolean | null | undefined | FXRateDefaultArgs> = $Result.GetResult<Prisma.$FXRatePayload, S>

  type FXRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FXRateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FXRateCountAggregateInputType | true
    }

  export interface FXRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FXRate'], meta: { name: 'FXRate' } }
    /**
     * Find zero or one FXRate that matches the filter.
     * @param {FXRateFindUniqueArgs} args - Arguments to find a FXRate
     * @example
     * // Get one FXRate
     * const fXRate = await prisma.fXRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FXRateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FXRateFindUniqueArgs<ExtArgs>>
    ): Prisma__FXRateClient<$Result.GetResult<Prisma.$FXRatePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FXRate that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FXRateFindUniqueOrThrowArgs} args - Arguments to find a FXRate
     * @example
     * // Get one FXRate
     * const fXRate = await prisma.fXRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FXRateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FXRateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FXRateClient<$Result.GetResult<Prisma.$FXRatePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FXRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FXRateFindFirstArgs} args - Arguments to find a FXRate
     * @example
     * // Get one FXRate
     * const fXRate = await prisma.fXRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FXRateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FXRateFindFirstArgs<ExtArgs>>
    ): Prisma__FXRateClient<$Result.GetResult<Prisma.$FXRatePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FXRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FXRateFindFirstOrThrowArgs} args - Arguments to find a FXRate
     * @example
     * // Get one FXRate
     * const fXRate = await prisma.fXRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FXRateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FXRateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FXRateClient<$Result.GetResult<Prisma.$FXRatePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FXRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FXRateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FXRates
     * const fXRates = await prisma.fXRate.findMany()
     * 
     * // Get first 10 FXRates
     * const fXRates = await prisma.fXRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fXRateWithIdOnly = await prisma.fXRate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FXRateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FXRateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FXRatePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FXRate.
     * @param {FXRateCreateArgs} args - Arguments to create a FXRate.
     * @example
     * // Create one FXRate
     * const FXRate = await prisma.fXRate.create({
     *   data: {
     *     // ... data to create a FXRate
     *   }
     * })
     * 
    **/
    create<T extends FXRateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FXRateCreateArgs<ExtArgs>>
    ): Prisma__FXRateClient<$Result.GetResult<Prisma.$FXRatePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a FXRate.
     * @param {FXRateDeleteArgs} args - Arguments to delete one FXRate.
     * @example
     * // Delete one FXRate
     * const FXRate = await prisma.fXRate.delete({
     *   where: {
     *     // ... filter to delete one FXRate
     *   }
     * })
     * 
    **/
    delete<T extends FXRateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FXRateDeleteArgs<ExtArgs>>
    ): Prisma__FXRateClient<$Result.GetResult<Prisma.$FXRatePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FXRate.
     * @param {FXRateUpdateArgs} args - Arguments to update one FXRate.
     * @example
     * // Update one FXRate
     * const fXRate = await prisma.fXRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FXRateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FXRateUpdateArgs<ExtArgs>>
    ): Prisma__FXRateClient<$Result.GetResult<Prisma.$FXRatePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FXRates.
     * @param {FXRateDeleteManyArgs} args - Arguments to filter FXRates to delete.
     * @example
     * // Delete a few FXRates
     * const { count } = await prisma.fXRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FXRateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FXRateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FXRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FXRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FXRates
     * const fXRate = await prisma.fXRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FXRateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FXRateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FXRate.
     * @param {FXRateUpsertArgs} args - Arguments to update or create a FXRate.
     * @example
     * // Update or create a FXRate
     * const fXRate = await prisma.fXRate.upsert({
     *   create: {
     *     // ... data to create a FXRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FXRate we want to update
     *   }
     * })
    **/
    upsert<T extends FXRateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FXRateUpsertArgs<ExtArgs>>
    ): Prisma__FXRateClient<$Result.GetResult<Prisma.$FXRatePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FXRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FXRateCountArgs} args - Arguments to filter FXRates to count.
     * @example
     * // Count the number of FXRates
     * const count = await prisma.fXRate.count({
     *   where: {
     *     // ... the filter for the FXRates we want to count
     *   }
     * })
    **/
    count<T extends FXRateCountArgs>(
      args?: Subset<T, FXRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FXRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FXRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FXRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FXRateAggregateArgs>(args: Subset<T, FXRateAggregateArgs>): Prisma.PrismaPromise<GetFXRateAggregateType<T>>

    /**
     * Group by FXRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FXRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FXRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FXRateGroupByArgs['orderBy'] }
        : { orderBy?: FXRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FXRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFXRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FXRate model
   */
  readonly fields: FXRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FXRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FXRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FXRate model
   */ 
  interface FXRateFieldRefs {
    readonly id: FieldRef<"FXRate", 'String'>
    readonly from_currency: FieldRef<"FXRate", 'String'>
    readonly to_currency: FieldRef<"FXRate", 'String'>
    readonly rate: FieldRef<"FXRate", 'Float'>
    readonly date: FieldRef<"FXRate", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * FXRate findUnique
   */
  export type FXRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FXRate
     */
    select?: FXRateSelect<ExtArgs> | null
    /**
     * Filter, which FXRate to fetch.
     */
    where: FXRateWhereUniqueInput
  }


  /**
   * FXRate findUniqueOrThrow
   */
  export type FXRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FXRate
     */
    select?: FXRateSelect<ExtArgs> | null
    /**
     * Filter, which FXRate to fetch.
     */
    where: FXRateWhereUniqueInput
  }


  /**
   * FXRate findFirst
   */
  export type FXRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FXRate
     */
    select?: FXRateSelect<ExtArgs> | null
    /**
     * Filter, which FXRate to fetch.
     */
    where?: FXRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FXRates to fetch.
     */
    orderBy?: FXRateOrderByWithRelationInput | FXRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FXRates.
     */
    cursor?: FXRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FXRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FXRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FXRates.
     */
    distinct?: FXRateScalarFieldEnum | FXRateScalarFieldEnum[]
  }


  /**
   * FXRate findFirstOrThrow
   */
  export type FXRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FXRate
     */
    select?: FXRateSelect<ExtArgs> | null
    /**
     * Filter, which FXRate to fetch.
     */
    where?: FXRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FXRates to fetch.
     */
    orderBy?: FXRateOrderByWithRelationInput | FXRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FXRates.
     */
    cursor?: FXRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FXRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FXRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FXRates.
     */
    distinct?: FXRateScalarFieldEnum | FXRateScalarFieldEnum[]
  }


  /**
   * FXRate findMany
   */
  export type FXRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FXRate
     */
    select?: FXRateSelect<ExtArgs> | null
    /**
     * Filter, which FXRates to fetch.
     */
    where?: FXRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FXRates to fetch.
     */
    orderBy?: FXRateOrderByWithRelationInput | FXRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FXRates.
     */
    cursor?: FXRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FXRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FXRates.
     */
    skip?: number
    distinct?: FXRateScalarFieldEnum | FXRateScalarFieldEnum[]
  }


  /**
   * FXRate create
   */
  export type FXRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FXRate
     */
    select?: FXRateSelect<ExtArgs> | null
    /**
     * The data needed to create a FXRate.
     */
    data: XOR<FXRateCreateInput, FXRateUncheckedCreateInput>
  }


  /**
   * FXRate update
   */
  export type FXRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FXRate
     */
    select?: FXRateSelect<ExtArgs> | null
    /**
     * The data needed to update a FXRate.
     */
    data: XOR<FXRateUpdateInput, FXRateUncheckedUpdateInput>
    /**
     * Choose, which FXRate to update.
     */
    where: FXRateWhereUniqueInput
  }


  /**
   * FXRate updateMany
   */
  export type FXRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FXRates.
     */
    data: XOR<FXRateUpdateManyMutationInput, FXRateUncheckedUpdateManyInput>
    /**
     * Filter which FXRates to update
     */
    where?: FXRateWhereInput
  }


  /**
   * FXRate upsert
   */
  export type FXRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FXRate
     */
    select?: FXRateSelect<ExtArgs> | null
    /**
     * The filter to search for the FXRate to update in case it exists.
     */
    where: FXRateWhereUniqueInput
    /**
     * In case the FXRate found by the `where` argument doesn't exist, create a new FXRate with this data.
     */
    create: XOR<FXRateCreateInput, FXRateUncheckedCreateInput>
    /**
     * In case the FXRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FXRateUpdateInput, FXRateUncheckedUpdateInput>
  }


  /**
   * FXRate delete
   */
  export type FXRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FXRate
     */
    select?: FXRateSelect<ExtArgs> | null
    /**
     * Filter which FXRate to delete.
     */
    where: FXRateWhereUniqueInput
  }


  /**
   * FXRate deleteMany
   */
  export type FXRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FXRates to delete
     */
    where?: FXRateWhereInput
  }


  /**
   * FXRate without action
   */
  export type FXRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FXRate
     */
    select?: FXRateSelect<ExtArgs> | null
  }



  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    entity_type: string | null
    entity_id: string | null
    action: string | null
    changes: string | null
    user_id: string | null
    created_at: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    entity_type: string | null
    entity_id: string | null
    action: string | null
    changes: string | null
    user_id: string | null
    created_at: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    entity_type: number
    entity_id: number
    action: number
    changes: number
    user_id: number
    created_at: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    entity_type?: true
    entity_id?: true
    action?: true
    changes?: true
    user_id?: true
    created_at?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    entity_type?: true
    entity_id?: true
    action?: true
    changes?: true
    user_id?: true
    created_at?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    entity_type?: true
    entity_id?: true
    action?: true
    changes?: true
    user_id?: true
    created_at?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    entity_type: string
    entity_id: string
    action: string
    changes: string
    user_id: string | null
    created_at: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity_type?: boolean
    entity_id?: boolean
    action?: boolean
    changes?: boolean
    user_id?: boolean
    created_at?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    entity_type?: boolean
    entity_id?: boolean
    action?: boolean
    changes?: boolean
    user_id?: boolean
    created_at?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entity_type: string
      entity_id: string
      action: string
      changes: string
      user_id: string | null
      created_at: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }


  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuditLogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuditLogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AuditLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
    **/
    create<T extends AuditLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
    **/
    delete<T extends AuditLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuditLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuditLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuditLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
    **/
    upsert<T extends AuditLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly entity_type: FieldRef<"AuditLog", 'String'>
    readonly entity_id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'String'>
    readonly user_id: FieldRef<"AuditLog", 'String'>
    readonly created_at: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }


  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }


  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }


  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }


  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }


  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }


  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }


  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }


  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }


  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }


  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }


  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
  }



  /**
   * Model NotificationLog
   */

  export type AggregateNotificationLog = {
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  export type NotificationLogMinAggregateOutputType = {
    id: string | null
    type: string | null
    recipient: string | null
    payload: string | null
    status: string | null
    created_at: Date | null
  }

  export type NotificationLogMaxAggregateOutputType = {
    id: string | null
    type: string | null
    recipient: string | null
    payload: string | null
    status: string | null
    created_at: Date | null
  }

  export type NotificationLogCountAggregateOutputType = {
    id: number
    type: number
    recipient: number
    payload: number
    status: number
    created_at: number
    _all: number
  }


  export type NotificationLogMinAggregateInputType = {
    id?: true
    type?: true
    recipient?: true
    payload?: true
    status?: true
    created_at?: true
  }

  export type NotificationLogMaxAggregateInputType = {
    id?: true
    type?: true
    recipient?: true
    payload?: true
    status?: true
    created_at?: true
  }

  export type NotificationLogCountAggregateInputType = {
    id?: true
    type?: true
    recipient?: true
    payload?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type NotificationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLog to aggregate.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationLogs
    **/
    _count?: true | NotificationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationLogMaxAggregateInputType
  }

  export type GetNotificationLogAggregateType<T extends NotificationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationLog[P]>
      : GetScalarType<T[P], AggregateNotificationLog[P]>
  }




  export type NotificationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithAggregationInput | NotificationLogOrderByWithAggregationInput[]
    by: NotificationLogScalarFieldEnum[] | NotificationLogScalarFieldEnum
    having?: NotificationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationLogCountAggregateInputType | true
    _min?: NotificationLogMinAggregateInputType
    _max?: NotificationLogMaxAggregateInputType
  }

  export type NotificationLogGroupByOutputType = {
    id: string
    type: string
    recipient: string
    payload: string
    status: string
    created_at: Date
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  type GetNotificationLogGroupByPayload<T extends NotificationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
        }
      >
    >


  export type NotificationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    recipient?: boolean
    payload?: boolean
    status?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectScalar = {
    id?: boolean
    type?: boolean
    recipient?: boolean
    payload?: boolean
    status?: boolean
    created_at?: boolean
  }


  export type $NotificationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      recipient: string
      payload: string
      status: string
      created_at: Date
    }, ExtArgs["result"]["notificationLog"]>
    composites: {}
  }


  type NotificationLogGetPayload<S extends boolean | null | undefined | NotificationLogDefaultArgs> = $Result.GetResult<Prisma.$NotificationLogPayload, S>

  type NotificationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationLogCountAggregateInputType | true
    }

  export interface NotificationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationLog'], meta: { name: 'NotificationLog' } }
    /**
     * Find zero or one NotificationLog that matches the filter.
     * @param {NotificationLogFindUniqueArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationLogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationLogFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one NotificationLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationLogFindUniqueOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first NotificationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationLogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationLogFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first NotificationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more NotificationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany()
     * 
     * // Get first 10 NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a NotificationLog.
     * @param {NotificationLogCreateArgs} args - Arguments to create a NotificationLog.
     * @example
     * // Create one NotificationLog
     * const NotificationLog = await prisma.notificationLog.create({
     *   data: {
     *     // ... data to create a NotificationLog
     *   }
     * })
     * 
    **/
    create<T extends NotificationLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationLogCreateArgs<ExtArgs>>
    ): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Delete a NotificationLog.
     * @param {NotificationLogDeleteArgs} args - Arguments to delete one NotificationLog.
     * @example
     * // Delete one NotificationLog
     * const NotificationLog = await prisma.notificationLog.delete({
     *   where: {
     *     // ... filter to delete one NotificationLog
     *   }
     * })
     * 
    **/
    delete<T extends NotificationLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationLogDeleteArgs<ExtArgs>>
    ): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one NotificationLog.
     * @param {NotificationLogUpdateArgs} args - Arguments to update one NotificationLog.
     * @example
     * // Update one NotificationLog
     * const notificationLog = await prisma.notificationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationLogUpdateArgs<ExtArgs>>
    ): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more NotificationLogs.
     * @param {NotificationLogDeleteManyArgs} args - Arguments to filter NotificationLogs to delete.
     * @example
     * // Delete a few NotificationLogs
     * const { count } = await prisma.notificationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationLog.
     * @param {NotificationLogUpsertArgs} args - Arguments to update or create a NotificationLog.
     * @example
     * // Update or create a NotificationLog
     * const notificationLog = await prisma.notificationLog.upsert({
     *   create: {
     *     // ... data to create a NotificationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationLog we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationLogUpsertArgs<ExtArgs>>
    ): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogCountArgs} args - Arguments to filter NotificationLogs to count.
     * @example
     * // Count the number of NotificationLogs
     * const count = await prisma.notificationLog.count({
     *   where: {
     *     // ... the filter for the NotificationLogs we want to count
     *   }
     * })
    **/
    count<T extends NotificationLogCountArgs>(
      args?: Subset<T, NotificationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationLogAggregateArgs>(args: Subset<T, NotificationLogAggregateArgs>): Prisma.PrismaPromise<GetNotificationLogAggregateType<T>>

    /**
     * Group by NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationLogGroupByArgs['orderBy'] }
        : { orderBy?: NotificationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationLog model
   */
  readonly fields: NotificationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the NotificationLog model
   */ 
  interface NotificationLogFieldRefs {
    readonly id: FieldRef<"NotificationLog", 'String'>
    readonly type: FieldRef<"NotificationLog", 'String'>
    readonly recipient: FieldRef<"NotificationLog", 'String'>
    readonly payload: FieldRef<"NotificationLog", 'String'>
    readonly status: FieldRef<"NotificationLog", 'String'>
    readonly created_at: FieldRef<"NotificationLog", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * NotificationLog findUnique
   */
  export type NotificationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }


  /**
   * NotificationLog findUniqueOrThrow
   */
  export type NotificationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }


  /**
   * NotificationLog findFirst
   */
  export type NotificationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }


  /**
   * NotificationLog findFirstOrThrow
   */
  export type NotificationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }


  /**
   * NotificationLog findMany
   */
  export type NotificationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLogs to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }


  /**
   * NotificationLog create
   */
  export type NotificationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * The data needed to create a NotificationLog.
     */
    data: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
  }


  /**
   * NotificationLog update
   */
  export type NotificationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * The data needed to update a NotificationLog.
     */
    data: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
    /**
     * Choose, which NotificationLog to update.
     */
    where: NotificationLogWhereUniqueInput
  }


  /**
   * NotificationLog updateMany
   */
  export type NotificationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
  }


  /**
   * NotificationLog upsert
   */
  export type NotificationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * The filter to search for the NotificationLog to update in case it exists.
     */
    where: NotificationLogWhereUniqueInput
    /**
     * In case the NotificationLog found by the `where` argument doesn't exist, create a new NotificationLog with this data.
     */
    create: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
    /**
     * In case the NotificationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
  }


  /**
   * NotificationLog delete
   */
  export type NotificationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter which NotificationLog to delete.
     */
    where: NotificationLogWhereUniqueInput
  }


  /**
   * NotificationLog deleteMany
   */
  export type NotificationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLogs to delete
     */
    where?: NotificationLogWhereInput
  }


  /**
   * NotificationLog without action
   */
  export type NotificationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password_hash: 'password_hash',
    role: 'role',
    created_at: 'created_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const StoreScalarFieldEnum: {
    id: 'id',
    name: 'name',
    country: 'country',
    city: 'city',
    address: 'address',
    timezone: 'timezone',
    status: 'status',
    planned_open_date: 'planned_open_date',
    actual_open_date: 'actual_open_date',
    contract_signed_date: 'contract_signed_date',
    template_version: 'template_version',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const TemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    version: 'version',
    is_active: 'is_active',
    created_at: 'created_at'
  };

  export type TemplateScalarFieldEnum = (typeof TemplateScalarFieldEnum)[keyof typeof TemplateScalarFieldEnum]


  export const TemplatePhaseScalarFieldEnum: {
    id: 'id',
    template_id: 'template_id',
    name: 'name',
    order: 'order'
  };

  export type TemplatePhaseScalarFieldEnum = (typeof TemplatePhaseScalarFieldEnum)[keyof typeof TemplatePhaseScalarFieldEnum]


  export const TemplateTaskScalarFieldEnum: {
    id: 'id',
    phase_id: 'phase_id',
    name: 'name',
    description: 'description',
    role_responsible: 'role_responsible',
    duration_days: 'duration_days',
    anchor_event: 'anchor_event',
    offset_days: 'offset_days',
    workday_rule: 'workday_rule',
    is_milestone: 'is_milestone',
    dependency_indices: 'dependency_indices'
  };

  export type TemplateTaskScalarFieldEnum = (typeof TemplateTaskScalarFieldEnum)[keyof typeof TemplateTaskScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    title: 'title',
    description: 'description',
    phase: 'phase',
    status: 'status',
    priority: 'priority',
    start_date: 'start_date',
    due_date: 'due_date',
    completed_at: 'completed_at',
    role: 'role',
    manual_override: 'manual_override',
    locked: 'locked',
    reschedule_mode: 'reschedule_mode',
    calendar_rule: 'calendar_rule',
    anchor: 'anchor',
    owner_id: 'owner_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskDependencyScalarFieldEnum: {
    task_id: 'task_id',
    depends_on_id: 'depends_on_id'
  };

  export type TaskDependencyScalarFieldEnum = (typeof TaskDependencyScalarFieldEnum)[keyof typeof TaskDependencyScalarFieldEnum]


  export const MilestoneScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    name: 'name',
    type: 'type',
    date: 'date',
    status: 'status'
  };

  export type MilestoneScalarFieldEnum = (typeof MilestoneScalarFieldEnum)[keyof typeof MilestoneScalarFieldEnum]


  export const IssueScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    title: 'title',
    severity: 'severity',
    status: 'status',
    mitigation: 'mitigation'
  };

  export type IssueScalarFieldEnum = (typeof IssueScalarFieldEnum)[keyof typeof IssueScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    name: 'name',
    url: 'url',
    type: 'type'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const IngredientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    unit_type: 'unit_type',
    category: 'category'
  };

  export type IngredientScalarFieldEnum = (typeof IngredientScalarFieldEnum)[keyof typeof IngredientScalarFieldEnum]


  export const GroceryPriceScalarFieldEnum: {
    id: 'id',
    country: 'country',
    retailer: 'retailer',
    ingredient_id: 'ingredient_id',
    package_size: 'package_size',
    package_unit: 'package_unit',
    price: 'price',
    currency: 'currency',
    normalized_price_per_unit: 'normalized_price_per_unit',
    as_of: 'as_of',
    source_url: 'source_url'
  };

  export type GroceryPriceScalarFieldEnum = (typeof GroceryPriceScalarFieldEnum)[keyof typeof GroceryPriceScalarFieldEnum]


  export const PriceHistoryScalarFieldEnum: {
    id: 'id',
    grocery_price_id: 'grocery_price_id',
    price: 'price',
    changed_at: 'changed_at',
    changed_by: 'changed_by',
    reason: 'reason'
  };

  export type PriceHistoryScalarFieldEnum = (typeof PriceHistoryScalarFieldEnum)[keyof typeof PriceHistoryScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    menu_item: 'menu_item',
    version: 'version',
    country: 'country',
    yield_count: 'yield_count',
    target_cost_pct: 'target_cost_pct',
    manual_price: 'manual_price',
    created_at: 'created_at'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const RecipeLineScalarFieldEnum: {
    id: 'id',
    recipe_id: 'recipe_id',
    ingredient_id: 'ingredient_id',
    quantity: 'quantity',
    unit: 'unit'
  };

  export type RecipeLineScalarFieldEnum = (typeof RecipeLineScalarFieldEnum)[keyof typeof RecipeLineScalarFieldEnum]


  export const CompetitorPriceScalarFieldEnum: {
    id: 'id',
    country: 'country',
    brand: 'brand',
    menu_item: 'menu_item',
    price: 'price',
    currency: 'currency',
    as_of: 'as_of'
  };

  export type CompetitorPriceScalarFieldEnum = (typeof CompetitorPriceScalarFieldEnum)[keyof typeof CompetitorPriceScalarFieldEnum]


  export const FXRateScalarFieldEnum: {
    id: 'id',
    from_currency: 'from_currency',
    to_currency: 'to_currency',
    rate: 'rate',
    date: 'date'
  };

  export type FXRateScalarFieldEnum = (typeof FXRateScalarFieldEnum)[keyof typeof FXRateScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    entity_type: 'entity_type',
    entity_id: 'entity_id',
    action: 'action',
    changes: 'changes',
    user_id: 'user_id',
    created_at: 'created_at'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const NotificationLogScalarFieldEnum: {
    id: 'id',
    type: 'type',
    recipient: 'recipient',
    payload: 'payload',
    status: 'status',
    created_at: 'created_at'
  };

  export type NotificationLogScalarFieldEnum = (typeof NotificationLogScalarFieldEnum)[keyof typeof NotificationLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    password_hash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    created_at?: DateTimeFilter<"User"> | Date | string
    tasks_owned?: TaskListRelationFilter
    tasks_collaborating?: TaskListRelationFilter
    audit_logs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    tasks_owned?: TaskOrderByRelationAggregateInput
    tasks_collaborating?: TaskOrderByRelationAggregateInput
    audit_logs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password_hash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    created_at?: DateTimeFilter<"User"> | Date | string
    tasks_owned?: TaskListRelationFilter
    tasks_collaborating?: TaskListRelationFilter
    audit_logs?: AuditLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    password_hash?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type StoreWhereInput = {
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    id?: StringFilter<"Store"> | string
    name?: StringFilter<"Store"> | string
    country?: StringFilter<"Store"> | string
    city?: StringFilter<"Store"> | string
    address?: StringNullableFilter<"Store"> | string | null
    timezone?: StringFilter<"Store"> | string
    status?: StringFilter<"Store"> | string
    planned_open_date?: DateTimeNullableFilter<"Store"> | Date | string | null
    actual_open_date?: DateTimeNullableFilter<"Store"> | Date | string | null
    contract_signed_date?: DateTimeNullableFilter<"Store"> | Date | string | null
    template_version?: StringFilter<"Store"> | string
    created_at?: DateTimeFilter<"Store"> | Date | string
    updated_at?: DateTimeFilter<"Store"> | Date | string
    tasks?: TaskListRelationFilter
    milestones?: MilestoneListRelationFilter
    issues?: IssueListRelationFilter
    documents?: DocumentListRelationFilter
  }

  export type StoreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    city?: SortOrder
    address?: SortOrderInput | SortOrder
    timezone?: SortOrder
    status?: SortOrder
    planned_open_date?: SortOrderInput | SortOrder
    actual_open_date?: SortOrderInput | SortOrder
    contract_signed_date?: SortOrderInput | SortOrder
    template_version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tasks?: TaskOrderByRelationAggregateInput
    milestones?: MilestoneOrderByRelationAggregateInput
    issues?: IssueOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
  }

  export type StoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    name?: StringFilter<"Store"> | string
    country?: StringFilter<"Store"> | string
    city?: StringFilter<"Store"> | string
    address?: StringNullableFilter<"Store"> | string | null
    timezone?: StringFilter<"Store"> | string
    status?: StringFilter<"Store"> | string
    planned_open_date?: DateTimeNullableFilter<"Store"> | Date | string | null
    actual_open_date?: DateTimeNullableFilter<"Store"> | Date | string | null
    contract_signed_date?: DateTimeNullableFilter<"Store"> | Date | string | null
    template_version?: StringFilter<"Store"> | string
    created_at?: DateTimeFilter<"Store"> | Date | string
    updated_at?: DateTimeFilter<"Store"> | Date | string
    tasks?: TaskListRelationFilter
    milestones?: MilestoneListRelationFilter
    issues?: IssueListRelationFilter
    documents?: DocumentListRelationFilter
  }, "id">

  export type StoreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    city?: SortOrder
    address?: SortOrderInput | SortOrder
    timezone?: SortOrder
    status?: SortOrder
    planned_open_date?: SortOrderInput | SortOrder
    actual_open_date?: SortOrderInput | SortOrder
    contract_signed_date?: SortOrderInput | SortOrder
    template_version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: StoreCountOrderByAggregateInput
    _max?: StoreMaxOrderByAggregateInput
    _min?: StoreMinOrderByAggregateInput
  }

  export type StoreScalarWhereWithAggregatesInput = {
    AND?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    OR?: StoreScalarWhereWithAggregatesInput[]
    NOT?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Store"> | string
    name?: StringWithAggregatesFilter<"Store"> | string
    country?: StringWithAggregatesFilter<"Store"> | string
    city?: StringWithAggregatesFilter<"Store"> | string
    address?: StringNullableWithAggregatesFilter<"Store"> | string | null
    timezone?: StringWithAggregatesFilter<"Store"> | string
    status?: StringWithAggregatesFilter<"Store"> | string
    planned_open_date?: DateTimeNullableWithAggregatesFilter<"Store"> | Date | string | null
    actual_open_date?: DateTimeNullableWithAggregatesFilter<"Store"> | Date | string | null
    contract_signed_date?: DateTimeNullableWithAggregatesFilter<"Store"> | Date | string | null
    template_version?: StringWithAggregatesFilter<"Store"> | string
    created_at?: DateTimeWithAggregatesFilter<"Store"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Store"> | Date | string
  }

  export type TemplateWhereInput = {
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    id?: StringFilter<"Template"> | string
    name?: StringFilter<"Template"> | string
    version?: StringFilter<"Template"> | string
    is_active?: BoolFilter<"Template"> | boolean
    created_at?: DateTimeFilter<"Template"> | Date | string
    phases?: TemplatePhaseListRelationFilter
  }

  export type TemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    phases?: TemplatePhaseOrderByRelationAggregateInput
  }

  export type TemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    name?: StringFilter<"Template"> | string
    version?: StringFilter<"Template"> | string
    is_active?: BoolFilter<"Template"> | boolean
    created_at?: DateTimeFilter<"Template"> | Date | string
    phases?: TemplatePhaseListRelationFilter
  }, "id">

  export type TemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    _count?: TemplateCountOrderByAggregateInput
    _max?: TemplateMaxOrderByAggregateInput
    _min?: TemplateMinOrderByAggregateInput
  }

  export type TemplateScalarWhereWithAggregatesInput = {
    AND?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    OR?: TemplateScalarWhereWithAggregatesInput[]
    NOT?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Template"> | string
    name?: StringWithAggregatesFilter<"Template"> | string
    version?: StringWithAggregatesFilter<"Template"> | string
    is_active?: BoolWithAggregatesFilter<"Template"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Template"> | Date | string
  }

  export type TemplatePhaseWhereInput = {
    AND?: TemplatePhaseWhereInput | TemplatePhaseWhereInput[]
    OR?: TemplatePhaseWhereInput[]
    NOT?: TemplatePhaseWhereInput | TemplatePhaseWhereInput[]
    id?: StringFilter<"TemplatePhase"> | string
    template_id?: StringFilter<"TemplatePhase"> | string
    name?: StringFilter<"TemplatePhase"> | string
    order?: IntFilter<"TemplatePhase"> | number
    template?: XOR<TemplateRelationFilter, TemplateWhereInput>
    tasks?: TemplateTaskListRelationFilter
  }

  export type TemplatePhaseOrderByWithRelationInput = {
    id?: SortOrder
    template_id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    template?: TemplateOrderByWithRelationInput
    tasks?: TemplateTaskOrderByRelationAggregateInput
  }

  export type TemplatePhaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TemplatePhaseWhereInput | TemplatePhaseWhereInput[]
    OR?: TemplatePhaseWhereInput[]
    NOT?: TemplatePhaseWhereInput | TemplatePhaseWhereInput[]
    template_id?: StringFilter<"TemplatePhase"> | string
    name?: StringFilter<"TemplatePhase"> | string
    order?: IntFilter<"TemplatePhase"> | number
    template?: XOR<TemplateRelationFilter, TemplateWhereInput>
    tasks?: TemplateTaskListRelationFilter
  }, "id">

  export type TemplatePhaseOrderByWithAggregationInput = {
    id?: SortOrder
    template_id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    _count?: TemplatePhaseCountOrderByAggregateInput
    _avg?: TemplatePhaseAvgOrderByAggregateInput
    _max?: TemplatePhaseMaxOrderByAggregateInput
    _min?: TemplatePhaseMinOrderByAggregateInput
    _sum?: TemplatePhaseSumOrderByAggregateInput
  }

  export type TemplatePhaseScalarWhereWithAggregatesInput = {
    AND?: TemplatePhaseScalarWhereWithAggregatesInput | TemplatePhaseScalarWhereWithAggregatesInput[]
    OR?: TemplatePhaseScalarWhereWithAggregatesInput[]
    NOT?: TemplatePhaseScalarWhereWithAggregatesInput | TemplatePhaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TemplatePhase"> | string
    template_id?: StringWithAggregatesFilter<"TemplatePhase"> | string
    name?: StringWithAggregatesFilter<"TemplatePhase"> | string
    order?: IntWithAggregatesFilter<"TemplatePhase"> | number
  }

  export type TemplateTaskWhereInput = {
    AND?: TemplateTaskWhereInput | TemplateTaskWhereInput[]
    OR?: TemplateTaskWhereInput[]
    NOT?: TemplateTaskWhereInput | TemplateTaskWhereInput[]
    id?: StringFilter<"TemplateTask"> | string
    phase_id?: StringFilter<"TemplateTask"> | string
    name?: StringFilter<"TemplateTask"> | string
    description?: StringNullableFilter<"TemplateTask"> | string | null
    role_responsible?: StringFilter<"TemplateTask"> | string
    duration_days?: IntFilter<"TemplateTask"> | number
    anchor_event?: StringFilter<"TemplateTask"> | string
    offset_days?: IntFilter<"TemplateTask"> | number
    workday_rule?: StringFilter<"TemplateTask"> | string
    is_milestone?: BoolFilter<"TemplateTask"> | boolean
    dependency_indices?: StringNullableFilter<"TemplateTask"> | string | null
    phase?: XOR<TemplatePhaseRelationFilter, TemplatePhaseWhereInput>
  }

  export type TemplateTaskOrderByWithRelationInput = {
    id?: SortOrder
    phase_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    role_responsible?: SortOrder
    duration_days?: SortOrder
    anchor_event?: SortOrder
    offset_days?: SortOrder
    workday_rule?: SortOrder
    is_milestone?: SortOrder
    dependency_indices?: SortOrderInput | SortOrder
    phase?: TemplatePhaseOrderByWithRelationInput
  }

  export type TemplateTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TemplateTaskWhereInput | TemplateTaskWhereInput[]
    OR?: TemplateTaskWhereInput[]
    NOT?: TemplateTaskWhereInput | TemplateTaskWhereInput[]
    phase_id?: StringFilter<"TemplateTask"> | string
    name?: StringFilter<"TemplateTask"> | string
    description?: StringNullableFilter<"TemplateTask"> | string | null
    role_responsible?: StringFilter<"TemplateTask"> | string
    duration_days?: IntFilter<"TemplateTask"> | number
    anchor_event?: StringFilter<"TemplateTask"> | string
    offset_days?: IntFilter<"TemplateTask"> | number
    workday_rule?: StringFilter<"TemplateTask"> | string
    is_milestone?: BoolFilter<"TemplateTask"> | boolean
    dependency_indices?: StringNullableFilter<"TemplateTask"> | string | null
    phase?: XOR<TemplatePhaseRelationFilter, TemplatePhaseWhereInput>
  }, "id">

  export type TemplateTaskOrderByWithAggregationInput = {
    id?: SortOrder
    phase_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    role_responsible?: SortOrder
    duration_days?: SortOrder
    anchor_event?: SortOrder
    offset_days?: SortOrder
    workday_rule?: SortOrder
    is_milestone?: SortOrder
    dependency_indices?: SortOrderInput | SortOrder
    _count?: TemplateTaskCountOrderByAggregateInput
    _avg?: TemplateTaskAvgOrderByAggregateInput
    _max?: TemplateTaskMaxOrderByAggregateInput
    _min?: TemplateTaskMinOrderByAggregateInput
    _sum?: TemplateTaskSumOrderByAggregateInput
  }

  export type TemplateTaskScalarWhereWithAggregatesInput = {
    AND?: TemplateTaskScalarWhereWithAggregatesInput | TemplateTaskScalarWhereWithAggregatesInput[]
    OR?: TemplateTaskScalarWhereWithAggregatesInput[]
    NOT?: TemplateTaskScalarWhereWithAggregatesInput | TemplateTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TemplateTask"> | string
    phase_id?: StringWithAggregatesFilter<"TemplateTask"> | string
    name?: StringWithAggregatesFilter<"TemplateTask"> | string
    description?: StringNullableWithAggregatesFilter<"TemplateTask"> | string | null
    role_responsible?: StringWithAggregatesFilter<"TemplateTask"> | string
    duration_days?: IntWithAggregatesFilter<"TemplateTask"> | number
    anchor_event?: StringWithAggregatesFilter<"TemplateTask"> | string
    offset_days?: IntWithAggregatesFilter<"TemplateTask"> | number
    workday_rule?: StringWithAggregatesFilter<"TemplateTask"> | string
    is_milestone?: BoolWithAggregatesFilter<"TemplateTask"> | boolean
    dependency_indices?: StringNullableWithAggregatesFilter<"TemplateTask"> | string | null
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    store_id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    phase?: StringFilter<"Task"> | string
    status?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    start_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    due_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"Task"> | Date | string | null
    role?: StringNullableFilter<"Task"> | string | null
    manual_override?: BoolFilter<"Task"> | boolean
    locked?: BoolFilter<"Task"> | boolean
    reschedule_mode?: StringFilter<"Task"> | string
    calendar_rule?: StringFilter<"Task"> | string
    anchor?: StringNullableFilter<"Task"> | string | null
    owner_id?: StringNullableFilter<"Task"> | string | null
    created_at?: DateTimeFilter<"Task"> | Date | string
    updated_at?: DateTimeFilter<"Task"> | Date | string
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    dependencies?: TaskDependencyListRelationFilter
    dependents?: TaskDependencyListRelationFilter
    collaborators?: UserListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    phase?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    start_date?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    manual_override?: SortOrder
    locked?: SortOrder
    reschedule_mode?: SortOrder
    calendar_rule?: SortOrder
    anchor?: SortOrderInput | SortOrder
    owner_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    owner?: UserOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
    dependencies?: TaskDependencyOrderByRelationAggregateInput
    dependents?: TaskDependencyOrderByRelationAggregateInput
    collaborators?: UserOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    store_id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    phase?: StringFilter<"Task"> | string
    status?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    start_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    due_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"Task"> | Date | string | null
    role?: StringNullableFilter<"Task"> | string | null
    manual_override?: BoolFilter<"Task"> | boolean
    locked?: BoolFilter<"Task"> | boolean
    reschedule_mode?: StringFilter<"Task"> | string
    calendar_rule?: StringFilter<"Task"> | string
    anchor?: StringNullableFilter<"Task"> | string | null
    owner_id?: StringNullableFilter<"Task"> | string | null
    created_at?: DateTimeFilter<"Task"> | Date | string
    updated_at?: DateTimeFilter<"Task"> | Date | string
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    dependencies?: TaskDependencyListRelationFilter
    dependents?: TaskDependencyListRelationFilter
    collaborators?: UserListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    phase?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    start_date?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    manual_override?: SortOrder
    locked?: SortOrder
    reschedule_mode?: SortOrder
    calendar_rule?: SortOrder
    anchor?: SortOrderInput | SortOrder
    owner_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    store_id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    phase?: StringWithAggregatesFilter<"Task"> | string
    status?: StringWithAggregatesFilter<"Task"> | string
    priority?: StringWithAggregatesFilter<"Task"> | string
    start_date?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    due_date?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    role?: StringNullableWithAggregatesFilter<"Task"> | string | null
    manual_override?: BoolWithAggregatesFilter<"Task"> | boolean
    locked?: BoolWithAggregatesFilter<"Task"> | boolean
    reschedule_mode?: StringWithAggregatesFilter<"Task"> | string
    calendar_rule?: StringWithAggregatesFilter<"Task"> | string
    anchor?: StringNullableWithAggregatesFilter<"Task"> | string | null
    owner_id?: StringNullableWithAggregatesFilter<"Task"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type TaskDependencyWhereInput = {
    AND?: TaskDependencyWhereInput | TaskDependencyWhereInput[]
    OR?: TaskDependencyWhereInput[]
    NOT?: TaskDependencyWhereInput | TaskDependencyWhereInput[]
    task_id?: StringFilter<"TaskDependency"> | string
    depends_on_id?: StringFilter<"TaskDependency"> | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    depends_on?: XOR<TaskRelationFilter, TaskWhereInput>
  }

  export type TaskDependencyOrderByWithRelationInput = {
    task_id?: SortOrder
    depends_on_id?: SortOrder
    task?: TaskOrderByWithRelationInput
    depends_on?: TaskOrderByWithRelationInput
  }

  export type TaskDependencyWhereUniqueInput = Prisma.AtLeast<{
    task_id_depends_on_id?: TaskDependencyTask_idDepends_on_idCompoundUniqueInput
    AND?: TaskDependencyWhereInput | TaskDependencyWhereInput[]
    OR?: TaskDependencyWhereInput[]
    NOT?: TaskDependencyWhereInput | TaskDependencyWhereInput[]
    task_id?: StringFilter<"TaskDependency"> | string
    depends_on_id?: StringFilter<"TaskDependency"> | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    depends_on?: XOR<TaskRelationFilter, TaskWhereInput>
  }, "task_id_depends_on_id">

  export type TaskDependencyOrderByWithAggregationInput = {
    task_id?: SortOrder
    depends_on_id?: SortOrder
    _count?: TaskDependencyCountOrderByAggregateInput
    _max?: TaskDependencyMaxOrderByAggregateInput
    _min?: TaskDependencyMinOrderByAggregateInput
  }

  export type TaskDependencyScalarWhereWithAggregatesInput = {
    AND?: TaskDependencyScalarWhereWithAggregatesInput | TaskDependencyScalarWhereWithAggregatesInput[]
    OR?: TaskDependencyScalarWhereWithAggregatesInput[]
    NOT?: TaskDependencyScalarWhereWithAggregatesInput | TaskDependencyScalarWhereWithAggregatesInput[]
    task_id?: StringWithAggregatesFilter<"TaskDependency"> | string
    depends_on_id?: StringWithAggregatesFilter<"TaskDependency"> | string
  }

  export type MilestoneWhereInput = {
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    id?: StringFilter<"Milestone"> | string
    store_id?: StringFilter<"Milestone"> | string
    name?: StringFilter<"Milestone"> | string
    type?: StringFilter<"Milestone"> | string
    date?: DateTimeFilter<"Milestone"> | Date | string
    status?: StringFilter<"Milestone"> | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }

  export type MilestoneOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    date?: SortOrder
    status?: SortOrder
    store?: StoreOrderByWithRelationInput
  }

  export type MilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    store_id?: StringFilter<"Milestone"> | string
    name?: StringFilter<"Milestone"> | string
    type?: StringFilter<"Milestone"> | string
    date?: DateTimeFilter<"Milestone"> | Date | string
    status?: StringFilter<"Milestone"> | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }, "id">

  export type MilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    date?: SortOrder
    status?: SortOrder
    _count?: MilestoneCountOrderByAggregateInput
    _max?: MilestoneMaxOrderByAggregateInput
    _min?: MilestoneMinOrderByAggregateInput
  }

  export type MilestoneScalarWhereWithAggregatesInput = {
    AND?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    OR?: MilestoneScalarWhereWithAggregatesInput[]
    NOT?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Milestone"> | string
    store_id?: StringWithAggregatesFilter<"Milestone"> | string
    name?: StringWithAggregatesFilter<"Milestone"> | string
    type?: StringWithAggregatesFilter<"Milestone"> | string
    date?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    status?: StringWithAggregatesFilter<"Milestone"> | string
  }

  export type IssueWhereInput = {
    AND?: IssueWhereInput | IssueWhereInput[]
    OR?: IssueWhereInput[]
    NOT?: IssueWhereInput | IssueWhereInput[]
    id?: StringFilter<"Issue"> | string
    store_id?: StringFilter<"Issue"> | string
    title?: StringFilter<"Issue"> | string
    severity?: StringFilter<"Issue"> | string
    status?: StringFilter<"Issue"> | string
    mitigation?: StringNullableFilter<"Issue"> | string | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }

  export type IssueOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    mitigation?: SortOrderInput | SortOrder
    store?: StoreOrderByWithRelationInput
  }

  export type IssueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IssueWhereInput | IssueWhereInput[]
    OR?: IssueWhereInput[]
    NOT?: IssueWhereInput | IssueWhereInput[]
    store_id?: StringFilter<"Issue"> | string
    title?: StringFilter<"Issue"> | string
    severity?: StringFilter<"Issue"> | string
    status?: StringFilter<"Issue"> | string
    mitigation?: StringNullableFilter<"Issue"> | string | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }, "id">

  export type IssueOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    mitigation?: SortOrderInput | SortOrder
    _count?: IssueCountOrderByAggregateInput
    _max?: IssueMaxOrderByAggregateInput
    _min?: IssueMinOrderByAggregateInput
  }

  export type IssueScalarWhereWithAggregatesInput = {
    AND?: IssueScalarWhereWithAggregatesInput | IssueScalarWhereWithAggregatesInput[]
    OR?: IssueScalarWhereWithAggregatesInput[]
    NOT?: IssueScalarWhereWithAggregatesInput | IssueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Issue"> | string
    store_id?: StringWithAggregatesFilter<"Issue"> | string
    title?: StringWithAggregatesFilter<"Issue"> | string
    severity?: StringWithAggregatesFilter<"Issue"> | string
    status?: StringWithAggregatesFilter<"Issue"> | string
    mitigation?: StringNullableWithAggregatesFilter<"Issue"> | string | null
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    store_id?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    store?: StoreOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    store_id?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    store_id?: StringWithAggregatesFilter<"Document"> | string
    name?: StringWithAggregatesFilter<"Document"> | string
    url?: StringWithAggregatesFilter<"Document"> | string
    type?: StringWithAggregatesFilter<"Document"> | string
  }

  export type IngredientWhereInput = {
    AND?: IngredientWhereInput | IngredientWhereInput[]
    OR?: IngredientWhereInput[]
    NOT?: IngredientWhereInput | IngredientWhereInput[]
    id?: StringFilter<"Ingredient"> | string
    name?: StringFilter<"Ingredient"> | string
    unit_type?: StringFilter<"Ingredient"> | string
    category?: StringNullableFilter<"Ingredient"> | string | null
    prices?: GroceryPriceListRelationFilter
    recipe_lines?: RecipeLineListRelationFilter
  }

  export type IngredientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    unit_type?: SortOrder
    category?: SortOrderInput | SortOrder
    prices?: GroceryPriceOrderByRelationAggregateInput
    recipe_lines?: RecipeLineOrderByRelationAggregateInput
  }

  export type IngredientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IngredientWhereInput | IngredientWhereInput[]
    OR?: IngredientWhereInput[]
    NOT?: IngredientWhereInput | IngredientWhereInput[]
    name?: StringFilter<"Ingredient"> | string
    unit_type?: StringFilter<"Ingredient"> | string
    category?: StringNullableFilter<"Ingredient"> | string | null
    prices?: GroceryPriceListRelationFilter
    recipe_lines?: RecipeLineListRelationFilter
  }, "id">

  export type IngredientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    unit_type?: SortOrder
    category?: SortOrderInput | SortOrder
    _count?: IngredientCountOrderByAggregateInput
    _max?: IngredientMaxOrderByAggregateInput
    _min?: IngredientMinOrderByAggregateInput
  }

  export type IngredientScalarWhereWithAggregatesInput = {
    AND?: IngredientScalarWhereWithAggregatesInput | IngredientScalarWhereWithAggregatesInput[]
    OR?: IngredientScalarWhereWithAggregatesInput[]
    NOT?: IngredientScalarWhereWithAggregatesInput | IngredientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ingredient"> | string
    name?: StringWithAggregatesFilter<"Ingredient"> | string
    unit_type?: StringWithAggregatesFilter<"Ingredient"> | string
    category?: StringNullableWithAggregatesFilter<"Ingredient"> | string | null
  }

  export type GroceryPriceWhereInput = {
    AND?: GroceryPriceWhereInput | GroceryPriceWhereInput[]
    OR?: GroceryPriceWhereInput[]
    NOT?: GroceryPriceWhereInput | GroceryPriceWhereInput[]
    id?: StringFilter<"GroceryPrice"> | string
    country?: StringFilter<"GroceryPrice"> | string
    retailer?: StringFilter<"GroceryPrice"> | string
    ingredient_id?: StringFilter<"GroceryPrice"> | string
    package_size?: FloatFilter<"GroceryPrice"> | number
    package_unit?: StringFilter<"GroceryPrice"> | string
    price?: FloatFilter<"GroceryPrice"> | number
    currency?: StringFilter<"GroceryPrice"> | string
    normalized_price_per_unit?: FloatFilter<"GroceryPrice"> | number
    as_of?: DateTimeFilter<"GroceryPrice"> | Date | string
    source_url?: StringNullableFilter<"GroceryPrice"> | string | null
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
    history?: PriceHistoryListRelationFilter
  }

  export type GroceryPriceOrderByWithRelationInput = {
    id?: SortOrder
    country?: SortOrder
    retailer?: SortOrder
    ingredient_id?: SortOrder
    package_size?: SortOrder
    package_unit?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    normalized_price_per_unit?: SortOrder
    as_of?: SortOrder
    source_url?: SortOrderInput | SortOrder
    ingredient?: IngredientOrderByWithRelationInput
    history?: PriceHistoryOrderByRelationAggregateInput
  }

  export type GroceryPriceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroceryPriceWhereInput | GroceryPriceWhereInput[]
    OR?: GroceryPriceWhereInput[]
    NOT?: GroceryPriceWhereInput | GroceryPriceWhereInput[]
    country?: StringFilter<"GroceryPrice"> | string
    retailer?: StringFilter<"GroceryPrice"> | string
    ingredient_id?: StringFilter<"GroceryPrice"> | string
    package_size?: FloatFilter<"GroceryPrice"> | number
    package_unit?: StringFilter<"GroceryPrice"> | string
    price?: FloatFilter<"GroceryPrice"> | number
    currency?: StringFilter<"GroceryPrice"> | string
    normalized_price_per_unit?: FloatFilter<"GroceryPrice"> | number
    as_of?: DateTimeFilter<"GroceryPrice"> | Date | string
    source_url?: StringNullableFilter<"GroceryPrice"> | string | null
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
    history?: PriceHistoryListRelationFilter
  }, "id">

  export type GroceryPriceOrderByWithAggregationInput = {
    id?: SortOrder
    country?: SortOrder
    retailer?: SortOrder
    ingredient_id?: SortOrder
    package_size?: SortOrder
    package_unit?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    normalized_price_per_unit?: SortOrder
    as_of?: SortOrder
    source_url?: SortOrderInput | SortOrder
    _count?: GroceryPriceCountOrderByAggregateInput
    _avg?: GroceryPriceAvgOrderByAggregateInput
    _max?: GroceryPriceMaxOrderByAggregateInput
    _min?: GroceryPriceMinOrderByAggregateInput
    _sum?: GroceryPriceSumOrderByAggregateInput
  }

  export type GroceryPriceScalarWhereWithAggregatesInput = {
    AND?: GroceryPriceScalarWhereWithAggregatesInput | GroceryPriceScalarWhereWithAggregatesInput[]
    OR?: GroceryPriceScalarWhereWithAggregatesInput[]
    NOT?: GroceryPriceScalarWhereWithAggregatesInput | GroceryPriceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroceryPrice"> | string
    country?: StringWithAggregatesFilter<"GroceryPrice"> | string
    retailer?: StringWithAggregatesFilter<"GroceryPrice"> | string
    ingredient_id?: StringWithAggregatesFilter<"GroceryPrice"> | string
    package_size?: FloatWithAggregatesFilter<"GroceryPrice"> | number
    package_unit?: StringWithAggregatesFilter<"GroceryPrice"> | string
    price?: FloatWithAggregatesFilter<"GroceryPrice"> | number
    currency?: StringWithAggregatesFilter<"GroceryPrice"> | string
    normalized_price_per_unit?: FloatWithAggregatesFilter<"GroceryPrice"> | number
    as_of?: DateTimeWithAggregatesFilter<"GroceryPrice"> | Date | string
    source_url?: StringNullableWithAggregatesFilter<"GroceryPrice"> | string | null
  }

  export type PriceHistoryWhereInput = {
    AND?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    OR?: PriceHistoryWhereInput[]
    NOT?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    id?: StringFilter<"PriceHistory"> | string
    grocery_price_id?: StringFilter<"PriceHistory"> | string
    price?: FloatFilter<"PriceHistory"> | number
    changed_at?: DateTimeFilter<"PriceHistory"> | Date | string
    changed_by?: StringNullableFilter<"PriceHistory"> | string | null
    reason?: StringNullableFilter<"PriceHistory"> | string | null
    grocery_price?: XOR<GroceryPriceRelationFilter, GroceryPriceWhereInput>
  }

  export type PriceHistoryOrderByWithRelationInput = {
    id?: SortOrder
    grocery_price_id?: SortOrder
    price?: SortOrder
    changed_at?: SortOrder
    changed_by?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    grocery_price?: GroceryPriceOrderByWithRelationInput
  }

  export type PriceHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    OR?: PriceHistoryWhereInput[]
    NOT?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    grocery_price_id?: StringFilter<"PriceHistory"> | string
    price?: FloatFilter<"PriceHistory"> | number
    changed_at?: DateTimeFilter<"PriceHistory"> | Date | string
    changed_by?: StringNullableFilter<"PriceHistory"> | string | null
    reason?: StringNullableFilter<"PriceHistory"> | string | null
    grocery_price?: XOR<GroceryPriceRelationFilter, GroceryPriceWhereInput>
  }, "id">

  export type PriceHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    grocery_price_id?: SortOrder
    price?: SortOrder
    changed_at?: SortOrder
    changed_by?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    _count?: PriceHistoryCountOrderByAggregateInput
    _avg?: PriceHistoryAvgOrderByAggregateInput
    _max?: PriceHistoryMaxOrderByAggregateInput
    _min?: PriceHistoryMinOrderByAggregateInput
    _sum?: PriceHistorySumOrderByAggregateInput
  }

  export type PriceHistoryScalarWhereWithAggregatesInput = {
    AND?: PriceHistoryScalarWhereWithAggregatesInput | PriceHistoryScalarWhereWithAggregatesInput[]
    OR?: PriceHistoryScalarWhereWithAggregatesInput[]
    NOT?: PriceHistoryScalarWhereWithAggregatesInput | PriceHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PriceHistory"> | string
    grocery_price_id?: StringWithAggregatesFilter<"PriceHistory"> | string
    price?: FloatWithAggregatesFilter<"PriceHistory"> | number
    changed_at?: DateTimeWithAggregatesFilter<"PriceHistory"> | Date | string
    changed_by?: StringNullableWithAggregatesFilter<"PriceHistory"> | string | null
    reason?: StringNullableWithAggregatesFilter<"PriceHistory"> | string | null
  }

  export type RecipeWhereInput = {
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    id?: StringFilter<"Recipe"> | string
    name?: StringFilter<"Recipe"> | string
    menu_item?: StringFilter<"Recipe"> | string
    version?: StringFilter<"Recipe"> | string
    country?: StringNullableFilter<"Recipe"> | string | null
    yield_count?: FloatFilter<"Recipe"> | number
    target_cost_pct?: FloatFilter<"Recipe"> | number
    manual_price?: FloatNullableFilter<"Recipe"> | number | null
    created_at?: DateTimeFilter<"Recipe"> | Date | string
    lines?: RecipeLineListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    menu_item?: SortOrder
    version?: SortOrder
    country?: SortOrderInput | SortOrder
    yield_count?: SortOrder
    target_cost_pct?: SortOrder
    manual_price?: SortOrderInput | SortOrder
    created_at?: SortOrder
    lines?: RecipeLineOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    name?: StringFilter<"Recipe"> | string
    menu_item?: StringFilter<"Recipe"> | string
    version?: StringFilter<"Recipe"> | string
    country?: StringNullableFilter<"Recipe"> | string | null
    yield_count?: FloatFilter<"Recipe"> | number
    target_cost_pct?: FloatFilter<"Recipe"> | number
    manual_price?: FloatNullableFilter<"Recipe"> | number | null
    created_at?: DateTimeFilter<"Recipe"> | Date | string
    lines?: RecipeLineListRelationFilter
  }, "id">

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    menu_item?: SortOrder
    version?: SortOrder
    country?: SortOrderInput | SortOrder
    yield_count?: SortOrder
    target_cost_pct?: SortOrder
    manual_price?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _avg?: RecipeAvgOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
    _sum?: RecipeSumOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    OR?: RecipeScalarWhereWithAggregatesInput[]
    NOT?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Recipe"> | string
    name?: StringWithAggregatesFilter<"Recipe"> | string
    menu_item?: StringWithAggregatesFilter<"Recipe"> | string
    version?: StringWithAggregatesFilter<"Recipe"> | string
    country?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    yield_count?: FloatWithAggregatesFilter<"Recipe"> | number
    target_cost_pct?: FloatWithAggregatesFilter<"Recipe"> | number
    manual_price?: FloatNullableWithAggregatesFilter<"Recipe"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
  }

  export type RecipeLineWhereInput = {
    AND?: RecipeLineWhereInput | RecipeLineWhereInput[]
    OR?: RecipeLineWhereInput[]
    NOT?: RecipeLineWhereInput | RecipeLineWhereInput[]
    id?: StringFilter<"RecipeLine"> | string
    recipe_id?: StringFilter<"RecipeLine"> | string
    ingredient_id?: StringFilter<"RecipeLine"> | string
    quantity?: FloatFilter<"RecipeLine"> | number
    unit?: StringFilter<"RecipeLine"> | string
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
  }

  export type RecipeLineOrderByWithRelationInput = {
    id?: SortOrder
    recipe_id?: SortOrder
    ingredient_id?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    recipe?: RecipeOrderByWithRelationInput
    ingredient?: IngredientOrderByWithRelationInput
  }

  export type RecipeLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeLineWhereInput | RecipeLineWhereInput[]
    OR?: RecipeLineWhereInput[]
    NOT?: RecipeLineWhereInput | RecipeLineWhereInput[]
    recipe_id?: StringFilter<"RecipeLine"> | string
    ingredient_id?: StringFilter<"RecipeLine"> | string
    quantity?: FloatFilter<"RecipeLine"> | number
    unit?: StringFilter<"RecipeLine"> | string
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
  }, "id">

  export type RecipeLineOrderByWithAggregationInput = {
    id?: SortOrder
    recipe_id?: SortOrder
    ingredient_id?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    _count?: RecipeLineCountOrderByAggregateInput
    _avg?: RecipeLineAvgOrderByAggregateInput
    _max?: RecipeLineMaxOrderByAggregateInput
    _min?: RecipeLineMinOrderByAggregateInput
    _sum?: RecipeLineSumOrderByAggregateInput
  }

  export type RecipeLineScalarWhereWithAggregatesInput = {
    AND?: RecipeLineScalarWhereWithAggregatesInput | RecipeLineScalarWhereWithAggregatesInput[]
    OR?: RecipeLineScalarWhereWithAggregatesInput[]
    NOT?: RecipeLineScalarWhereWithAggregatesInput | RecipeLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecipeLine"> | string
    recipe_id?: StringWithAggregatesFilter<"RecipeLine"> | string
    ingredient_id?: StringWithAggregatesFilter<"RecipeLine"> | string
    quantity?: FloatWithAggregatesFilter<"RecipeLine"> | number
    unit?: StringWithAggregatesFilter<"RecipeLine"> | string
  }

  export type CompetitorPriceWhereInput = {
    AND?: CompetitorPriceWhereInput | CompetitorPriceWhereInput[]
    OR?: CompetitorPriceWhereInput[]
    NOT?: CompetitorPriceWhereInput | CompetitorPriceWhereInput[]
    id?: StringFilter<"CompetitorPrice"> | string
    country?: StringFilter<"CompetitorPrice"> | string
    brand?: StringFilter<"CompetitorPrice"> | string
    menu_item?: StringFilter<"CompetitorPrice"> | string
    price?: FloatFilter<"CompetitorPrice"> | number
    currency?: StringFilter<"CompetitorPrice"> | string
    as_of?: DateTimeFilter<"CompetitorPrice"> | Date | string
  }

  export type CompetitorPriceOrderByWithRelationInput = {
    id?: SortOrder
    country?: SortOrder
    brand?: SortOrder
    menu_item?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    as_of?: SortOrder
  }

  export type CompetitorPriceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompetitorPriceWhereInput | CompetitorPriceWhereInput[]
    OR?: CompetitorPriceWhereInput[]
    NOT?: CompetitorPriceWhereInput | CompetitorPriceWhereInput[]
    country?: StringFilter<"CompetitorPrice"> | string
    brand?: StringFilter<"CompetitorPrice"> | string
    menu_item?: StringFilter<"CompetitorPrice"> | string
    price?: FloatFilter<"CompetitorPrice"> | number
    currency?: StringFilter<"CompetitorPrice"> | string
    as_of?: DateTimeFilter<"CompetitorPrice"> | Date | string
  }, "id">

  export type CompetitorPriceOrderByWithAggregationInput = {
    id?: SortOrder
    country?: SortOrder
    brand?: SortOrder
    menu_item?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    as_of?: SortOrder
    _count?: CompetitorPriceCountOrderByAggregateInput
    _avg?: CompetitorPriceAvgOrderByAggregateInput
    _max?: CompetitorPriceMaxOrderByAggregateInput
    _min?: CompetitorPriceMinOrderByAggregateInput
    _sum?: CompetitorPriceSumOrderByAggregateInput
  }

  export type CompetitorPriceScalarWhereWithAggregatesInput = {
    AND?: CompetitorPriceScalarWhereWithAggregatesInput | CompetitorPriceScalarWhereWithAggregatesInput[]
    OR?: CompetitorPriceScalarWhereWithAggregatesInput[]
    NOT?: CompetitorPriceScalarWhereWithAggregatesInput | CompetitorPriceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompetitorPrice"> | string
    country?: StringWithAggregatesFilter<"CompetitorPrice"> | string
    brand?: StringWithAggregatesFilter<"CompetitorPrice"> | string
    menu_item?: StringWithAggregatesFilter<"CompetitorPrice"> | string
    price?: FloatWithAggregatesFilter<"CompetitorPrice"> | number
    currency?: StringWithAggregatesFilter<"CompetitorPrice"> | string
    as_of?: DateTimeWithAggregatesFilter<"CompetitorPrice"> | Date | string
  }

  export type FXRateWhereInput = {
    AND?: FXRateWhereInput | FXRateWhereInput[]
    OR?: FXRateWhereInput[]
    NOT?: FXRateWhereInput | FXRateWhereInput[]
    id?: StringFilter<"FXRate"> | string
    from_currency?: StringFilter<"FXRate"> | string
    to_currency?: StringFilter<"FXRate"> | string
    rate?: FloatFilter<"FXRate"> | number
    date?: DateTimeFilter<"FXRate"> | Date | string
  }

  export type FXRateOrderByWithRelationInput = {
    id?: SortOrder
    from_currency?: SortOrder
    to_currency?: SortOrder
    rate?: SortOrder
    date?: SortOrder
  }

  export type FXRateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FXRateWhereInput | FXRateWhereInput[]
    OR?: FXRateWhereInput[]
    NOT?: FXRateWhereInput | FXRateWhereInput[]
    from_currency?: StringFilter<"FXRate"> | string
    to_currency?: StringFilter<"FXRate"> | string
    rate?: FloatFilter<"FXRate"> | number
    date?: DateTimeFilter<"FXRate"> | Date | string
  }, "id">

  export type FXRateOrderByWithAggregationInput = {
    id?: SortOrder
    from_currency?: SortOrder
    to_currency?: SortOrder
    rate?: SortOrder
    date?: SortOrder
    _count?: FXRateCountOrderByAggregateInput
    _avg?: FXRateAvgOrderByAggregateInput
    _max?: FXRateMaxOrderByAggregateInput
    _min?: FXRateMinOrderByAggregateInput
    _sum?: FXRateSumOrderByAggregateInput
  }

  export type FXRateScalarWhereWithAggregatesInput = {
    AND?: FXRateScalarWhereWithAggregatesInput | FXRateScalarWhereWithAggregatesInput[]
    OR?: FXRateScalarWhereWithAggregatesInput[]
    NOT?: FXRateScalarWhereWithAggregatesInput | FXRateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FXRate"> | string
    from_currency?: StringWithAggregatesFilter<"FXRate"> | string
    to_currency?: StringWithAggregatesFilter<"FXRate"> | string
    rate?: FloatWithAggregatesFilter<"FXRate"> | number
    date?: DateTimeWithAggregatesFilter<"FXRate"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    entity_type?: StringFilter<"AuditLog"> | string
    entity_id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    changes?: StringFilter<"AuditLog"> | string
    user_id?: StringNullableFilter<"AuditLog"> | string | null
    created_at?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    action?: SortOrder
    changes?: SortOrder
    user_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    entity_type?: StringFilter<"AuditLog"> | string
    entity_id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    changes?: StringFilter<"AuditLog"> | string
    user_id?: StringNullableFilter<"AuditLog"> | string | null
    created_at?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    action?: SortOrder
    changes?: SortOrder
    user_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    entity_type?: StringWithAggregatesFilter<"AuditLog"> | string
    entity_id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    changes?: StringWithAggregatesFilter<"AuditLog"> | string
    user_id?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type NotificationLogWhereInput = {
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    type?: StringFilter<"NotificationLog"> | string
    recipient?: StringFilter<"NotificationLog"> | string
    payload?: StringFilter<"NotificationLog"> | string
    status?: StringFilter<"NotificationLog"> | string
    created_at?: DateTimeFilter<"NotificationLog"> | Date | string
  }

  export type NotificationLogOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    recipient?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    type?: StringFilter<"NotificationLog"> | string
    recipient?: StringFilter<"NotificationLog"> | string
    payload?: StringFilter<"NotificationLog"> | string
    status?: StringFilter<"NotificationLog"> | string
    created_at?: DateTimeFilter<"NotificationLog"> | Date | string
  }, "id">

  export type NotificationLogOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    recipient?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    _count?: NotificationLogCountOrderByAggregateInput
    _max?: NotificationLogMaxOrderByAggregateInput
    _min?: NotificationLogMinOrderByAggregateInput
  }

  export type NotificationLogScalarWhereWithAggregatesInput = {
    AND?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    OR?: NotificationLogScalarWhereWithAggregatesInput[]
    NOT?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationLog"> | string
    type?: StringWithAggregatesFilter<"NotificationLog"> | string
    recipient?: StringWithAggregatesFilter<"NotificationLog"> | string
    payload?: StringWithAggregatesFilter<"NotificationLog"> | string
    status?: StringWithAggregatesFilter<"NotificationLog"> | string
    created_at?: DateTimeWithAggregatesFilter<"NotificationLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    password_hash: string
    role: string
    created_at?: Date | string
    tasks_owned?: TaskCreateNestedManyWithoutOwnerInput
    tasks_collaborating?: TaskCreateNestedManyWithoutCollaboratorsInput
    audit_logs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    password_hash: string
    role: string
    created_at?: Date | string
    tasks_owned?: TaskUncheckedCreateNestedManyWithoutOwnerInput
    tasks_collaborating?: TaskUncheckedCreateNestedManyWithoutCollaboratorsInput
    audit_logs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks_owned?: TaskUpdateManyWithoutOwnerNestedInput
    tasks_collaborating?: TaskUpdateManyWithoutCollaboratorsNestedInput
    audit_logs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks_owned?: TaskUncheckedUpdateManyWithoutOwnerNestedInput
    tasks_collaborating?: TaskUncheckedUpdateManyWithoutCollaboratorsNestedInput
    audit_logs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreCreateInput = {
    id?: string
    name: string
    country: string
    city: string
    address?: string | null
    timezone: string
    status: string
    planned_open_date?: Date | string | null
    actual_open_date?: Date | string | null
    contract_signed_date?: Date | string | null
    template_version: string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskCreateNestedManyWithoutStoreInput
    milestones?: MilestoneCreateNestedManyWithoutStoreInput
    issues?: IssueCreateNestedManyWithoutStoreInput
    documents?: DocumentCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateInput = {
    id?: string
    name: string
    country: string
    city: string
    address?: string | null
    timezone: string
    status: string
    planned_open_date?: Date | string | null
    actual_open_date?: Date | string | null
    contract_signed_date?: Date | string | null
    template_version: string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutStoreInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutStoreInput
    issues?: IssueUncheckedCreateNestedManyWithoutStoreInput
    documents?: DocumentUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planned_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_signed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_version?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutStoreNestedInput
    milestones?: MilestoneUpdateManyWithoutStoreNestedInput
    issues?: IssueUpdateManyWithoutStoreNestedInput
    documents?: DocumentUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planned_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_signed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_version?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutStoreNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutStoreNestedInput
    issues?: IssueUncheckedUpdateManyWithoutStoreNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planned_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_signed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_version?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planned_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_signed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_version?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCreateInput = {
    id?: string
    name: string
    version: string
    is_active?: boolean
    created_at?: Date | string
    phases?: TemplatePhaseCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUncheckedCreateInput = {
    id?: string
    name: string
    version: string
    is_active?: boolean
    created_at?: Date | string
    phases?: TemplatePhaseUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phases?: TemplatePhaseUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phases?: TemplatePhaseUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplatePhaseCreateInput = {
    id?: string
    name: string
    order: number
    template: TemplateCreateNestedOneWithoutPhasesInput
    tasks?: TemplateTaskCreateNestedManyWithoutPhaseInput
  }

  export type TemplatePhaseUncheckedCreateInput = {
    id?: string
    template_id: string
    name: string
    order: number
    tasks?: TemplateTaskUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type TemplatePhaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    template?: TemplateUpdateOneRequiredWithoutPhasesNestedInput
    tasks?: TemplateTaskUpdateManyWithoutPhaseNestedInput
  }

  export type TemplatePhaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    template_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    tasks?: TemplateTaskUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type TemplatePhaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TemplatePhaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    template_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateTaskCreateInput = {
    id?: string
    name: string
    description?: string | null
    role_responsible: string
    duration_days: number
    anchor_event: string
    offset_days: number
    workday_rule?: string
    is_milestone?: boolean
    dependency_indices?: string | null
    phase: TemplatePhaseCreateNestedOneWithoutTasksInput
  }

  export type TemplateTaskUncheckedCreateInput = {
    id?: string
    phase_id: string
    name: string
    description?: string | null
    role_responsible: string
    duration_days: number
    anchor_event: string
    offset_days: number
    workday_rule?: string
    is_milestone?: boolean
    dependency_indices?: string | null
  }

  export type TemplateTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role_responsible?: StringFieldUpdateOperationsInput | string
    duration_days?: IntFieldUpdateOperationsInput | number
    anchor_event?: StringFieldUpdateOperationsInput | string
    offset_days?: IntFieldUpdateOperationsInput | number
    workday_rule?: StringFieldUpdateOperationsInput | string
    is_milestone?: BoolFieldUpdateOperationsInput | boolean
    dependency_indices?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: TemplatePhaseUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TemplateTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phase_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role_responsible?: StringFieldUpdateOperationsInput | string
    duration_days?: IntFieldUpdateOperationsInput | number
    anchor_event?: StringFieldUpdateOperationsInput | string
    offset_days?: IntFieldUpdateOperationsInput | number
    workday_rule?: StringFieldUpdateOperationsInput | string
    is_milestone?: BoolFieldUpdateOperationsInput | boolean
    dependency_indices?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role_responsible?: StringFieldUpdateOperationsInput | string
    duration_days?: IntFieldUpdateOperationsInput | number
    anchor_event?: StringFieldUpdateOperationsInput | string
    offset_days?: IntFieldUpdateOperationsInput | number
    workday_rule?: StringFieldUpdateOperationsInput | string
    is_milestone?: BoolFieldUpdateOperationsInput | boolean
    dependency_indices?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phase_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role_responsible?: StringFieldUpdateOperationsInput | string
    duration_days?: IntFieldUpdateOperationsInput | number
    anchor_event?: StringFieldUpdateOperationsInput | string
    offset_days?: IntFieldUpdateOperationsInput | number
    workday_rule?: StringFieldUpdateOperationsInput | string
    is_milestone?: BoolFieldUpdateOperationsInput | boolean
    dependency_indices?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    phase: string
    status: string
    priority?: string
    start_date?: Date | string | null
    due_date?: Date | string | null
    completed_at?: Date | string | null
    role?: string | null
    manual_override?: boolean
    locked?: boolean
    reschedule_mode?: string
    calendar_rule?: string
    anchor?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    owner?: UserCreateNestedOneWithoutTasks_ownedInput
    store: StoreCreateNestedOneWithoutTasksInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDepends_onInput
    collaborators?: UserCreateNestedManyWithoutTasks_collaboratingInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    store_id: string
    title: string
    description?: string | null
    phase: string
    status: string
    priority?: string
    start_date?: Date | string | null
    due_date?: Date | string | null
    completed_at?: Date | string | null
    role?: string | null
    manual_override?: boolean
    locked?: boolean
    reschedule_mode?: string
    calendar_rule?: string
    anchor?: string | null
    owner_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDepends_onInput
    collaborators?: UserUncheckedCreateNestedManyWithoutTasks_collaboratingInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutTasks_ownedNestedInput
    store?: StoreUpdateOneRequiredWithoutTasksNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDepends_onNestedInput
    collaborators?: UserUpdateManyWithoutTasks_collaboratingNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    store_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDepends_onNestedInput
    collaborators?: UserUncheckedUpdateManyWithoutTasks_collaboratingNestedInput
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    store_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDependencyCreateInput = {
    task: TaskCreateNestedOneWithoutDependenciesInput
    depends_on: TaskCreateNestedOneWithoutDependentsInput
  }

  export type TaskDependencyUncheckedCreateInput = {
    task_id: string
    depends_on_id: string
  }

  export type TaskDependencyUpdateInput = {
    task?: TaskUpdateOneRequiredWithoutDependenciesNestedInput
    depends_on?: TaskUpdateOneRequiredWithoutDependentsNestedInput
  }

  export type TaskDependencyUncheckedUpdateInput = {
    task_id?: StringFieldUpdateOperationsInput | string
    depends_on_id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDependencyUpdateManyMutationInput = {

  }

  export type TaskDependencyUncheckedUpdateManyInput = {
    task_id?: StringFieldUpdateOperationsInput | string
    depends_on_id?: StringFieldUpdateOperationsInput | string
  }

  export type MilestoneCreateInput = {
    id?: string
    name: string
    type: string
    date: Date | string
    status: string
    store: StoreCreateNestedOneWithoutMilestonesInput
  }

  export type MilestoneUncheckedCreateInput = {
    id?: string
    store_id: string
    name: string
    type: string
    date: Date | string
    status: string
  }

  export type MilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    store?: StoreUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type MilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    store_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    store_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type IssueCreateInput = {
    id?: string
    title: string
    severity: string
    status: string
    mitigation?: string | null
    store: StoreCreateNestedOneWithoutIssuesInput
  }

  export type IssueUncheckedCreateInput = {
    id?: string
    store_id: string
    title: string
    severity: string
    status: string
    mitigation?: string | null
  }

  export type IssueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    mitigation?: NullableStringFieldUpdateOperationsInput | string | null
    store?: StoreUpdateOneRequiredWithoutIssuesNestedInput
  }

  export type IssueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    store_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    mitigation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IssueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    mitigation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IssueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    store_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    mitigation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateInput = {
    id?: string
    name: string
    url: string
    type: string
    store: StoreCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    store_id: string
    name: string
    url: string
    type: string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    store?: StoreUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    store_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    store_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientCreateInput = {
    id?: string
    name: string
    unit_type: string
    category?: string | null
    prices?: GroceryPriceCreateNestedManyWithoutIngredientInput
    recipe_lines?: RecipeLineCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateInput = {
    id?: string
    name: string
    unit_type: string
    category?: string | null
    prices?: GroceryPriceUncheckedCreateNestedManyWithoutIngredientInput
    recipe_lines?: RecipeLineUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit_type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    prices?: GroceryPriceUpdateManyWithoutIngredientNestedInput
    recipe_lines?: RecipeLineUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit_type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    prices?: GroceryPriceUncheckedUpdateManyWithoutIngredientNestedInput
    recipe_lines?: RecipeLineUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit_type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit_type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroceryPriceCreateInput = {
    id?: string
    country: string
    retailer: string
    package_size: number
    package_unit: string
    price: number
    currency: string
    normalized_price_per_unit: number
    as_of: Date | string
    source_url?: string | null
    ingredient: IngredientCreateNestedOneWithoutPricesInput
    history?: PriceHistoryCreateNestedManyWithoutGrocery_priceInput
  }

  export type GroceryPriceUncheckedCreateInput = {
    id?: string
    country: string
    retailer: string
    ingredient_id: string
    package_size: number
    package_unit: string
    price: number
    currency: string
    normalized_price_per_unit: number
    as_of: Date | string
    source_url?: string | null
    history?: PriceHistoryUncheckedCreateNestedManyWithoutGrocery_priceInput
  }

  export type GroceryPriceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    retailer?: StringFieldUpdateOperationsInput | string
    package_size?: FloatFieldUpdateOperationsInput | number
    package_unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    normalized_price_per_unit?: FloatFieldUpdateOperationsInput | number
    as_of?: DateTimeFieldUpdateOperationsInput | Date | string
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    ingredient?: IngredientUpdateOneRequiredWithoutPricesNestedInput
    history?: PriceHistoryUpdateManyWithoutGrocery_priceNestedInput
  }

  export type GroceryPriceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    retailer?: StringFieldUpdateOperationsInput | string
    ingredient_id?: StringFieldUpdateOperationsInput | string
    package_size?: FloatFieldUpdateOperationsInput | number
    package_unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    normalized_price_per_unit?: FloatFieldUpdateOperationsInput | number
    as_of?: DateTimeFieldUpdateOperationsInput | Date | string
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    history?: PriceHistoryUncheckedUpdateManyWithoutGrocery_priceNestedInput
  }

  export type GroceryPriceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    retailer?: StringFieldUpdateOperationsInput | string
    package_size?: FloatFieldUpdateOperationsInput | number
    package_unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    normalized_price_per_unit?: FloatFieldUpdateOperationsInput | number
    as_of?: DateTimeFieldUpdateOperationsInput | Date | string
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroceryPriceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    retailer?: StringFieldUpdateOperationsInput | string
    ingredient_id?: StringFieldUpdateOperationsInput | string
    package_size?: FloatFieldUpdateOperationsInput | number
    package_unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    normalized_price_per_unit?: FloatFieldUpdateOperationsInput | number
    as_of?: DateTimeFieldUpdateOperationsInput | Date | string
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PriceHistoryCreateInput = {
    id?: string
    price: number
    changed_at?: Date | string
    changed_by?: string | null
    reason?: string | null
    grocery_price: GroceryPriceCreateNestedOneWithoutHistoryInput
  }

  export type PriceHistoryUncheckedCreateInput = {
    id?: string
    grocery_price_id: string
    price: number
    changed_at?: Date | string
    changed_by?: string | null
    reason?: string | null
  }

  export type PriceHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    changed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    grocery_price?: GroceryPriceUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type PriceHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grocery_price_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    changed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PriceHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    changed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PriceHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    grocery_price_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    changed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeCreateInput = {
    id?: string
    name: string
    menu_item: string
    version: string
    country?: string | null
    yield_count?: number
    target_cost_pct?: number
    manual_price?: number | null
    created_at?: Date | string
    lines?: RecipeLineCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: string
    name: string
    menu_item: string
    version: string
    country?: string | null
    yield_count?: number
    target_cost_pct?: number
    manual_price?: number | null
    created_at?: Date | string
    lines?: RecipeLineUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    menu_item?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    yield_count?: FloatFieldUpdateOperationsInput | number
    target_cost_pct?: FloatFieldUpdateOperationsInput | number
    manual_price?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: RecipeLineUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    menu_item?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    yield_count?: FloatFieldUpdateOperationsInput | number
    target_cost_pct?: FloatFieldUpdateOperationsInput | number
    manual_price?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: RecipeLineUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    menu_item?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    yield_count?: FloatFieldUpdateOperationsInput | number
    target_cost_pct?: FloatFieldUpdateOperationsInput | number
    manual_price?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    menu_item?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    yield_count?: FloatFieldUpdateOperationsInput | number
    target_cost_pct?: FloatFieldUpdateOperationsInput | number
    manual_price?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeLineCreateInput = {
    id?: string
    quantity: number
    unit: string
    recipe: RecipeCreateNestedOneWithoutLinesInput
    ingredient: IngredientCreateNestedOneWithoutRecipe_linesInput
  }

  export type RecipeLineUncheckedCreateInput = {
    id?: string
    recipe_id: string
    ingredient_id: string
    quantity: number
    unit: string
  }

  export type RecipeLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    recipe?: RecipeUpdateOneRequiredWithoutLinesNestedInput
    ingredient?: IngredientUpdateOneRequiredWithoutRecipe_linesNestedInput
  }

  export type RecipeLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipe_id?: StringFieldUpdateOperationsInput | string
    ingredient_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipe_id?: StringFieldUpdateOperationsInput | string
    ingredient_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type CompetitorPriceCreateInput = {
    id?: string
    country: string
    brand: string
    menu_item: string
    price: number
    currency: string
    as_of: Date | string
  }

  export type CompetitorPriceUncheckedCreateInput = {
    id?: string
    country: string
    brand: string
    menu_item: string
    price: number
    currency: string
    as_of: Date | string
  }

  export type CompetitorPriceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    menu_item?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    as_of?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorPriceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    menu_item?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    as_of?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorPriceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    menu_item?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    as_of?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorPriceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    menu_item?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    as_of?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FXRateCreateInput = {
    id?: string
    from_currency: string
    to_currency: string
    rate: number
    date?: Date | string
  }

  export type FXRateUncheckedCreateInput = {
    id?: string
    from_currency: string
    to_currency: string
    rate: number
    date?: Date | string
  }

  export type FXRateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_currency?: StringFieldUpdateOperationsInput | string
    to_currency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FXRateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_currency?: StringFieldUpdateOperationsInput | string
    to_currency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FXRateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_currency?: StringFieldUpdateOperationsInput | string
    to_currency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FXRateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_currency?: StringFieldUpdateOperationsInput | string
    to_currency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    entity_type: string
    entity_id: string
    action: string
    changes: string
    created_at?: Date | string
    user?: UserCreateNestedOneWithoutAudit_logsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    entity_type: string
    entity_id: string
    action: string
    changes: string
    user_id?: string | null
    created_at?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAudit_logsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateInput = {
    id?: string
    type: string
    recipient: string
    payload: string
    status: string
    created_at?: Date | string
  }

  export type NotificationLogUncheckedCreateInput = {
    id?: string
    type: string
    recipient: string
    payload: string
    status: string
    created_at?: Date | string
  }

  export type NotificationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MilestoneListRelationFilter = {
    every?: MilestoneWhereInput
    some?: MilestoneWhereInput
    none?: MilestoneWhereInput
  }

  export type IssueListRelationFilter = {
    every?: IssueWhereInput
    some?: IssueWhereInput
    none?: IssueWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type MilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IssueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    city?: SortOrder
    address?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    planned_open_date?: SortOrder
    actual_open_date?: SortOrder
    contract_signed_date?: SortOrder
    template_version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StoreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    city?: SortOrder
    address?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    planned_open_date?: SortOrder
    actual_open_date?: SortOrder
    contract_signed_date?: SortOrder
    template_version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StoreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    city?: SortOrder
    address?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    planned_open_date?: SortOrder
    actual_open_date?: SortOrder
    contract_signed_date?: SortOrder
    template_version?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TemplatePhaseListRelationFilter = {
    every?: TemplatePhaseWhereInput
    some?: TemplatePhaseWhereInput
    none?: TemplatePhaseWhereInput
  }

  export type TemplatePhaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type TemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type TemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TemplateRelationFilter = {
    is?: TemplateWhereInput
    isNot?: TemplateWhereInput
  }

  export type TemplateTaskListRelationFilter = {
    every?: TemplateTaskWhereInput
    some?: TemplateTaskWhereInput
    none?: TemplateTaskWhereInput
  }

  export type TemplateTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplatePhaseCountOrderByAggregateInput = {
    id?: SortOrder
    template_id?: SortOrder
    name?: SortOrder
    order?: SortOrder
  }

  export type TemplatePhaseAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type TemplatePhaseMaxOrderByAggregateInput = {
    id?: SortOrder
    template_id?: SortOrder
    name?: SortOrder
    order?: SortOrder
  }

  export type TemplatePhaseMinOrderByAggregateInput = {
    id?: SortOrder
    template_id?: SortOrder
    name?: SortOrder
    order?: SortOrder
  }

  export type TemplatePhaseSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type TemplatePhaseRelationFilter = {
    is?: TemplatePhaseWhereInput
    isNot?: TemplatePhaseWhereInput
  }

  export type TemplateTaskCountOrderByAggregateInput = {
    id?: SortOrder
    phase_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    role_responsible?: SortOrder
    duration_days?: SortOrder
    anchor_event?: SortOrder
    offset_days?: SortOrder
    workday_rule?: SortOrder
    is_milestone?: SortOrder
    dependency_indices?: SortOrder
  }

  export type TemplateTaskAvgOrderByAggregateInput = {
    duration_days?: SortOrder
    offset_days?: SortOrder
  }

  export type TemplateTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    phase_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    role_responsible?: SortOrder
    duration_days?: SortOrder
    anchor_event?: SortOrder
    offset_days?: SortOrder
    workday_rule?: SortOrder
    is_milestone?: SortOrder
    dependency_indices?: SortOrder
  }

  export type TemplateTaskMinOrderByAggregateInput = {
    id?: SortOrder
    phase_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    role_responsible?: SortOrder
    duration_days?: SortOrder
    anchor_event?: SortOrder
    offset_days?: SortOrder
    workday_rule?: SortOrder
    is_milestone?: SortOrder
    dependency_indices?: SortOrder
  }

  export type TemplateTaskSumOrderByAggregateInput = {
    duration_days?: SortOrder
    offset_days?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type StoreRelationFilter = {
    is?: StoreWhereInput
    isNot?: StoreWhereInput
  }

  export type TaskDependencyListRelationFilter = {
    every?: TaskDependencyWhereInput
    some?: TaskDependencyWhereInput
    none?: TaskDependencyWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type TaskDependencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    start_date?: SortOrder
    due_date?: SortOrder
    completed_at?: SortOrder
    role?: SortOrder
    manual_override?: SortOrder
    locked?: SortOrder
    reschedule_mode?: SortOrder
    calendar_rule?: SortOrder
    anchor?: SortOrder
    owner_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    start_date?: SortOrder
    due_date?: SortOrder
    completed_at?: SortOrder
    role?: SortOrder
    manual_override?: SortOrder
    locked?: SortOrder
    reschedule_mode?: SortOrder
    calendar_rule?: SortOrder
    anchor?: SortOrder
    owner_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    start_date?: SortOrder
    due_date?: SortOrder
    completed_at?: SortOrder
    role?: SortOrder
    manual_override?: SortOrder
    locked?: SortOrder
    reschedule_mode?: SortOrder
    calendar_rule?: SortOrder
    anchor?: SortOrder
    owner_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskDependencyTask_idDepends_on_idCompoundUniqueInput = {
    task_id: string
    depends_on_id: string
  }

  export type TaskDependencyCountOrderByAggregateInput = {
    task_id?: SortOrder
    depends_on_id?: SortOrder
  }

  export type TaskDependencyMaxOrderByAggregateInput = {
    task_id?: SortOrder
    depends_on_id?: SortOrder
  }

  export type TaskDependencyMinOrderByAggregateInput = {
    task_id?: SortOrder
    depends_on_id?: SortOrder
  }

  export type MilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type MilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type MilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type IssueCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    mitigation?: SortOrder
  }

  export type IssueMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    mitigation?: SortOrder
  }

  export type IssueMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    mitigation?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
  }

  export type GroceryPriceListRelationFilter = {
    every?: GroceryPriceWhereInput
    some?: GroceryPriceWhereInput
    none?: GroceryPriceWhereInput
  }

  export type RecipeLineListRelationFilter = {
    every?: RecipeLineWhereInput
    some?: RecipeLineWhereInput
    none?: RecipeLineWhereInput
  }

  export type GroceryPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngredientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    unit_type?: SortOrder
    category?: SortOrder
  }

  export type IngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    unit_type?: SortOrder
    category?: SortOrder
  }

  export type IngredientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    unit_type?: SortOrder
    category?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IngredientRelationFilter = {
    is?: IngredientWhereInput
    isNot?: IngredientWhereInput
  }

  export type PriceHistoryListRelationFilter = {
    every?: PriceHistoryWhereInput
    some?: PriceHistoryWhereInput
    none?: PriceHistoryWhereInput
  }

  export type PriceHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroceryPriceCountOrderByAggregateInput = {
    id?: SortOrder
    country?: SortOrder
    retailer?: SortOrder
    ingredient_id?: SortOrder
    package_size?: SortOrder
    package_unit?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    normalized_price_per_unit?: SortOrder
    as_of?: SortOrder
    source_url?: SortOrder
  }

  export type GroceryPriceAvgOrderByAggregateInput = {
    package_size?: SortOrder
    price?: SortOrder
    normalized_price_per_unit?: SortOrder
  }

  export type GroceryPriceMaxOrderByAggregateInput = {
    id?: SortOrder
    country?: SortOrder
    retailer?: SortOrder
    ingredient_id?: SortOrder
    package_size?: SortOrder
    package_unit?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    normalized_price_per_unit?: SortOrder
    as_of?: SortOrder
    source_url?: SortOrder
  }

  export type GroceryPriceMinOrderByAggregateInput = {
    id?: SortOrder
    country?: SortOrder
    retailer?: SortOrder
    ingredient_id?: SortOrder
    package_size?: SortOrder
    package_unit?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    normalized_price_per_unit?: SortOrder
    as_of?: SortOrder
    source_url?: SortOrder
  }

  export type GroceryPriceSumOrderByAggregateInput = {
    package_size?: SortOrder
    price?: SortOrder
    normalized_price_per_unit?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type GroceryPriceRelationFilter = {
    is?: GroceryPriceWhereInput
    isNot?: GroceryPriceWhereInput
  }

  export type PriceHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    grocery_price_id?: SortOrder
    price?: SortOrder
    changed_at?: SortOrder
    changed_by?: SortOrder
    reason?: SortOrder
  }

  export type PriceHistoryAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PriceHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    grocery_price_id?: SortOrder
    price?: SortOrder
    changed_at?: SortOrder
    changed_by?: SortOrder
    reason?: SortOrder
  }

  export type PriceHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    grocery_price_id?: SortOrder
    price?: SortOrder
    changed_at?: SortOrder
    changed_by?: SortOrder
    reason?: SortOrder
  }

  export type PriceHistorySumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    menu_item?: SortOrder
    version?: SortOrder
    country?: SortOrder
    yield_count?: SortOrder
    target_cost_pct?: SortOrder
    manual_price?: SortOrder
    created_at?: SortOrder
  }

  export type RecipeAvgOrderByAggregateInput = {
    yield_count?: SortOrder
    target_cost_pct?: SortOrder
    manual_price?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    menu_item?: SortOrder
    version?: SortOrder
    country?: SortOrder
    yield_count?: SortOrder
    target_cost_pct?: SortOrder
    manual_price?: SortOrder
    created_at?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    menu_item?: SortOrder
    version?: SortOrder
    country?: SortOrder
    yield_count?: SortOrder
    target_cost_pct?: SortOrder
    manual_price?: SortOrder
    created_at?: SortOrder
  }

  export type RecipeSumOrderByAggregateInput = {
    yield_count?: SortOrder
    target_cost_pct?: SortOrder
    manual_price?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type RecipeRelationFilter = {
    is?: RecipeWhereInput
    isNot?: RecipeWhereInput
  }

  export type RecipeLineCountOrderByAggregateInput = {
    id?: SortOrder
    recipe_id?: SortOrder
    ingredient_id?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
  }

  export type RecipeLineAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type RecipeLineMaxOrderByAggregateInput = {
    id?: SortOrder
    recipe_id?: SortOrder
    ingredient_id?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
  }

  export type RecipeLineMinOrderByAggregateInput = {
    id?: SortOrder
    recipe_id?: SortOrder
    ingredient_id?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
  }

  export type RecipeLineSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CompetitorPriceCountOrderByAggregateInput = {
    id?: SortOrder
    country?: SortOrder
    brand?: SortOrder
    menu_item?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    as_of?: SortOrder
  }

  export type CompetitorPriceAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CompetitorPriceMaxOrderByAggregateInput = {
    id?: SortOrder
    country?: SortOrder
    brand?: SortOrder
    menu_item?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    as_of?: SortOrder
  }

  export type CompetitorPriceMinOrderByAggregateInput = {
    id?: SortOrder
    country?: SortOrder
    brand?: SortOrder
    menu_item?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    as_of?: SortOrder
  }

  export type CompetitorPriceSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FXRateCountOrderByAggregateInput = {
    id?: SortOrder
    from_currency?: SortOrder
    to_currency?: SortOrder
    rate?: SortOrder
    date?: SortOrder
  }

  export type FXRateAvgOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type FXRateMaxOrderByAggregateInput = {
    id?: SortOrder
    from_currency?: SortOrder
    to_currency?: SortOrder
    rate?: SortOrder
    date?: SortOrder
  }

  export type FXRateMinOrderByAggregateInput = {
    id?: SortOrder
    from_currency?: SortOrder
    to_currency?: SortOrder
    rate?: SortOrder
    date?: SortOrder
  }

  export type FXRateSumOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    action?: SortOrder
    changes?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    action?: SortOrder
    changes?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    action?: SortOrder
    changes?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationLogCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    recipient?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    recipient?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationLogMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    recipient?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type TaskCreateNestedManyWithoutOwnerInput = {
    create?: XOR<TaskCreateWithoutOwnerInput, TaskUncheckedCreateWithoutOwnerInput> | TaskCreateWithoutOwnerInput[] | TaskUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutOwnerInput | TaskCreateOrConnectWithoutOwnerInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutCollaboratorsInput = {
    create?: XOR<TaskCreateWithoutCollaboratorsInput, TaskUncheckedCreateWithoutCollaboratorsInput> | TaskCreateWithoutCollaboratorsInput[] | TaskUncheckedCreateWithoutCollaboratorsInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCollaboratorsInput | TaskCreateOrConnectWithoutCollaboratorsInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<TaskCreateWithoutOwnerInput, TaskUncheckedCreateWithoutOwnerInput> | TaskCreateWithoutOwnerInput[] | TaskUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutOwnerInput | TaskCreateOrConnectWithoutOwnerInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutCollaboratorsInput = {
    create?: XOR<TaskCreateWithoutCollaboratorsInput, TaskUncheckedCreateWithoutCollaboratorsInput> | TaskCreateWithoutCollaboratorsInput[] | TaskUncheckedCreateWithoutCollaboratorsInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCollaboratorsInput | TaskCreateOrConnectWithoutCollaboratorsInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TaskUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<TaskCreateWithoutOwnerInput, TaskUncheckedCreateWithoutOwnerInput> | TaskCreateWithoutOwnerInput[] | TaskUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutOwnerInput | TaskCreateOrConnectWithoutOwnerInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutOwnerInput | TaskUpsertWithWhereUniqueWithoutOwnerInput[]
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutOwnerInput | TaskUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutOwnerInput | TaskUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutCollaboratorsNestedInput = {
    create?: XOR<TaskCreateWithoutCollaboratorsInput, TaskUncheckedCreateWithoutCollaboratorsInput> | TaskCreateWithoutCollaboratorsInput[] | TaskUncheckedCreateWithoutCollaboratorsInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCollaboratorsInput | TaskCreateOrConnectWithoutCollaboratorsInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCollaboratorsInput | TaskUpsertWithWhereUniqueWithoutCollaboratorsInput[]
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCollaboratorsInput | TaskUpdateWithWhereUniqueWithoutCollaboratorsInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCollaboratorsInput | TaskUpdateManyWithWhereWithoutCollaboratorsInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<TaskCreateWithoutOwnerInput, TaskUncheckedCreateWithoutOwnerInput> | TaskCreateWithoutOwnerInput[] | TaskUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutOwnerInput | TaskCreateOrConnectWithoutOwnerInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutOwnerInput | TaskUpsertWithWhereUniqueWithoutOwnerInput[]
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutOwnerInput | TaskUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutOwnerInput | TaskUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutCollaboratorsNestedInput = {
    create?: XOR<TaskCreateWithoutCollaboratorsInput, TaskUncheckedCreateWithoutCollaboratorsInput> | TaskCreateWithoutCollaboratorsInput[] | TaskUncheckedCreateWithoutCollaboratorsInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCollaboratorsInput | TaskCreateOrConnectWithoutCollaboratorsInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCollaboratorsInput | TaskUpsertWithWhereUniqueWithoutCollaboratorsInput[]
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCollaboratorsInput | TaskUpdateWithWhereUniqueWithoutCollaboratorsInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCollaboratorsInput | TaskUpdateManyWithWhereWithoutCollaboratorsInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type TaskCreateNestedManyWithoutStoreInput = {
    create?: XOR<TaskCreateWithoutStoreInput, TaskUncheckedCreateWithoutStoreInput> | TaskCreateWithoutStoreInput[] | TaskUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutStoreInput | TaskCreateOrConnectWithoutStoreInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type MilestoneCreateNestedManyWithoutStoreInput = {
    create?: XOR<MilestoneCreateWithoutStoreInput, MilestoneUncheckedCreateWithoutStoreInput> | MilestoneCreateWithoutStoreInput[] | MilestoneUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutStoreInput | MilestoneCreateOrConnectWithoutStoreInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type IssueCreateNestedManyWithoutStoreInput = {
    create?: XOR<IssueCreateWithoutStoreInput, IssueUncheckedCreateWithoutStoreInput> | IssueCreateWithoutStoreInput[] | IssueUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutStoreInput | IssueCreateOrConnectWithoutStoreInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutStoreInput = {
    create?: XOR<DocumentCreateWithoutStoreInput, DocumentUncheckedCreateWithoutStoreInput> | DocumentCreateWithoutStoreInput[] | DocumentUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutStoreInput | DocumentCreateOrConnectWithoutStoreInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<TaskCreateWithoutStoreInput, TaskUncheckedCreateWithoutStoreInput> | TaskCreateWithoutStoreInput[] | TaskUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutStoreInput | TaskCreateOrConnectWithoutStoreInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type MilestoneUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<MilestoneCreateWithoutStoreInput, MilestoneUncheckedCreateWithoutStoreInput> | MilestoneCreateWithoutStoreInput[] | MilestoneUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutStoreInput | MilestoneCreateOrConnectWithoutStoreInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type IssueUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<IssueCreateWithoutStoreInput, IssueUncheckedCreateWithoutStoreInput> | IssueCreateWithoutStoreInput[] | IssueUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutStoreInput | IssueCreateOrConnectWithoutStoreInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<DocumentCreateWithoutStoreInput, DocumentUncheckedCreateWithoutStoreInput> | DocumentCreateWithoutStoreInput[] | DocumentUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutStoreInput | DocumentCreateOrConnectWithoutStoreInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TaskUpdateManyWithoutStoreNestedInput = {
    create?: XOR<TaskCreateWithoutStoreInput, TaskUncheckedCreateWithoutStoreInput> | TaskCreateWithoutStoreInput[] | TaskUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutStoreInput | TaskCreateOrConnectWithoutStoreInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutStoreInput | TaskUpsertWithWhereUniqueWithoutStoreInput[]
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutStoreInput | TaskUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutStoreInput | TaskUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type MilestoneUpdateManyWithoutStoreNestedInput = {
    create?: XOR<MilestoneCreateWithoutStoreInput, MilestoneUncheckedCreateWithoutStoreInput> | MilestoneCreateWithoutStoreInput[] | MilestoneUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutStoreInput | MilestoneCreateOrConnectWithoutStoreInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutStoreInput | MilestoneUpsertWithWhereUniqueWithoutStoreInput[]
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutStoreInput | MilestoneUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutStoreInput | MilestoneUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type IssueUpdateManyWithoutStoreNestedInput = {
    create?: XOR<IssueCreateWithoutStoreInput, IssueUncheckedCreateWithoutStoreInput> | IssueCreateWithoutStoreInput[] | IssueUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutStoreInput | IssueCreateOrConnectWithoutStoreInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutStoreInput | IssueUpsertWithWhereUniqueWithoutStoreInput[]
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutStoreInput | IssueUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutStoreInput | IssueUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutStoreNestedInput = {
    create?: XOR<DocumentCreateWithoutStoreInput, DocumentUncheckedCreateWithoutStoreInput> | DocumentCreateWithoutStoreInput[] | DocumentUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutStoreInput | DocumentCreateOrConnectWithoutStoreInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutStoreInput | DocumentUpsertWithWhereUniqueWithoutStoreInput[]
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutStoreInput | DocumentUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutStoreInput | DocumentUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<TaskCreateWithoutStoreInput, TaskUncheckedCreateWithoutStoreInput> | TaskCreateWithoutStoreInput[] | TaskUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutStoreInput | TaskCreateOrConnectWithoutStoreInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutStoreInput | TaskUpsertWithWhereUniqueWithoutStoreInput[]
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutStoreInput | TaskUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutStoreInput | TaskUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type MilestoneUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<MilestoneCreateWithoutStoreInput, MilestoneUncheckedCreateWithoutStoreInput> | MilestoneCreateWithoutStoreInput[] | MilestoneUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutStoreInput | MilestoneCreateOrConnectWithoutStoreInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutStoreInput | MilestoneUpsertWithWhereUniqueWithoutStoreInput[]
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutStoreInput | MilestoneUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutStoreInput | MilestoneUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type IssueUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<IssueCreateWithoutStoreInput, IssueUncheckedCreateWithoutStoreInput> | IssueCreateWithoutStoreInput[] | IssueUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutStoreInput | IssueCreateOrConnectWithoutStoreInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutStoreInput | IssueUpsertWithWhereUniqueWithoutStoreInput[]
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutStoreInput | IssueUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutStoreInput | IssueUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<DocumentCreateWithoutStoreInput, DocumentUncheckedCreateWithoutStoreInput> | DocumentCreateWithoutStoreInput[] | DocumentUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutStoreInput | DocumentCreateOrConnectWithoutStoreInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutStoreInput | DocumentUpsertWithWhereUniqueWithoutStoreInput[]
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutStoreInput | DocumentUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutStoreInput | DocumentUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type TemplatePhaseCreateNestedManyWithoutTemplateInput = {
    create?: XOR<TemplatePhaseCreateWithoutTemplateInput, TemplatePhaseUncheckedCreateWithoutTemplateInput> | TemplatePhaseCreateWithoutTemplateInput[] | TemplatePhaseUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplatePhaseCreateOrConnectWithoutTemplateInput | TemplatePhaseCreateOrConnectWithoutTemplateInput[]
    connect?: TemplatePhaseWhereUniqueInput | TemplatePhaseWhereUniqueInput[]
  }

  export type TemplatePhaseUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<TemplatePhaseCreateWithoutTemplateInput, TemplatePhaseUncheckedCreateWithoutTemplateInput> | TemplatePhaseCreateWithoutTemplateInput[] | TemplatePhaseUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplatePhaseCreateOrConnectWithoutTemplateInput | TemplatePhaseCreateOrConnectWithoutTemplateInput[]
    connect?: TemplatePhaseWhereUniqueInput | TemplatePhaseWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TemplatePhaseUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<TemplatePhaseCreateWithoutTemplateInput, TemplatePhaseUncheckedCreateWithoutTemplateInput> | TemplatePhaseCreateWithoutTemplateInput[] | TemplatePhaseUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplatePhaseCreateOrConnectWithoutTemplateInput | TemplatePhaseCreateOrConnectWithoutTemplateInput[]
    upsert?: TemplatePhaseUpsertWithWhereUniqueWithoutTemplateInput | TemplatePhaseUpsertWithWhereUniqueWithoutTemplateInput[]
    set?: TemplatePhaseWhereUniqueInput | TemplatePhaseWhereUniqueInput[]
    disconnect?: TemplatePhaseWhereUniqueInput | TemplatePhaseWhereUniqueInput[]
    delete?: TemplatePhaseWhereUniqueInput | TemplatePhaseWhereUniqueInput[]
    connect?: TemplatePhaseWhereUniqueInput | TemplatePhaseWhereUniqueInput[]
    update?: TemplatePhaseUpdateWithWhereUniqueWithoutTemplateInput | TemplatePhaseUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: TemplatePhaseUpdateManyWithWhereWithoutTemplateInput | TemplatePhaseUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: TemplatePhaseScalarWhereInput | TemplatePhaseScalarWhereInput[]
  }

  export type TemplatePhaseUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<TemplatePhaseCreateWithoutTemplateInput, TemplatePhaseUncheckedCreateWithoutTemplateInput> | TemplatePhaseCreateWithoutTemplateInput[] | TemplatePhaseUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplatePhaseCreateOrConnectWithoutTemplateInput | TemplatePhaseCreateOrConnectWithoutTemplateInput[]
    upsert?: TemplatePhaseUpsertWithWhereUniqueWithoutTemplateInput | TemplatePhaseUpsertWithWhereUniqueWithoutTemplateInput[]
    set?: TemplatePhaseWhereUniqueInput | TemplatePhaseWhereUniqueInput[]
    disconnect?: TemplatePhaseWhereUniqueInput | TemplatePhaseWhereUniqueInput[]
    delete?: TemplatePhaseWhereUniqueInput | TemplatePhaseWhereUniqueInput[]
    connect?: TemplatePhaseWhereUniqueInput | TemplatePhaseWhereUniqueInput[]
    update?: TemplatePhaseUpdateWithWhereUniqueWithoutTemplateInput | TemplatePhaseUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: TemplatePhaseUpdateManyWithWhereWithoutTemplateInput | TemplatePhaseUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: TemplatePhaseScalarWhereInput | TemplatePhaseScalarWhereInput[]
  }

  export type TemplateCreateNestedOneWithoutPhasesInput = {
    create?: XOR<TemplateCreateWithoutPhasesInput, TemplateUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutPhasesInput
    connect?: TemplateWhereUniqueInput
  }

  export type TemplateTaskCreateNestedManyWithoutPhaseInput = {
    create?: XOR<TemplateTaskCreateWithoutPhaseInput, TemplateTaskUncheckedCreateWithoutPhaseInput> | TemplateTaskCreateWithoutPhaseInput[] | TemplateTaskUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: TemplateTaskCreateOrConnectWithoutPhaseInput | TemplateTaskCreateOrConnectWithoutPhaseInput[]
    connect?: TemplateTaskWhereUniqueInput | TemplateTaskWhereUniqueInput[]
  }

  export type TemplateTaskUncheckedCreateNestedManyWithoutPhaseInput = {
    create?: XOR<TemplateTaskCreateWithoutPhaseInput, TemplateTaskUncheckedCreateWithoutPhaseInput> | TemplateTaskCreateWithoutPhaseInput[] | TemplateTaskUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: TemplateTaskCreateOrConnectWithoutPhaseInput | TemplateTaskCreateOrConnectWithoutPhaseInput[]
    connect?: TemplateTaskWhereUniqueInput | TemplateTaskWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TemplateUpdateOneRequiredWithoutPhasesNestedInput = {
    create?: XOR<TemplateCreateWithoutPhasesInput, TemplateUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutPhasesInput
    upsert?: TemplateUpsertWithoutPhasesInput
    connect?: TemplateWhereUniqueInput
    update?: XOR<XOR<TemplateUpdateToOneWithWhereWithoutPhasesInput, TemplateUpdateWithoutPhasesInput>, TemplateUncheckedUpdateWithoutPhasesInput>
  }

  export type TemplateTaskUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<TemplateTaskCreateWithoutPhaseInput, TemplateTaskUncheckedCreateWithoutPhaseInput> | TemplateTaskCreateWithoutPhaseInput[] | TemplateTaskUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: TemplateTaskCreateOrConnectWithoutPhaseInput | TemplateTaskCreateOrConnectWithoutPhaseInput[]
    upsert?: TemplateTaskUpsertWithWhereUniqueWithoutPhaseInput | TemplateTaskUpsertWithWhereUniqueWithoutPhaseInput[]
    set?: TemplateTaskWhereUniqueInput | TemplateTaskWhereUniqueInput[]
    disconnect?: TemplateTaskWhereUniqueInput | TemplateTaskWhereUniqueInput[]
    delete?: TemplateTaskWhereUniqueInput | TemplateTaskWhereUniqueInput[]
    connect?: TemplateTaskWhereUniqueInput | TemplateTaskWhereUniqueInput[]
    update?: TemplateTaskUpdateWithWhereUniqueWithoutPhaseInput | TemplateTaskUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: TemplateTaskUpdateManyWithWhereWithoutPhaseInput | TemplateTaskUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: TemplateTaskScalarWhereInput | TemplateTaskScalarWhereInput[]
  }

  export type TemplateTaskUncheckedUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<TemplateTaskCreateWithoutPhaseInput, TemplateTaskUncheckedCreateWithoutPhaseInput> | TemplateTaskCreateWithoutPhaseInput[] | TemplateTaskUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: TemplateTaskCreateOrConnectWithoutPhaseInput | TemplateTaskCreateOrConnectWithoutPhaseInput[]
    upsert?: TemplateTaskUpsertWithWhereUniqueWithoutPhaseInput | TemplateTaskUpsertWithWhereUniqueWithoutPhaseInput[]
    set?: TemplateTaskWhereUniqueInput | TemplateTaskWhereUniqueInput[]
    disconnect?: TemplateTaskWhereUniqueInput | TemplateTaskWhereUniqueInput[]
    delete?: TemplateTaskWhereUniqueInput | TemplateTaskWhereUniqueInput[]
    connect?: TemplateTaskWhereUniqueInput | TemplateTaskWhereUniqueInput[]
    update?: TemplateTaskUpdateWithWhereUniqueWithoutPhaseInput | TemplateTaskUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: TemplateTaskUpdateManyWithWhereWithoutPhaseInput | TemplateTaskUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: TemplateTaskScalarWhereInput | TemplateTaskScalarWhereInput[]
  }

  export type TemplatePhaseCreateNestedOneWithoutTasksInput = {
    create?: XOR<TemplatePhaseCreateWithoutTasksInput, TemplatePhaseUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TemplatePhaseCreateOrConnectWithoutTasksInput
    connect?: TemplatePhaseWhereUniqueInput
  }

  export type TemplatePhaseUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<TemplatePhaseCreateWithoutTasksInput, TemplatePhaseUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TemplatePhaseCreateOrConnectWithoutTasksInput
    upsert?: TemplatePhaseUpsertWithoutTasksInput
    connect?: TemplatePhaseWhereUniqueInput
    update?: XOR<XOR<TemplatePhaseUpdateToOneWithWhereWithoutTasksInput, TemplatePhaseUpdateWithoutTasksInput>, TemplatePhaseUncheckedUpdateWithoutTasksInput>
  }

  export type UserCreateNestedOneWithoutTasks_ownedInput = {
    create?: XOR<UserCreateWithoutTasks_ownedInput, UserUncheckedCreateWithoutTasks_ownedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasks_ownedInput
    connect?: UserWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutTasksInput = {
    create?: XOR<StoreCreateWithoutTasksInput, StoreUncheckedCreateWithoutTasksInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTasksInput
    connect?: StoreWhereUniqueInput
  }

  export type TaskDependencyCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput> | TaskDependencyCreateWithoutTaskInput[] | TaskDependencyUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutTaskInput | TaskDependencyCreateOrConnectWithoutTaskInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
  }

  export type TaskDependencyCreateNestedManyWithoutDepends_onInput = {
    create?: XOR<TaskDependencyCreateWithoutDepends_onInput, TaskDependencyUncheckedCreateWithoutDepends_onInput> | TaskDependencyCreateWithoutDepends_onInput[] | TaskDependencyUncheckedCreateWithoutDepends_onInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutDepends_onInput | TaskDependencyCreateOrConnectWithoutDepends_onInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutTasks_collaboratingInput = {
    create?: XOR<UserCreateWithoutTasks_collaboratingInput, UserUncheckedCreateWithoutTasks_collaboratingInput> | UserCreateWithoutTasks_collaboratingInput[] | UserUncheckedCreateWithoutTasks_collaboratingInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTasks_collaboratingInput | UserCreateOrConnectWithoutTasks_collaboratingInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TaskDependencyUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput> | TaskDependencyCreateWithoutTaskInput[] | TaskDependencyUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutTaskInput | TaskDependencyCreateOrConnectWithoutTaskInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
  }

  export type TaskDependencyUncheckedCreateNestedManyWithoutDepends_onInput = {
    create?: XOR<TaskDependencyCreateWithoutDepends_onInput, TaskDependencyUncheckedCreateWithoutDepends_onInput> | TaskDependencyCreateWithoutDepends_onInput[] | TaskDependencyUncheckedCreateWithoutDepends_onInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutDepends_onInput | TaskDependencyCreateOrConnectWithoutDepends_onInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTasks_collaboratingInput = {
    create?: XOR<UserCreateWithoutTasks_collaboratingInput, UserUncheckedCreateWithoutTasks_collaboratingInput> | UserCreateWithoutTasks_collaboratingInput[] | UserUncheckedCreateWithoutTasks_collaboratingInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTasks_collaboratingInput | UserCreateOrConnectWithoutTasks_collaboratingInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutTasks_ownedNestedInput = {
    create?: XOR<UserCreateWithoutTasks_ownedInput, UserUncheckedCreateWithoutTasks_ownedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasks_ownedInput
    upsert?: UserUpsertWithoutTasks_ownedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasks_ownedInput, UserUpdateWithoutTasks_ownedInput>, UserUncheckedUpdateWithoutTasks_ownedInput>
  }

  export type StoreUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<StoreCreateWithoutTasksInput, StoreUncheckedCreateWithoutTasksInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTasksInput
    upsert?: StoreUpsertWithoutTasksInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutTasksInput, StoreUpdateWithoutTasksInput>, StoreUncheckedUpdateWithoutTasksInput>
  }

  export type TaskDependencyUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput> | TaskDependencyCreateWithoutTaskInput[] | TaskDependencyUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutTaskInput | TaskDependencyCreateOrConnectWithoutTaskInput[]
    upsert?: TaskDependencyUpsertWithWhereUniqueWithoutTaskInput | TaskDependencyUpsertWithWhereUniqueWithoutTaskInput[]
    set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    update?: TaskDependencyUpdateWithWhereUniqueWithoutTaskInput | TaskDependencyUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskDependencyUpdateManyWithWhereWithoutTaskInput | TaskDependencyUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
  }

  export type TaskDependencyUpdateManyWithoutDepends_onNestedInput = {
    create?: XOR<TaskDependencyCreateWithoutDepends_onInput, TaskDependencyUncheckedCreateWithoutDepends_onInput> | TaskDependencyCreateWithoutDepends_onInput[] | TaskDependencyUncheckedCreateWithoutDepends_onInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutDepends_onInput | TaskDependencyCreateOrConnectWithoutDepends_onInput[]
    upsert?: TaskDependencyUpsertWithWhereUniqueWithoutDepends_onInput | TaskDependencyUpsertWithWhereUniqueWithoutDepends_onInput[]
    set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    update?: TaskDependencyUpdateWithWhereUniqueWithoutDepends_onInput | TaskDependencyUpdateWithWhereUniqueWithoutDepends_onInput[]
    updateMany?: TaskDependencyUpdateManyWithWhereWithoutDepends_onInput | TaskDependencyUpdateManyWithWhereWithoutDepends_onInput[]
    deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
  }

  export type UserUpdateManyWithoutTasks_collaboratingNestedInput = {
    create?: XOR<UserCreateWithoutTasks_collaboratingInput, UserUncheckedCreateWithoutTasks_collaboratingInput> | UserCreateWithoutTasks_collaboratingInput[] | UserUncheckedCreateWithoutTasks_collaboratingInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTasks_collaboratingInput | UserCreateOrConnectWithoutTasks_collaboratingInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTasks_collaboratingInput | UserUpsertWithWhereUniqueWithoutTasks_collaboratingInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTasks_collaboratingInput | UserUpdateWithWhereUniqueWithoutTasks_collaboratingInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTasks_collaboratingInput | UserUpdateManyWithWhereWithoutTasks_collaboratingInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput> | TaskDependencyCreateWithoutTaskInput[] | TaskDependencyUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutTaskInput | TaskDependencyCreateOrConnectWithoutTaskInput[]
    upsert?: TaskDependencyUpsertWithWhereUniqueWithoutTaskInput | TaskDependencyUpsertWithWhereUniqueWithoutTaskInput[]
    set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    update?: TaskDependencyUpdateWithWhereUniqueWithoutTaskInput | TaskDependencyUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskDependencyUpdateManyWithWhereWithoutTaskInput | TaskDependencyUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
  }

  export type TaskDependencyUncheckedUpdateManyWithoutDepends_onNestedInput = {
    create?: XOR<TaskDependencyCreateWithoutDepends_onInput, TaskDependencyUncheckedCreateWithoutDepends_onInput> | TaskDependencyCreateWithoutDepends_onInput[] | TaskDependencyUncheckedCreateWithoutDepends_onInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutDepends_onInput | TaskDependencyCreateOrConnectWithoutDepends_onInput[]
    upsert?: TaskDependencyUpsertWithWhereUniqueWithoutDepends_onInput | TaskDependencyUpsertWithWhereUniqueWithoutDepends_onInput[]
    set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    update?: TaskDependencyUpdateWithWhereUniqueWithoutDepends_onInput | TaskDependencyUpdateWithWhereUniqueWithoutDepends_onInput[]
    updateMany?: TaskDependencyUpdateManyWithWhereWithoutDepends_onInput | TaskDependencyUpdateManyWithWhereWithoutDepends_onInput[]
    deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTasks_collaboratingNestedInput = {
    create?: XOR<UserCreateWithoutTasks_collaboratingInput, UserUncheckedCreateWithoutTasks_collaboratingInput> | UserCreateWithoutTasks_collaboratingInput[] | UserUncheckedCreateWithoutTasks_collaboratingInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTasks_collaboratingInput | UserCreateOrConnectWithoutTasks_collaboratingInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTasks_collaboratingInput | UserUpsertWithWhereUniqueWithoutTasks_collaboratingInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTasks_collaboratingInput | UserUpdateWithWhereUniqueWithoutTasks_collaboratingInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTasks_collaboratingInput | UserUpdateManyWithWhereWithoutTasks_collaboratingInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutDependenciesInput = {
    create?: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutDependenciesInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutDependentsInput = {
    create?: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutDependentsInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutDependenciesNestedInput = {
    create?: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutDependenciesInput
    upsert?: TaskUpsertWithoutDependenciesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutDependenciesInput, TaskUpdateWithoutDependenciesInput>, TaskUncheckedUpdateWithoutDependenciesInput>
  }

  export type TaskUpdateOneRequiredWithoutDependentsNestedInput = {
    create?: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutDependentsInput
    upsert?: TaskUpsertWithoutDependentsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutDependentsInput, TaskUpdateWithoutDependentsInput>, TaskUncheckedUpdateWithoutDependentsInput>
  }

  export type StoreCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<StoreCreateWithoutMilestonesInput, StoreUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutMilestonesInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<StoreCreateWithoutMilestonesInput, StoreUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutMilestonesInput
    upsert?: StoreUpsertWithoutMilestonesInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutMilestonesInput, StoreUpdateWithoutMilestonesInput>, StoreUncheckedUpdateWithoutMilestonesInput>
  }

  export type StoreCreateNestedOneWithoutIssuesInput = {
    create?: XOR<StoreCreateWithoutIssuesInput, StoreUncheckedCreateWithoutIssuesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutIssuesInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreUpdateOneRequiredWithoutIssuesNestedInput = {
    create?: XOR<StoreCreateWithoutIssuesInput, StoreUncheckedCreateWithoutIssuesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutIssuesInput
    upsert?: StoreUpsertWithoutIssuesInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutIssuesInput, StoreUpdateWithoutIssuesInput>, StoreUncheckedUpdateWithoutIssuesInput>
  }

  export type StoreCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<StoreCreateWithoutDocumentsInput, StoreUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutDocumentsInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<StoreCreateWithoutDocumentsInput, StoreUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutDocumentsInput
    upsert?: StoreUpsertWithoutDocumentsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutDocumentsInput, StoreUpdateWithoutDocumentsInput>, StoreUncheckedUpdateWithoutDocumentsInput>
  }

  export type GroceryPriceCreateNestedManyWithoutIngredientInput = {
    create?: XOR<GroceryPriceCreateWithoutIngredientInput, GroceryPriceUncheckedCreateWithoutIngredientInput> | GroceryPriceCreateWithoutIngredientInput[] | GroceryPriceUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: GroceryPriceCreateOrConnectWithoutIngredientInput | GroceryPriceCreateOrConnectWithoutIngredientInput[]
    connect?: GroceryPriceWhereUniqueInput | GroceryPriceWhereUniqueInput[]
  }

  export type RecipeLineCreateNestedManyWithoutIngredientInput = {
    create?: XOR<RecipeLineCreateWithoutIngredientInput, RecipeLineUncheckedCreateWithoutIngredientInput> | RecipeLineCreateWithoutIngredientInput[] | RecipeLineUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: RecipeLineCreateOrConnectWithoutIngredientInput | RecipeLineCreateOrConnectWithoutIngredientInput[]
    connect?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
  }

  export type GroceryPriceUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<GroceryPriceCreateWithoutIngredientInput, GroceryPriceUncheckedCreateWithoutIngredientInput> | GroceryPriceCreateWithoutIngredientInput[] | GroceryPriceUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: GroceryPriceCreateOrConnectWithoutIngredientInput | GroceryPriceCreateOrConnectWithoutIngredientInput[]
    connect?: GroceryPriceWhereUniqueInput | GroceryPriceWhereUniqueInput[]
  }

  export type RecipeLineUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<RecipeLineCreateWithoutIngredientInput, RecipeLineUncheckedCreateWithoutIngredientInput> | RecipeLineCreateWithoutIngredientInput[] | RecipeLineUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: RecipeLineCreateOrConnectWithoutIngredientInput | RecipeLineCreateOrConnectWithoutIngredientInput[]
    connect?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
  }

  export type GroceryPriceUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<GroceryPriceCreateWithoutIngredientInput, GroceryPriceUncheckedCreateWithoutIngredientInput> | GroceryPriceCreateWithoutIngredientInput[] | GroceryPriceUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: GroceryPriceCreateOrConnectWithoutIngredientInput | GroceryPriceCreateOrConnectWithoutIngredientInput[]
    upsert?: GroceryPriceUpsertWithWhereUniqueWithoutIngredientInput | GroceryPriceUpsertWithWhereUniqueWithoutIngredientInput[]
    set?: GroceryPriceWhereUniqueInput | GroceryPriceWhereUniqueInput[]
    disconnect?: GroceryPriceWhereUniqueInput | GroceryPriceWhereUniqueInput[]
    delete?: GroceryPriceWhereUniqueInput | GroceryPriceWhereUniqueInput[]
    connect?: GroceryPriceWhereUniqueInput | GroceryPriceWhereUniqueInput[]
    update?: GroceryPriceUpdateWithWhereUniqueWithoutIngredientInput | GroceryPriceUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: GroceryPriceUpdateManyWithWhereWithoutIngredientInput | GroceryPriceUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: GroceryPriceScalarWhereInput | GroceryPriceScalarWhereInput[]
  }

  export type RecipeLineUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<RecipeLineCreateWithoutIngredientInput, RecipeLineUncheckedCreateWithoutIngredientInput> | RecipeLineCreateWithoutIngredientInput[] | RecipeLineUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: RecipeLineCreateOrConnectWithoutIngredientInput | RecipeLineCreateOrConnectWithoutIngredientInput[]
    upsert?: RecipeLineUpsertWithWhereUniqueWithoutIngredientInput | RecipeLineUpsertWithWhereUniqueWithoutIngredientInput[]
    set?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    disconnect?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    delete?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    connect?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    update?: RecipeLineUpdateWithWhereUniqueWithoutIngredientInput | RecipeLineUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: RecipeLineUpdateManyWithWhereWithoutIngredientInput | RecipeLineUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: RecipeLineScalarWhereInput | RecipeLineScalarWhereInput[]
  }

  export type GroceryPriceUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<GroceryPriceCreateWithoutIngredientInput, GroceryPriceUncheckedCreateWithoutIngredientInput> | GroceryPriceCreateWithoutIngredientInput[] | GroceryPriceUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: GroceryPriceCreateOrConnectWithoutIngredientInput | GroceryPriceCreateOrConnectWithoutIngredientInput[]
    upsert?: GroceryPriceUpsertWithWhereUniqueWithoutIngredientInput | GroceryPriceUpsertWithWhereUniqueWithoutIngredientInput[]
    set?: GroceryPriceWhereUniqueInput | GroceryPriceWhereUniqueInput[]
    disconnect?: GroceryPriceWhereUniqueInput | GroceryPriceWhereUniqueInput[]
    delete?: GroceryPriceWhereUniqueInput | GroceryPriceWhereUniqueInput[]
    connect?: GroceryPriceWhereUniqueInput | GroceryPriceWhereUniqueInput[]
    update?: GroceryPriceUpdateWithWhereUniqueWithoutIngredientInput | GroceryPriceUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: GroceryPriceUpdateManyWithWhereWithoutIngredientInput | GroceryPriceUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: GroceryPriceScalarWhereInput | GroceryPriceScalarWhereInput[]
  }

  export type RecipeLineUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<RecipeLineCreateWithoutIngredientInput, RecipeLineUncheckedCreateWithoutIngredientInput> | RecipeLineCreateWithoutIngredientInput[] | RecipeLineUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: RecipeLineCreateOrConnectWithoutIngredientInput | RecipeLineCreateOrConnectWithoutIngredientInput[]
    upsert?: RecipeLineUpsertWithWhereUniqueWithoutIngredientInput | RecipeLineUpsertWithWhereUniqueWithoutIngredientInput[]
    set?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    disconnect?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    delete?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    connect?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    update?: RecipeLineUpdateWithWhereUniqueWithoutIngredientInput | RecipeLineUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: RecipeLineUpdateManyWithWhereWithoutIngredientInput | RecipeLineUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: RecipeLineScalarWhereInput | RecipeLineScalarWhereInput[]
  }

  export type IngredientCreateNestedOneWithoutPricesInput = {
    create?: XOR<IngredientCreateWithoutPricesInput, IngredientUncheckedCreateWithoutPricesInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutPricesInput
    connect?: IngredientWhereUniqueInput
  }

  export type PriceHistoryCreateNestedManyWithoutGrocery_priceInput = {
    create?: XOR<PriceHistoryCreateWithoutGrocery_priceInput, PriceHistoryUncheckedCreateWithoutGrocery_priceInput> | PriceHistoryCreateWithoutGrocery_priceInput[] | PriceHistoryUncheckedCreateWithoutGrocery_priceInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutGrocery_priceInput | PriceHistoryCreateOrConnectWithoutGrocery_priceInput[]
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
  }

  export type PriceHistoryUncheckedCreateNestedManyWithoutGrocery_priceInput = {
    create?: XOR<PriceHistoryCreateWithoutGrocery_priceInput, PriceHistoryUncheckedCreateWithoutGrocery_priceInput> | PriceHistoryCreateWithoutGrocery_priceInput[] | PriceHistoryUncheckedCreateWithoutGrocery_priceInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutGrocery_priceInput | PriceHistoryCreateOrConnectWithoutGrocery_priceInput[]
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IngredientUpdateOneRequiredWithoutPricesNestedInput = {
    create?: XOR<IngredientCreateWithoutPricesInput, IngredientUncheckedCreateWithoutPricesInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutPricesInput
    upsert?: IngredientUpsertWithoutPricesInput
    connect?: IngredientWhereUniqueInput
    update?: XOR<XOR<IngredientUpdateToOneWithWhereWithoutPricesInput, IngredientUpdateWithoutPricesInput>, IngredientUncheckedUpdateWithoutPricesInput>
  }

  export type PriceHistoryUpdateManyWithoutGrocery_priceNestedInput = {
    create?: XOR<PriceHistoryCreateWithoutGrocery_priceInput, PriceHistoryUncheckedCreateWithoutGrocery_priceInput> | PriceHistoryCreateWithoutGrocery_priceInput[] | PriceHistoryUncheckedCreateWithoutGrocery_priceInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutGrocery_priceInput | PriceHistoryCreateOrConnectWithoutGrocery_priceInput[]
    upsert?: PriceHistoryUpsertWithWhereUniqueWithoutGrocery_priceInput | PriceHistoryUpsertWithWhereUniqueWithoutGrocery_priceInput[]
    set?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    disconnect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    delete?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    update?: PriceHistoryUpdateWithWhereUniqueWithoutGrocery_priceInput | PriceHistoryUpdateWithWhereUniqueWithoutGrocery_priceInput[]
    updateMany?: PriceHistoryUpdateManyWithWhereWithoutGrocery_priceInput | PriceHistoryUpdateManyWithWhereWithoutGrocery_priceInput[]
    deleteMany?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
  }

  export type PriceHistoryUncheckedUpdateManyWithoutGrocery_priceNestedInput = {
    create?: XOR<PriceHistoryCreateWithoutGrocery_priceInput, PriceHistoryUncheckedCreateWithoutGrocery_priceInput> | PriceHistoryCreateWithoutGrocery_priceInput[] | PriceHistoryUncheckedCreateWithoutGrocery_priceInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutGrocery_priceInput | PriceHistoryCreateOrConnectWithoutGrocery_priceInput[]
    upsert?: PriceHistoryUpsertWithWhereUniqueWithoutGrocery_priceInput | PriceHistoryUpsertWithWhereUniqueWithoutGrocery_priceInput[]
    set?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    disconnect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    delete?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    update?: PriceHistoryUpdateWithWhereUniqueWithoutGrocery_priceInput | PriceHistoryUpdateWithWhereUniqueWithoutGrocery_priceInput[]
    updateMany?: PriceHistoryUpdateManyWithWhereWithoutGrocery_priceInput | PriceHistoryUpdateManyWithWhereWithoutGrocery_priceInput[]
    deleteMany?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
  }

  export type GroceryPriceCreateNestedOneWithoutHistoryInput = {
    create?: XOR<GroceryPriceCreateWithoutHistoryInput, GroceryPriceUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: GroceryPriceCreateOrConnectWithoutHistoryInput
    connect?: GroceryPriceWhereUniqueInput
  }

  export type GroceryPriceUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<GroceryPriceCreateWithoutHistoryInput, GroceryPriceUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: GroceryPriceCreateOrConnectWithoutHistoryInput
    upsert?: GroceryPriceUpsertWithoutHistoryInput
    connect?: GroceryPriceWhereUniqueInput
    update?: XOR<XOR<GroceryPriceUpdateToOneWithWhereWithoutHistoryInput, GroceryPriceUpdateWithoutHistoryInput>, GroceryPriceUncheckedUpdateWithoutHistoryInput>
  }

  export type RecipeLineCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeLineCreateWithoutRecipeInput, RecipeLineUncheckedCreateWithoutRecipeInput> | RecipeLineCreateWithoutRecipeInput[] | RecipeLineUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeLineCreateOrConnectWithoutRecipeInput | RecipeLineCreateOrConnectWithoutRecipeInput[]
    connect?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
  }

  export type RecipeLineUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeLineCreateWithoutRecipeInput, RecipeLineUncheckedCreateWithoutRecipeInput> | RecipeLineCreateWithoutRecipeInput[] | RecipeLineUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeLineCreateOrConnectWithoutRecipeInput | RecipeLineCreateOrConnectWithoutRecipeInput[]
    connect?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RecipeLineUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeLineCreateWithoutRecipeInput, RecipeLineUncheckedCreateWithoutRecipeInput> | RecipeLineCreateWithoutRecipeInput[] | RecipeLineUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeLineCreateOrConnectWithoutRecipeInput | RecipeLineCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeLineUpsertWithWhereUniqueWithoutRecipeInput | RecipeLineUpsertWithWhereUniqueWithoutRecipeInput[]
    set?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    disconnect?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    delete?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    connect?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    update?: RecipeLineUpdateWithWhereUniqueWithoutRecipeInput | RecipeLineUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeLineUpdateManyWithWhereWithoutRecipeInput | RecipeLineUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeLineScalarWhereInput | RecipeLineScalarWhereInput[]
  }

  export type RecipeLineUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeLineCreateWithoutRecipeInput, RecipeLineUncheckedCreateWithoutRecipeInput> | RecipeLineCreateWithoutRecipeInput[] | RecipeLineUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeLineCreateOrConnectWithoutRecipeInput | RecipeLineCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeLineUpsertWithWhereUniqueWithoutRecipeInput | RecipeLineUpsertWithWhereUniqueWithoutRecipeInput[]
    set?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    disconnect?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    delete?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    connect?: RecipeLineWhereUniqueInput | RecipeLineWhereUniqueInput[]
    update?: RecipeLineUpdateWithWhereUniqueWithoutRecipeInput | RecipeLineUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeLineUpdateManyWithWhereWithoutRecipeInput | RecipeLineUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeLineScalarWhereInput | RecipeLineScalarWhereInput[]
  }

  export type RecipeCreateNestedOneWithoutLinesInput = {
    create?: XOR<RecipeCreateWithoutLinesInput, RecipeUncheckedCreateWithoutLinesInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutLinesInput
    connect?: RecipeWhereUniqueInput
  }

  export type IngredientCreateNestedOneWithoutRecipe_linesInput = {
    create?: XOR<IngredientCreateWithoutRecipe_linesInput, IngredientUncheckedCreateWithoutRecipe_linesInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutRecipe_linesInput
    connect?: IngredientWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<RecipeCreateWithoutLinesInput, RecipeUncheckedCreateWithoutLinesInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutLinesInput
    upsert?: RecipeUpsertWithoutLinesInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutLinesInput, RecipeUpdateWithoutLinesInput>, RecipeUncheckedUpdateWithoutLinesInput>
  }

  export type IngredientUpdateOneRequiredWithoutRecipe_linesNestedInput = {
    create?: XOR<IngredientCreateWithoutRecipe_linesInput, IngredientUncheckedCreateWithoutRecipe_linesInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutRecipe_linesInput
    upsert?: IngredientUpsertWithoutRecipe_linesInput
    connect?: IngredientWhereUniqueInput
    update?: XOR<XOR<IngredientUpdateToOneWithWhereWithoutRecipe_linesInput, IngredientUpdateWithoutRecipe_linesInput>, IngredientUncheckedUpdateWithoutRecipe_linesInput>
  }

  export type UserCreateNestedOneWithoutAudit_logsInput = {
    create?: XOR<UserCreateWithoutAudit_logsInput, UserUncheckedCreateWithoutAudit_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudit_logsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAudit_logsNestedInput = {
    create?: XOR<UserCreateWithoutAudit_logsInput, UserUncheckedCreateWithoutAudit_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudit_logsInput
    upsert?: UserUpsertWithoutAudit_logsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAudit_logsInput, UserUpdateWithoutAudit_logsInput>, UserUncheckedUpdateWithoutAudit_logsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type TaskCreateWithoutOwnerInput = {
    id?: string
    title: string
    description?: string | null
    phase: string
    status: string
    priority?: string
    start_date?: Date | string | null
    due_date?: Date | string | null
    completed_at?: Date | string | null
    role?: string | null
    manual_override?: boolean
    locked?: boolean
    reschedule_mode?: string
    calendar_rule?: string
    anchor?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    store: StoreCreateNestedOneWithoutTasksInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDepends_onInput
    collaborators?: UserCreateNestedManyWithoutTasks_collaboratingInput
  }

  export type TaskUncheckedCreateWithoutOwnerInput = {
    id?: string
    store_id: string
    title: string
    description?: string | null
    phase: string
    status: string
    priority?: string
    start_date?: Date | string | null
    due_date?: Date | string | null
    completed_at?: Date | string | null
    role?: string | null
    manual_override?: boolean
    locked?: boolean
    reschedule_mode?: string
    calendar_rule?: string
    anchor?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDepends_onInput
    collaborators?: UserUncheckedCreateNestedManyWithoutTasks_collaboratingInput
  }

  export type TaskCreateOrConnectWithoutOwnerInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutOwnerInput, TaskUncheckedCreateWithoutOwnerInput>
  }

  export type TaskCreateWithoutCollaboratorsInput = {
    id?: string
    title: string
    description?: string | null
    phase: string
    status: string
    priority?: string
    start_date?: Date | string | null
    due_date?: Date | string | null
    completed_at?: Date | string | null
    role?: string | null
    manual_override?: boolean
    locked?: boolean
    reschedule_mode?: string
    calendar_rule?: string
    anchor?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    owner?: UserCreateNestedOneWithoutTasks_ownedInput
    store: StoreCreateNestedOneWithoutTasksInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDepends_onInput
  }

  export type TaskUncheckedCreateWithoutCollaboratorsInput = {
    id?: string
    store_id: string
    title: string
    description?: string | null
    phase: string
    status: string
    priority?: string
    start_date?: Date | string | null
    due_date?: Date | string | null
    completed_at?: Date | string | null
    role?: string | null
    manual_override?: boolean
    locked?: boolean
    reschedule_mode?: string
    calendar_rule?: string
    anchor?: string | null
    owner_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDepends_onInput
  }

  export type TaskCreateOrConnectWithoutCollaboratorsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCollaboratorsInput, TaskUncheckedCreateWithoutCollaboratorsInput>
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    entity_type: string
    entity_id: string
    action: string
    changes: string
    created_at?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    entity_type: string
    entity_id: string
    action: string
    changes: string
    created_at?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutOwnerInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutOwnerInput, TaskUncheckedUpdateWithoutOwnerInput>
    create: XOR<TaskCreateWithoutOwnerInput, TaskUncheckedCreateWithoutOwnerInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutOwnerInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutOwnerInput, TaskUncheckedUpdateWithoutOwnerInput>
  }

  export type TaskUpdateManyWithWhereWithoutOwnerInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutOwnerInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    store_id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    phase?: StringFilter<"Task"> | string
    status?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    start_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    due_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"Task"> | Date | string | null
    role?: StringNullableFilter<"Task"> | string | null
    manual_override?: BoolFilter<"Task"> | boolean
    locked?: BoolFilter<"Task"> | boolean
    reschedule_mode?: StringFilter<"Task"> | string
    calendar_rule?: StringFilter<"Task"> | string
    anchor?: StringNullableFilter<"Task"> | string | null
    owner_id?: StringNullableFilter<"Task"> | string | null
    created_at?: DateTimeFilter<"Task"> | Date | string
    updated_at?: DateTimeFilter<"Task"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutCollaboratorsInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCollaboratorsInput, TaskUncheckedUpdateWithoutCollaboratorsInput>
    create: XOR<TaskCreateWithoutCollaboratorsInput, TaskUncheckedCreateWithoutCollaboratorsInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCollaboratorsInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCollaboratorsInput, TaskUncheckedUpdateWithoutCollaboratorsInput>
  }

  export type TaskUpdateManyWithWhereWithoutCollaboratorsInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCollaboratorsInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    entity_type?: StringFilter<"AuditLog"> | string
    entity_id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    changes?: StringFilter<"AuditLog"> | string
    user_id?: StringNullableFilter<"AuditLog"> | string | null
    created_at?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type TaskCreateWithoutStoreInput = {
    id?: string
    title: string
    description?: string | null
    phase: string
    status: string
    priority?: string
    start_date?: Date | string | null
    due_date?: Date | string | null
    completed_at?: Date | string | null
    role?: string | null
    manual_override?: boolean
    locked?: boolean
    reschedule_mode?: string
    calendar_rule?: string
    anchor?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    owner?: UserCreateNestedOneWithoutTasks_ownedInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDepends_onInput
    collaborators?: UserCreateNestedManyWithoutTasks_collaboratingInput
  }

  export type TaskUncheckedCreateWithoutStoreInput = {
    id?: string
    title: string
    description?: string | null
    phase: string
    status: string
    priority?: string
    start_date?: Date | string | null
    due_date?: Date | string | null
    completed_at?: Date | string | null
    role?: string | null
    manual_override?: boolean
    locked?: boolean
    reschedule_mode?: string
    calendar_rule?: string
    anchor?: string | null
    owner_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDepends_onInput
    collaborators?: UserUncheckedCreateNestedManyWithoutTasks_collaboratingInput
  }

  export type TaskCreateOrConnectWithoutStoreInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutStoreInput, TaskUncheckedCreateWithoutStoreInput>
  }

  export type MilestoneCreateWithoutStoreInput = {
    id?: string
    name: string
    type: string
    date: Date | string
    status: string
  }

  export type MilestoneUncheckedCreateWithoutStoreInput = {
    id?: string
    name: string
    type: string
    date: Date | string
    status: string
  }

  export type MilestoneCreateOrConnectWithoutStoreInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutStoreInput, MilestoneUncheckedCreateWithoutStoreInput>
  }

  export type IssueCreateWithoutStoreInput = {
    id?: string
    title: string
    severity: string
    status: string
    mitigation?: string | null
  }

  export type IssueUncheckedCreateWithoutStoreInput = {
    id?: string
    title: string
    severity: string
    status: string
    mitigation?: string | null
  }

  export type IssueCreateOrConnectWithoutStoreInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutStoreInput, IssueUncheckedCreateWithoutStoreInput>
  }

  export type DocumentCreateWithoutStoreInput = {
    id?: string
    name: string
    url: string
    type: string
  }

  export type DocumentUncheckedCreateWithoutStoreInput = {
    id?: string
    name: string
    url: string
    type: string
  }

  export type DocumentCreateOrConnectWithoutStoreInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutStoreInput, DocumentUncheckedCreateWithoutStoreInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutStoreInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutStoreInput, TaskUncheckedUpdateWithoutStoreInput>
    create: XOR<TaskCreateWithoutStoreInput, TaskUncheckedCreateWithoutStoreInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutStoreInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutStoreInput, TaskUncheckedUpdateWithoutStoreInput>
  }

  export type TaskUpdateManyWithWhereWithoutStoreInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutStoreInput>
  }

  export type MilestoneUpsertWithWhereUniqueWithoutStoreInput = {
    where: MilestoneWhereUniqueInput
    update: XOR<MilestoneUpdateWithoutStoreInput, MilestoneUncheckedUpdateWithoutStoreInput>
    create: XOR<MilestoneCreateWithoutStoreInput, MilestoneUncheckedCreateWithoutStoreInput>
  }

  export type MilestoneUpdateWithWhereUniqueWithoutStoreInput = {
    where: MilestoneWhereUniqueInput
    data: XOR<MilestoneUpdateWithoutStoreInput, MilestoneUncheckedUpdateWithoutStoreInput>
  }

  export type MilestoneUpdateManyWithWhereWithoutStoreInput = {
    where: MilestoneScalarWhereInput
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyWithoutStoreInput>
  }

  export type MilestoneScalarWhereInput = {
    AND?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    OR?: MilestoneScalarWhereInput[]
    NOT?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    id?: StringFilter<"Milestone"> | string
    store_id?: StringFilter<"Milestone"> | string
    name?: StringFilter<"Milestone"> | string
    type?: StringFilter<"Milestone"> | string
    date?: DateTimeFilter<"Milestone"> | Date | string
    status?: StringFilter<"Milestone"> | string
  }

  export type IssueUpsertWithWhereUniqueWithoutStoreInput = {
    where: IssueWhereUniqueInput
    update: XOR<IssueUpdateWithoutStoreInput, IssueUncheckedUpdateWithoutStoreInput>
    create: XOR<IssueCreateWithoutStoreInput, IssueUncheckedCreateWithoutStoreInput>
  }

  export type IssueUpdateWithWhereUniqueWithoutStoreInput = {
    where: IssueWhereUniqueInput
    data: XOR<IssueUpdateWithoutStoreInput, IssueUncheckedUpdateWithoutStoreInput>
  }

  export type IssueUpdateManyWithWhereWithoutStoreInput = {
    where: IssueScalarWhereInput
    data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyWithoutStoreInput>
  }

  export type IssueScalarWhereInput = {
    AND?: IssueScalarWhereInput | IssueScalarWhereInput[]
    OR?: IssueScalarWhereInput[]
    NOT?: IssueScalarWhereInput | IssueScalarWhereInput[]
    id?: StringFilter<"Issue"> | string
    store_id?: StringFilter<"Issue"> | string
    title?: StringFilter<"Issue"> | string
    severity?: StringFilter<"Issue"> | string
    status?: StringFilter<"Issue"> | string
    mitigation?: StringNullableFilter<"Issue"> | string | null
  }

  export type DocumentUpsertWithWhereUniqueWithoutStoreInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutStoreInput, DocumentUncheckedUpdateWithoutStoreInput>
    create: XOR<DocumentCreateWithoutStoreInput, DocumentUncheckedCreateWithoutStoreInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutStoreInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutStoreInput, DocumentUncheckedUpdateWithoutStoreInput>
  }

  export type DocumentUpdateManyWithWhereWithoutStoreInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutStoreInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    store_id?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
  }

  export type TemplatePhaseCreateWithoutTemplateInput = {
    id?: string
    name: string
    order: number
    tasks?: TemplateTaskCreateNestedManyWithoutPhaseInput
  }

  export type TemplatePhaseUncheckedCreateWithoutTemplateInput = {
    id?: string
    name: string
    order: number
    tasks?: TemplateTaskUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type TemplatePhaseCreateOrConnectWithoutTemplateInput = {
    where: TemplatePhaseWhereUniqueInput
    create: XOR<TemplatePhaseCreateWithoutTemplateInput, TemplatePhaseUncheckedCreateWithoutTemplateInput>
  }

  export type TemplatePhaseUpsertWithWhereUniqueWithoutTemplateInput = {
    where: TemplatePhaseWhereUniqueInput
    update: XOR<TemplatePhaseUpdateWithoutTemplateInput, TemplatePhaseUncheckedUpdateWithoutTemplateInput>
    create: XOR<TemplatePhaseCreateWithoutTemplateInput, TemplatePhaseUncheckedCreateWithoutTemplateInput>
  }

  export type TemplatePhaseUpdateWithWhereUniqueWithoutTemplateInput = {
    where: TemplatePhaseWhereUniqueInput
    data: XOR<TemplatePhaseUpdateWithoutTemplateInput, TemplatePhaseUncheckedUpdateWithoutTemplateInput>
  }

  export type TemplatePhaseUpdateManyWithWhereWithoutTemplateInput = {
    where: TemplatePhaseScalarWhereInput
    data: XOR<TemplatePhaseUpdateManyMutationInput, TemplatePhaseUncheckedUpdateManyWithoutTemplateInput>
  }

  export type TemplatePhaseScalarWhereInput = {
    AND?: TemplatePhaseScalarWhereInput | TemplatePhaseScalarWhereInput[]
    OR?: TemplatePhaseScalarWhereInput[]
    NOT?: TemplatePhaseScalarWhereInput | TemplatePhaseScalarWhereInput[]
    id?: StringFilter<"TemplatePhase"> | string
    template_id?: StringFilter<"TemplatePhase"> | string
    name?: StringFilter<"TemplatePhase"> | string
    order?: IntFilter<"TemplatePhase"> | number
  }

  export type TemplateCreateWithoutPhasesInput = {
    id?: string
    name: string
    version: string
    is_active?: boolean
    created_at?: Date | string
  }

  export type TemplateUncheckedCreateWithoutPhasesInput = {
    id?: string
    name: string
    version: string
    is_active?: boolean
    created_at?: Date | string
  }

  export type TemplateCreateOrConnectWithoutPhasesInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutPhasesInput, TemplateUncheckedCreateWithoutPhasesInput>
  }

  export type TemplateTaskCreateWithoutPhaseInput = {
    id?: string
    name: string
    description?: string | null
    role_responsible: string
    duration_days: number
    anchor_event: string
    offset_days: number
    workday_rule?: string
    is_milestone?: boolean
    dependency_indices?: string | null
  }

  export type TemplateTaskUncheckedCreateWithoutPhaseInput = {
    id?: string
    name: string
    description?: string | null
    role_responsible: string
    duration_days: number
    anchor_event: string
    offset_days: number
    workday_rule?: string
    is_milestone?: boolean
    dependency_indices?: string | null
  }

  export type TemplateTaskCreateOrConnectWithoutPhaseInput = {
    where: TemplateTaskWhereUniqueInput
    create: XOR<TemplateTaskCreateWithoutPhaseInput, TemplateTaskUncheckedCreateWithoutPhaseInput>
  }

  export type TemplateUpsertWithoutPhasesInput = {
    update: XOR<TemplateUpdateWithoutPhasesInput, TemplateUncheckedUpdateWithoutPhasesInput>
    create: XOR<TemplateCreateWithoutPhasesInput, TemplateUncheckedCreateWithoutPhasesInput>
    where?: TemplateWhereInput
  }

  export type TemplateUpdateToOneWithWhereWithoutPhasesInput = {
    where?: TemplateWhereInput
    data: XOR<TemplateUpdateWithoutPhasesInput, TemplateUncheckedUpdateWithoutPhasesInput>
  }

  export type TemplateUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateTaskUpsertWithWhereUniqueWithoutPhaseInput = {
    where: TemplateTaskWhereUniqueInput
    update: XOR<TemplateTaskUpdateWithoutPhaseInput, TemplateTaskUncheckedUpdateWithoutPhaseInput>
    create: XOR<TemplateTaskCreateWithoutPhaseInput, TemplateTaskUncheckedCreateWithoutPhaseInput>
  }

  export type TemplateTaskUpdateWithWhereUniqueWithoutPhaseInput = {
    where: TemplateTaskWhereUniqueInput
    data: XOR<TemplateTaskUpdateWithoutPhaseInput, TemplateTaskUncheckedUpdateWithoutPhaseInput>
  }

  export type TemplateTaskUpdateManyWithWhereWithoutPhaseInput = {
    where: TemplateTaskScalarWhereInput
    data: XOR<TemplateTaskUpdateManyMutationInput, TemplateTaskUncheckedUpdateManyWithoutPhaseInput>
  }

  export type TemplateTaskScalarWhereInput = {
    AND?: TemplateTaskScalarWhereInput | TemplateTaskScalarWhereInput[]
    OR?: TemplateTaskScalarWhereInput[]
    NOT?: TemplateTaskScalarWhereInput | TemplateTaskScalarWhereInput[]
    id?: StringFilter<"TemplateTask"> | string
    phase_id?: StringFilter<"TemplateTask"> | string
    name?: StringFilter<"TemplateTask"> | string
    description?: StringNullableFilter<"TemplateTask"> | string | null
    role_responsible?: StringFilter<"TemplateTask"> | string
    duration_days?: IntFilter<"TemplateTask"> | number
    anchor_event?: StringFilter<"TemplateTask"> | string
    offset_days?: IntFilter<"TemplateTask"> | number
    workday_rule?: StringFilter<"TemplateTask"> | string
    is_milestone?: BoolFilter<"TemplateTask"> | boolean
    dependency_indices?: StringNullableFilter<"TemplateTask"> | string | null
  }

  export type TemplatePhaseCreateWithoutTasksInput = {
    id?: string
    name: string
    order: number
    template: TemplateCreateNestedOneWithoutPhasesInput
  }

  export type TemplatePhaseUncheckedCreateWithoutTasksInput = {
    id?: string
    template_id: string
    name: string
    order: number
  }

  export type TemplatePhaseCreateOrConnectWithoutTasksInput = {
    where: TemplatePhaseWhereUniqueInput
    create: XOR<TemplatePhaseCreateWithoutTasksInput, TemplatePhaseUncheckedCreateWithoutTasksInput>
  }

  export type TemplatePhaseUpsertWithoutTasksInput = {
    update: XOR<TemplatePhaseUpdateWithoutTasksInput, TemplatePhaseUncheckedUpdateWithoutTasksInput>
    create: XOR<TemplatePhaseCreateWithoutTasksInput, TemplatePhaseUncheckedCreateWithoutTasksInput>
    where?: TemplatePhaseWhereInput
  }

  export type TemplatePhaseUpdateToOneWithWhereWithoutTasksInput = {
    where?: TemplatePhaseWhereInput
    data: XOR<TemplatePhaseUpdateWithoutTasksInput, TemplatePhaseUncheckedUpdateWithoutTasksInput>
  }

  export type TemplatePhaseUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    template?: TemplateUpdateOneRequiredWithoutPhasesNestedInput
  }

  export type TemplatePhaseUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    template_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutTasks_ownedInput = {
    id?: string
    email: string
    name?: string | null
    password_hash: string
    role: string
    created_at?: Date | string
    tasks_collaborating?: TaskCreateNestedManyWithoutCollaboratorsInput
    audit_logs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasks_ownedInput = {
    id?: string
    email: string
    name?: string | null
    password_hash: string
    role: string
    created_at?: Date | string
    tasks_collaborating?: TaskUncheckedCreateNestedManyWithoutCollaboratorsInput
    audit_logs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasks_ownedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasks_ownedInput, UserUncheckedCreateWithoutTasks_ownedInput>
  }

  export type StoreCreateWithoutTasksInput = {
    id?: string
    name: string
    country: string
    city: string
    address?: string | null
    timezone: string
    status: string
    planned_open_date?: Date | string | null
    actual_open_date?: Date | string | null
    contract_signed_date?: Date | string | null
    template_version: string
    created_at?: Date | string
    updated_at?: Date | string
    milestones?: MilestoneCreateNestedManyWithoutStoreInput
    issues?: IssueCreateNestedManyWithoutStoreInput
    documents?: DocumentCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    country: string
    city: string
    address?: string | null
    timezone: string
    status: string
    planned_open_date?: Date | string | null
    actual_open_date?: Date | string | null
    contract_signed_date?: Date | string | null
    template_version: string
    created_at?: Date | string
    updated_at?: Date | string
    milestones?: MilestoneUncheckedCreateNestedManyWithoutStoreInput
    issues?: IssueUncheckedCreateNestedManyWithoutStoreInput
    documents?: DocumentUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutTasksInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutTasksInput, StoreUncheckedCreateWithoutTasksInput>
  }

  export type TaskDependencyCreateWithoutTaskInput = {
    depends_on: TaskCreateNestedOneWithoutDependentsInput
  }

  export type TaskDependencyUncheckedCreateWithoutTaskInput = {
    depends_on_id: string
  }

  export type TaskDependencyCreateOrConnectWithoutTaskInput = {
    where: TaskDependencyWhereUniqueInput
    create: XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput>
  }

  export type TaskDependencyCreateWithoutDepends_onInput = {
    task: TaskCreateNestedOneWithoutDependenciesInput
  }

  export type TaskDependencyUncheckedCreateWithoutDepends_onInput = {
    task_id: string
  }

  export type TaskDependencyCreateOrConnectWithoutDepends_onInput = {
    where: TaskDependencyWhereUniqueInput
    create: XOR<TaskDependencyCreateWithoutDepends_onInput, TaskDependencyUncheckedCreateWithoutDepends_onInput>
  }

  export type UserCreateWithoutTasks_collaboratingInput = {
    id?: string
    email: string
    name?: string | null
    password_hash: string
    role: string
    created_at?: Date | string
    tasks_owned?: TaskCreateNestedManyWithoutOwnerInput
    audit_logs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasks_collaboratingInput = {
    id?: string
    email: string
    name?: string | null
    password_hash: string
    role: string
    created_at?: Date | string
    tasks_owned?: TaskUncheckedCreateNestedManyWithoutOwnerInput
    audit_logs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasks_collaboratingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasks_collaboratingInput, UserUncheckedCreateWithoutTasks_collaboratingInput>
  }

  export type UserUpsertWithoutTasks_ownedInput = {
    update: XOR<UserUpdateWithoutTasks_ownedInput, UserUncheckedUpdateWithoutTasks_ownedInput>
    create: XOR<UserCreateWithoutTasks_ownedInput, UserUncheckedCreateWithoutTasks_ownedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasks_ownedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasks_ownedInput, UserUncheckedUpdateWithoutTasks_ownedInput>
  }

  export type UserUpdateWithoutTasks_ownedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks_collaborating?: TaskUpdateManyWithoutCollaboratorsNestedInput
    audit_logs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasks_ownedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks_collaborating?: TaskUncheckedUpdateManyWithoutCollaboratorsNestedInput
    audit_logs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StoreUpsertWithoutTasksInput = {
    update: XOR<StoreUpdateWithoutTasksInput, StoreUncheckedUpdateWithoutTasksInput>
    create: XOR<StoreCreateWithoutTasksInput, StoreUncheckedCreateWithoutTasksInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutTasksInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutTasksInput, StoreUncheckedUpdateWithoutTasksInput>
  }

  export type StoreUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planned_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_signed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_version?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: MilestoneUpdateManyWithoutStoreNestedInput
    issues?: IssueUpdateManyWithoutStoreNestedInput
    documents?: DocumentUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planned_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_signed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_version?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: MilestoneUncheckedUpdateManyWithoutStoreNestedInput
    issues?: IssueUncheckedUpdateManyWithoutStoreNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type TaskDependencyUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskDependencyWhereUniqueInput
    update: XOR<TaskDependencyUpdateWithoutTaskInput, TaskDependencyUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput>
  }

  export type TaskDependencyUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskDependencyWhereUniqueInput
    data: XOR<TaskDependencyUpdateWithoutTaskInput, TaskDependencyUncheckedUpdateWithoutTaskInput>
  }

  export type TaskDependencyUpdateManyWithWhereWithoutTaskInput = {
    where: TaskDependencyScalarWhereInput
    data: XOR<TaskDependencyUpdateManyMutationInput, TaskDependencyUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskDependencyScalarWhereInput = {
    AND?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
    OR?: TaskDependencyScalarWhereInput[]
    NOT?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
    task_id?: StringFilter<"TaskDependency"> | string
    depends_on_id?: StringFilter<"TaskDependency"> | string
  }

  export type TaskDependencyUpsertWithWhereUniqueWithoutDepends_onInput = {
    where: TaskDependencyWhereUniqueInput
    update: XOR<TaskDependencyUpdateWithoutDepends_onInput, TaskDependencyUncheckedUpdateWithoutDepends_onInput>
    create: XOR<TaskDependencyCreateWithoutDepends_onInput, TaskDependencyUncheckedCreateWithoutDepends_onInput>
  }

  export type TaskDependencyUpdateWithWhereUniqueWithoutDepends_onInput = {
    where: TaskDependencyWhereUniqueInput
    data: XOR<TaskDependencyUpdateWithoutDepends_onInput, TaskDependencyUncheckedUpdateWithoutDepends_onInput>
  }

  export type TaskDependencyUpdateManyWithWhereWithoutDepends_onInput = {
    where: TaskDependencyScalarWhereInput
    data: XOR<TaskDependencyUpdateManyMutationInput, TaskDependencyUncheckedUpdateManyWithoutDepends_onInput>
  }

  export type UserUpsertWithWhereUniqueWithoutTasks_collaboratingInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTasks_collaboratingInput, UserUncheckedUpdateWithoutTasks_collaboratingInput>
    create: XOR<UserCreateWithoutTasks_collaboratingInput, UserUncheckedCreateWithoutTasks_collaboratingInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTasks_collaboratingInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTasks_collaboratingInput, UserUncheckedUpdateWithoutTasks_collaboratingInput>
  }

  export type UserUpdateManyWithWhereWithoutTasks_collaboratingInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTasks_collaboratingInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    password_hash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    created_at?: DateTimeFilter<"User"> | Date | string
  }

  export type TaskCreateWithoutDependenciesInput = {
    id?: string
    title: string
    description?: string | null
    phase: string
    status: string
    priority?: string
    start_date?: Date | string | null
    due_date?: Date | string | null
    completed_at?: Date | string | null
    role?: string | null
    manual_override?: boolean
    locked?: boolean
    reschedule_mode?: string
    calendar_rule?: string
    anchor?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    owner?: UserCreateNestedOneWithoutTasks_ownedInput
    store: StoreCreateNestedOneWithoutTasksInput
    dependents?: TaskDependencyCreateNestedManyWithoutDepends_onInput
    collaborators?: UserCreateNestedManyWithoutTasks_collaboratingInput
  }

  export type TaskUncheckedCreateWithoutDependenciesInput = {
    id?: string
    store_id: string
    title: string
    description?: string | null
    phase: string
    status: string
    priority?: string
    start_date?: Date | string | null
    due_date?: Date | string | null
    completed_at?: Date | string | null
    role?: string | null
    manual_override?: boolean
    locked?: boolean
    reschedule_mode?: string
    calendar_rule?: string
    anchor?: string | null
    owner_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDepends_onInput
    collaborators?: UserUncheckedCreateNestedManyWithoutTasks_collaboratingInput
  }

  export type TaskCreateOrConnectWithoutDependenciesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>
  }

  export type TaskCreateWithoutDependentsInput = {
    id?: string
    title: string
    description?: string | null
    phase: string
    status: string
    priority?: string
    start_date?: Date | string | null
    due_date?: Date | string | null
    completed_at?: Date | string | null
    role?: string | null
    manual_override?: boolean
    locked?: boolean
    reschedule_mode?: string
    calendar_rule?: string
    anchor?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    owner?: UserCreateNestedOneWithoutTasks_ownedInput
    store: StoreCreateNestedOneWithoutTasksInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    collaborators?: UserCreateNestedManyWithoutTasks_collaboratingInput
  }

  export type TaskUncheckedCreateWithoutDependentsInput = {
    id?: string
    store_id: string
    title: string
    description?: string | null
    phase: string
    status: string
    priority?: string
    start_date?: Date | string | null
    due_date?: Date | string | null
    completed_at?: Date | string | null
    role?: string | null
    manual_override?: boolean
    locked?: boolean
    reschedule_mode?: string
    calendar_rule?: string
    anchor?: string | null
    owner_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    collaborators?: UserUncheckedCreateNestedManyWithoutTasks_collaboratingInput
  }

  export type TaskCreateOrConnectWithoutDependentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
  }

  export type TaskUpsertWithoutDependenciesInput = {
    update: XOR<TaskUpdateWithoutDependenciesInput, TaskUncheckedUpdateWithoutDependenciesInput>
    create: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutDependenciesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutDependenciesInput, TaskUncheckedUpdateWithoutDependenciesInput>
  }

  export type TaskUpdateWithoutDependenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutTasks_ownedNestedInput
    store?: StoreUpdateOneRequiredWithoutTasksNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDepends_onNestedInput
    collaborators?: UserUpdateManyWithoutTasks_collaboratingNestedInput
  }

  export type TaskUncheckedUpdateWithoutDependenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    store_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDepends_onNestedInput
    collaborators?: UserUncheckedUpdateManyWithoutTasks_collaboratingNestedInput
  }

  export type TaskUpsertWithoutDependentsInput = {
    update: XOR<TaskUpdateWithoutDependentsInput, TaskUncheckedUpdateWithoutDependentsInput>
    create: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutDependentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutDependentsInput, TaskUncheckedUpdateWithoutDependentsInput>
  }

  export type TaskUpdateWithoutDependentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutTasks_ownedNestedInput
    store?: StoreUpdateOneRequiredWithoutTasksNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    collaborators?: UserUpdateManyWithoutTasks_collaboratingNestedInput
  }

  export type TaskUncheckedUpdateWithoutDependentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    store_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    collaborators?: UserUncheckedUpdateManyWithoutTasks_collaboratingNestedInput
  }

  export type StoreCreateWithoutMilestonesInput = {
    id?: string
    name: string
    country: string
    city: string
    address?: string | null
    timezone: string
    status: string
    planned_open_date?: Date | string | null
    actual_open_date?: Date | string | null
    contract_signed_date?: Date | string | null
    template_version: string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskCreateNestedManyWithoutStoreInput
    issues?: IssueCreateNestedManyWithoutStoreInput
    documents?: DocumentCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutMilestonesInput = {
    id?: string
    name: string
    country: string
    city: string
    address?: string | null
    timezone: string
    status: string
    planned_open_date?: Date | string | null
    actual_open_date?: Date | string | null
    contract_signed_date?: Date | string | null
    template_version: string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutStoreInput
    issues?: IssueUncheckedCreateNestedManyWithoutStoreInput
    documents?: DocumentUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutMilestonesInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutMilestonesInput, StoreUncheckedCreateWithoutMilestonesInput>
  }

  export type StoreUpsertWithoutMilestonesInput = {
    update: XOR<StoreUpdateWithoutMilestonesInput, StoreUncheckedUpdateWithoutMilestonesInput>
    create: XOR<StoreCreateWithoutMilestonesInput, StoreUncheckedCreateWithoutMilestonesInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutMilestonesInput, StoreUncheckedUpdateWithoutMilestonesInput>
  }

  export type StoreUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planned_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_signed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_version?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutStoreNestedInput
    issues?: IssueUpdateManyWithoutStoreNestedInput
    documents?: DocumentUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planned_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_signed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_version?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutStoreNestedInput
    issues?: IssueUncheckedUpdateManyWithoutStoreNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreCreateWithoutIssuesInput = {
    id?: string
    name: string
    country: string
    city: string
    address?: string | null
    timezone: string
    status: string
    planned_open_date?: Date | string | null
    actual_open_date?: Date | string | null
    contract_signed_date?: Date | string | null
    template_version: string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskCreateNestedManyWithoutStoreInput
    milestones?: MilestoneCreateNestedManyWithoutStoreInput
    documents?: DocumentCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutIssuesInput = {
    id?: string
    name: string
    country: string
    city: string
    address?: string | null
    timezone: string
    status: string
    planned_open_date?: Date | string | null
    actual_open_date?: Date | string | null
    contract_signed_date?: Date | string | null
    template_version: string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutStoreInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutStoreInput
    documents?: DocumentUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutIssuesInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutIssuesInput, StoreUncheckedCreateWithoutIssuesInput>
  }

  export type StoreUpsertWithoutIssuesInput = {
    update: XOR<StoreUpdateWithoutIssuesInput, StoreUncheckedUpdateWithoutIssuesInput>
    create: XOR<StoreCreateWithoutIssuesInput, StoreUncheckedCreateWithoutIssuesInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutIssuesInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutIssuesInput, StoreUncheckedUpdateWithoutIssuesInput>
  }

  export type StoreUpdateWithoutIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planned_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_signed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_version?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutStoreNestedInput
    milestones?: MilestoneUpdateManyWithoutStoreNestedInput
    documents?: DocumentUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planned_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_signed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_version?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutStoreNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutStoreNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreCreateWithoutDocumentsInput = {
    id?: string
    name: string
    country: string
    city: string
    address?: string | null
    timezone: string
    status: string
    planned_open_date?: Date | string | null
    actual_open_date?: Date | string | null
    contract_signed_date?: Date | string | null
    template_version: string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskCreateNestedManyWithoutStoreInput
    milestones?: MilestoneCreateNestedManyWithoutStoreInput
    issues?: IssueCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    country: string
    city: string
    address?: string | null
    timezone: string
    status: string
    planned_open_date?: Date | string | null
    actual_open_date?: Date | string | null
    contract_signed_date?: Date | string | null
    template_version: string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutStoreInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutStoreInput
    issues?: IssueUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutDocumentsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutDocumentsInput, StoreUncheckedCreateWithoutDocumentsInput>
  }

  export type StoreUpsertWithoutDocumentsInput = {
    update: XOR<StoreUpdateWithoutDocumentsInput, StoreUncheckedUpdateWithoutDocumentsInput>
    create: XOR<StoreCreateWithoutDocumentsInput, StoreUncheckedCreateWithoutDocumentsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutDocumentsInput, StoreUncheckedUpdateWithoutDocumentsInput>
  }

  export type StoreUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planned_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_signed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_version?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutStoreNestedInput
    milestones?: MilestoneUpdateManyWithoutStoreNestedInput
    issues?: IssueUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planned_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_open_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contract_signed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_version?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutStoreNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutStoreNestedInput
    issues?: IssueUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type GroceryPriceCreateWithoutIngredientInput = {
    id?: string
    country: string
    retailer: string
    package_size: number
    package_unit: string
    price: number
    currency: string
    normalized_price_per_unit: number
    as_of: Date | string
    source_url?: string | null
    history?: PriceHistoryCreateNestedManyWithoutGrocery_priceInput
  }

  export type GroceryPriceUncheckedCreateWithoutIngredientInput = {
    id?: string
    country: string
    retailer: string
    package_size: number
    package_unit: string
    price: number
    currency: string
    normalized_price_per_unit: number
    as_of: Date | string
    source_url?: string | null
    history?: PriceHistoryUncheckedCreateNestedManyWithoutGrocery_priceInput
  }

  export type GroceryPriceCreateOrConnectWithoutIngredientInput = {
    where: GroceryPriceWhereUniqueInput
    create: XOR<GroceryPriceCreateWithoutIngredientInput, GroceryPriceUncheckedCreateWithoutIngredientInput>
  }

  export type RecipeLineCreateWithoutIngredientInput = {
    id?: string
    quantity: number
    unit: string
    recipe: RecipeCreateNestedOneWithoutLinesInput
  }

  export type RecipeLineUncheckedCreateWithoutIngredientInput = {
    id?: string
    recipe_id: string
    quantity: number
    unit: string
  }

  export type RecipeLineCreateOrConnectWithoutIngredientInput = {
    where: RecipeLineWhereUniqueInput
    create: XOR<RecipeLineCreateWithoutIngredientInput, RecipeLineUncheckedCreateWithoutIngredientInput>
  }

  export type GroceryPriceUpsertWithWhereUniqueWithoutIngredientInput = {
    where: GroceryPriceWhereUniqueInput
    update: XOR<GroceryPriceUpdateWithoutIngredientInput, GroceryPriceUncheckedUpdateWithoutIngredientInput>
    create: XOR<GroceryPriceCreateWithoutIngredientInput, GroceryPriceUncheckedCreateWithoutIngredientInput>
  }

  export type GroceryPriceUpdateWithWhereUniqueWithoutIngredientInput = {
    where: GroceryPriceWhereUniqueInput
    data: XOR<GroceryPriceUpdateWithoutIngredientInput, GroceryPriceUncheckedUpdateWithoutIngredientInput>
  }

  export type GroceryPriceUpdateManyWithWhereWithoutIngredientInput = {
    where: GroceryPriceScalarWhereInput
    data: XOR<GroceryPriceUpdateManyMutationInput, GroceryPriceUncheckedUpdateManyWithoutIngredientInput>
  }

  export type GroceryPriceScalarWhereInput = {
    AND?: GroceryPriceScalarWhereInput | GroceryPriceScalarWhereInput[]
    OR?: GroceryPriceScalarWhereInput[]
    NOT?: GroceryPriceScalarWhereInput | GroceryPriceScalarWhereInput[]
    id?: StringFilter<"GroceryPrice"> | string
    country?: StringFilter<"GroceryPrice"> | string
    retailer?: StringFilter<"GroceryPrice"> | string
    ingredient_id?: StringFilter<"GroceryPrice"> | string
    package_size?: FloatFilter<"GroceryPrice"> | number
    package_unit?: StringFilter<"GroceryPrice"> | string
    price?: FloatFilter<"GroceryPrice"> | number
    currency?: StringFilter<"GroceryPrice"> | string
    normalized_price_per_unit?: FloatFilter<"GroceryPrice"> | number
    as_of?: DateTimeFilter<"GroceryPrice"> | Date | string
    source_url?: StringNullableFilter<"GroceryPrice"> | string | null
  }

  export type RecipeLineUpsertWithWhereUniqueWithoutIngredientInput = {
    where: RecipeLineWhereUniqueInput
    update: XOR<RecipeLineUpdateWithoutIngredientInput, RecipeLineUncheckedUpdateWithoutIngredientInput>
    create: XOR<RecipeLineCreateWithoutIngredientInput, RecipeLineUncheckedCreateWithoutIngredientInput>
  }

  export type RecipeLineUpdateWithWhereUniqueWithoutIngredientInput = {
    where: RecipeLineWhereUniqueInput
    data: XOR<RecipeLineUpdateWithoutIngredientInput, RecipeLineUncheckedUpdateWithoutIngredientInput>
  }

  export type RecipeLineUpdateManyWithWhereWithoutIngredientInput = {
    where: RecipeLineScalarWhereInput
    data: XOR<RecipeLineUpdateManyMutationInput, RecipeLineUncheckedUpdateManyWithoutIngredientInput>
  }

  export type RecipeLineScalarWhereInput = {
    AND?: RecipeLineScalarWhereInput | RecipeLineScalarWhereInput[]
    OR?: RecipeLineScalarWhereInput[]
    NOT?: RecipeLineScalarWhereInput | RecipeLineScalarWhereInput[]
    id?: StringFilter<"RecipeLine"> | string
    recipe_id?: StringFilter<"RecipeLine"> | string
    ingredient_id?: StringFilter<"RecipeLine"> | string
    quantity?: FloatFilter<"RecipeLine"> | number
    unit?: StringFilter<"RecipeLine"> | string
  }

  export type IngredientCreateWithoutPricesInput = {
    id?: string
    name: string
    unit_type: string
    category?: string | null
    recipe_lines?: RecipeLineCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutPricesInput = {
    id?: string
    name: string
    unit_type: string
    category?: string | null
    recipe_lines?: RecipeLineUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutPricesInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutPricesInput, IngredientUncheckedCreateWithoutPricesInput>
  }

  export type PriceHistoryCreateWithoutGrocery_priceInput = {
    id?: string
    price: number
    changed_at?: Date | string
    changed_by?: string | null
    reason?: string | null
  }

  export type PriceHistoryUncheckedCreateWithoutGrocery_priceInput = {
    id?: string
    price: number
    changed_at?: Date | string
    changed_by?: string | null
    reason?: string | null
  }

  export type PriceHistoryCreateOrConnectWithoutGrocery_priceInput = {
    where: PriceHistoryWhereUniqueInput
    create: XOR<PriceHistoryCreateWithoutGrocery_priceInput, PriceHistoryUncheckedCreateWithoutGrocery_priceInput>
  }

  export type IngredientUpsertWithoutPricesInput = {
    update: XOR<IngredientUpdateWithoutPricesInput, IngredientUncheckedUpdateWithoutPricesInput>
    create: XOR<IngredientCreateWithoutPricesInput, IngredientUncheckedCreateWithoutPricesInput>
    where?: IngredientWhereInput
  }

  export type IngredientUpdateToOneWithWhereWithoutPricesInput = {
    where?: IngredientWhereInput
    data: XOR<IngredientUpdateWithoutPricesInput, IngredientUncheckedUpdateWithoutPricesInput>
  }

  export type IngredientUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit_type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    recipe_lines?: RecipeLineUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit_type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    recipe_lines?: RecipeLineUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type PriceHistoryUpsertWithWhereUniqueWithoutGrocery_priceInput = {
    where: PriceHistoryWhereUniqueInput
    update: XOR<PriceHistoryUpdateWithoutGrocery_priceInput, PriceHistoryUncheckedUpdateWithoutGrocery_priceInput>
    create: XOR<PriceHistoryCreateWithoutGrocery_priceInput, PriceHistoryUncheckedCreateWithoutGrocery_priceInput>
  }

  export type PriceHistoryUpdateWithWhereUniqueWithoutGrocery_priceInput = {
    where: PriceHistoryWhereUniqueInput
    data: XOR<PriceHistoryUpdateWithoutGrocery_priceInput, PriceHistoryUncheckedUpdateWithoutGrocery_priceInput>
  }

  export type PriceHistoryUpdateManyWithWhereWithoutGrocery_priceInput = {
    where: PriceHistoryScalarWhereInput
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyWithoutGrocery_priceInput>
  }

  export type PriceHistoryScalarWhereInput = {
    AND?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
    OR?: PriceHistoryScalarWhereInput[]
    NOT?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
    id?: StringFilter<"PriceHistory"> | string
    grocery_price_id?: StringFilter<"PriceHistory"> | string
    price?: FloatFilter<"PriceHistory"> | number
    changed_at?: DateTimeFilter<"PriceHistory"> | Date | string
    changed_by?: StringNullableFilter<"PriceHistory"> | string | null
    reason?: StringNullableFilter<"PriceHistory"> | string | null
  }

  export type GroceryPriceCreateWithoutHistoryInput = {
    id?: string
    country: string
    retailer: string
    package_size: number
    package_unit: string
    price: number
    currency: string
    normalized_price_per_unit: number
    as_of: Date | string
    source_url?: string | null
    ingredient: IngredientCreateNestedOneWithoutPricesInput
  }

  export type GroceryPriceUncheckedCreateWithoutHistoryInput = {
    id?: string
    country: string
    retailer: string
    ingredient_id: string
    package_size: number
    package_unit: string
    price: number
    currency: string
    normalized_price_per_unit: number
    as_of: Date | string
    source_url?: string | null
  }

  export type GroceryPriceCreateOrConnectWithoutHistoryInput = {
    where: GroceryPriceWhereUniqueInput
    create: XOR<GroceryPriceCreateWithoutHistoryInput, GroceryPriceUncheckedCreateWithoutHistoryInput>
  }

  export type GroceryPriceUpsertWithoutHistoryInput = {
    update: XOR<GroceryPriceUpdateWithoutHistoryInput, GroceryPriceUncheckedUpdateWithoutHistoryInput>
    create: XOR<GroceryPriceCreateWithoutHistoryInput, GroceryPriceUncheckedCreateWithoutHistoryInput>
    where?: GroceryPriceWhereInput
  }

  export type GroceryPriceUpdateToOneWithWhereWithoutHistoryInput = {
    where?: GroceryPriceWhereInput
    data: XOR<GroceryPriceUpdateWithoutHistoryInput, GroceryPriceUncheckedUpdateWithoutHistoryInput>
  }

  export type GroceryPriceUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    retailer?: StringFieldUpdateOperationsInput | string
    package_size?: FloatFieldUpdateOperationsInput | number
    package_unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    normalized_price_per_unit?: FloatFieldUpdateOperationsInput | number
    as_of?: DateTimeFieldUpdateOperationsInput | Date | string
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    ingredient?: IngredientUpdateOneRequiredWithoutPricesNestedInput
  }

  export type GroceryPriceUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    retailer?: StringFieldUpdateOperationsInput | string
    ingredient_id?: StringFieldUpdateOperationsInput | string
    package_size?: FloatFieldUpdateOperationsInput | number
    package_unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    normalized_price_per_unit?: FloatFieldUpdateOperationsInput | number
    as_of?: DateTimeFieldUpdateOperationsInput | Date | string
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeLineCreateWithoutRecipeInput = {
    id?: string
    quantity: number
    unit: string
    ingredient: IngredientCreateNestedOneWithoutRecipe_linesInput
  }

  export type RecipeLineUncheckedCreateWithoutRecipeInput = {
    id?: string
    ingredient_id: string
    quantity: number
    unit: string
  }

  export type RecipeLineCreateOrConnectWithoutRecipeInput = {
    where: RecipeLineWhereUniqueInput
    create: XOR<RecipeLineCreateWithoutRecipeInput, RecipeLineUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeLineUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeLineWhereUniqueInput
    update: XOR<RecipeLineUpdateWithoutRecipeInput, RecipeLineUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeLineCreateWithoutRecipeInput, RecipeLineUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeLineUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeLineWhereUniqueInput
    data: XOR<RecipeLineUpdateWithoutRecipeInput, RecipeLineUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeLineUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeLineScalarWhereInput
    data: XOR<RecipeLineUpdateManyMutationInput, RecipeLineUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeCreateWithoutLinesInput = {
    id?: string
    name: string
    menu_item: string
    version: string
    country?: string | null
    yield_count?: number
    target_cost_pct?: number
    manual_price?: number | null
    created_at?: Date | string
  }

  export type RecipeUncheckedCreateWithoutLinesInput = {
    id?: string
    name: string
    menu_item: string
    version: string
    country?: string | null
    yield_count?: number
    target_cost_pct?: number
    manual_price?: number | null
    created_at?: Date | string
  }

  export type RecipeCreateOrConnectWithoutLinesInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutLinesInput, RecipeUncheckedCreateWithoutLinesInput>
  }

  export type IngredientCreateWithoutRecipe_linesInput = {
    id?: string
    name: string
    unit_type: string
    category?: string | null
    prices?: GroceryPriceCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutRecipe_linesInput = {
    id?: string
    name: string
    unit_type: string
    category?: string | null
    prices?: GroceryPriceUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutRecipe_linesInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutRecipe_linesInput, IngredientUncheckedCreateWithoutRecipe_linesInput>
  }

  export type RecipeUpsertWithoutLinesInput = {
    update: XOR<RecipeUpdateWithoutLinesInput, RecipeUncheckedUpdateWithoutLinesInput>
    create: XOR<RecipeCreateWithoutLinesInput, RecipeUncheckedCreateWithoutLinesInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutLinesInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutLinesInput, RecipeUncheckedUpdateWithoutLinesInput>
  }

  export type RecipeUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    menu_item?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    yield_count?: FloatFieldUpdateOperationsInput | number
    target_cost_pct?: FloatFieldUpdateOperationsInput | number
    manual_price?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    menu_item?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    yield_count?: FloatFieldUpdateOperationsInput | number
    target_cost_pct?: FloatFieldUpdateOperationsInput | number
    manual_price?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngredientUpsertWithoutRecipe_linesInput = {
    update: XOR<IngredientUpdateWithoutRecipe_linesInput, IngredientUncheckedUpdateWithoutRecipe_linesInput>
    create: XOR<IngredientCreateWithoutRecipe_linesInput, IngredientUncheckedCreateWithoutRecipe_linesInput>
    where?: IngredientWhereInput
  }

  export type IngredientUpdateToOneWithWhereWithoutRecipe_linesInput = {
    where?: IngredientWhereInput
    data: XOR<IngredientUpdateWithoutRecipe_linesInput, IngredientUncheckedUpdateWithoutRecipe_linesInput>
  }

  export type IngredientUpdateWithoutRecipe_linesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit_type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    prices?: GroceryPriceUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutRecipe_linesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit_type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    prices?: GroceryPriceUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type UserCreateWithoutAudit_logsInput = {
    id?: string
    email: string
    name?: string | null
    password_hash: string
    role: string
    created_at?: Date | string
    tasks_owned?: TaskCreateNestedManyWithoutOwnerInput
    tasks_collaborating?: TaskCreateNestedManyWithoutCollaboratorsInput
  }

  export type UserUncheckedCreateWithoutAudit_logsInput = {
    id?: string
    email: string
    name?: string | null
    password_hash: string
    role: string
    created_at?: Date | string
    tasks_owned?: TaskUncheckedCreateNestedManyWithoutOwnerInput
    tasks_collaborating?: TaskUncheckedCreateNestedManyWithoutCollaboratorsInput
  }

  export type UserCreateOrConnectWithoutAudit_logsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAudit_logsInput, UserUncheckedCreateWithoutAudit_logsInput>
  }

  export type UserUpsertWithoutAudit_logsInput = {
    update: XOR<UserUpdateWithoutAudit_logsInput, UserUncheckedUpdateWithoutAudit_logsInput>
    create: XOR<UserCreateWithoutAudit_logsInput, UserUncheckedCreateWithoutAudit_logsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAudit_logsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAudit_logsInput, UserUncheckedUpdateWithoutAudit_logsInput>
  }

  export type UserUpdateWithoutAudit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks_owned?: TaskUpdateManyWithoutOwnerNestedInput
    tasks_collaborating?: TaskUpdateManyWithoutCollaboratorsNestedInput
  }

  export type UserUncheckedUpdateWithoutAudit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks_owned?: TaskUncheckedUpdateManyWithoutOwnerNestedInput
    tasks_collaborating?: TaskUncheckedUpdateManyWithoutCollaboratorsNestedInput
  }

  export type TaskUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutTasksNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDepends_onNestedInput
    collaborators?: UserUpdateManyWithoutTasks_collaboratingNestedInput
  }

  export type TaskUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    store_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDepends_onNestedInput
    collaborators?: UserUncheckedUpdateManyWithoutTasks_collaboratingNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    store_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutTasks_ownedNestedInput
    store?: StoreUpdateOneRequiredWithoutTasksNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDepends_onNestedInput
  }

  export type TaskUncheckedUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    store_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDepends_onNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    store_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutTasks_ownedNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDepends_onNestedInput
    collaborators?: UserUpdateManyWithoutTasks_collaboratingNestedInput
  }

  export type TaskUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDepends_onNestedInput
    collaborators?: UserUncheckedUpdateManyWithoutTasks_collaboratingNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    manual_override?: BoolFieldUpdateOperationsInput | boolean
    locked?: BoolFieldUpdateOperationsInput | boolean
    reschedule_mode?: StringFieldUpdateOperationsInput | string
    calendar_rule?: StringFieldUpdateOperationsInput | string
    anchor?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MilestoneUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MilestoneUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type IssueUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    mitigation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IssueUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    mitigation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IssueUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    mitigation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type TemplatePhaseUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    tasks?: TemplateTaskUpdateManyWithoutPhaseNestedInput
  }

  export type TemplatePhaseUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    tasks?: TemplateTaskUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type TemplatePhaseUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateTaskUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role_responsible?: StringFieldUpdateOperationsInput | string
    duration_days?: IntFieldUpdateOperationsInput | number
    anchor_event?: StringFieldUpdateOperationsInput | string
    offset_days?: IntFieldUpdateOperationsInput | number
    workday_rule?: StringFieldUpdateOperationsInput | string
    is_milestone?: BoolFieldUpdateOperationsInput | boolean
    dependency_indices?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateTaskUncheckedUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role_responsible?: StringFieldUpdateOperationsInput | string
    duration_days?: IntFieldUpdateOperationsInput | number
    anchor_event?: StringFieldUpdateOperationsInput | string
    offset_days?: IntFieldUpdateOperationsInput | number
    workday_rule?: StringFieldUpdateOperationsInput | string
    is_milestone?: BoolFieldUpdateOperationsInput | boolean
    dependency_indices?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateTaskUncheckedUpdateManyWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    role_responsible?: StringFieldUpdateOperationsInput | string
    duration_days?: IntFieldUpdateOperationsInput | number
    anchor_event?: StringFieldUpdateOperationsInput | string
    offset_days?: IntFieldUpdateOperationsInput | number
    workday_rule?: StringFieldUpdateOperationsInput | string
    is_milestone?: BoolFieldUpdateOperationsInput | boolean
    dependency_indices?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskDependencyUpdateWithoutTaskInput = {
    depends_on?: TaskUpdateOneRequiredWithoutDependentsNestedInput
  }

  export type TaskDependencyUncheckedUpdateWithoutTaskInput = {
    depends_on_id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDependencyUncheckedUpdateManyWithoutTaskInput = {
    depends_on_id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDependencyUpdateWithoutDepends_onInput = {
    task?: TaskUpdateOneRequiredWithoutDependenciesNestedInput
  }

  export type TaskDependencyUncheckedUpdateWithoutDepends_onInput = {
    task_id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDependencyUncheckedUpdateManyWithoutDepends_onInput = {
    task_id?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutTasks_collaboratingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks_owned?: TaskUpdateManyWithoutOwnerNestedInput
    audit_logs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasks_collaboratingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks_owned?: TaskUncheckedUpdateManyWithoutOwnerNestedInput
    audit_logs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTasks_collaboratingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroceryPriceUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    retailer?: StringFieldUpdateOperationsInput | string
    package_size?: FloatFieldUpdateOperationsInput | number
    package_unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    normalized_price_per_unit?: FloatFieldUpdateOperationsInput | number
    as_of?: DateTimeFieldUpdateOperationsInput | Date | string
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    history?: PriceHistoryUpdateManyWithoutGrocery_priceNestedInput
  }

  export type GroceryPriceUncheckedUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    retailer?: StringFieldUpdateOperationsInput | string
    package_size?: FloatFieldUpdateOperationsInput | number
    package_unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    normalized_price_per_unit?: FloatFieldUpdateOperationsInput | number
    as_of?: DateTimeFieldUpdateOperationsInput | Date | string
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    history?: PriceHistoryUncheckedUpdateManyWithoutGrocery_priceNestedInput
  }

  export type GroceryPriceUncheckedUpdateManyWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    retailer?: StringFieldUpdateOperationsInput | string
    package_size?: FloatFieldUpdateOperationsInput | number
    package_unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    normalized_price_per_unit?: FloatFieldUpdateOperationsInput | number
    as_of?: DateTimeFieldUpdateOperationsInput | Date | string
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeLineUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    recipe?: RecipeUpdateOneRequiredWithoutLinesNestedInput
  }

  export type RecipeLineUncheckedUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipe_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeLineUncheckedUpdateManyWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipe_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type PriceHistoryUpdateWithoutGrocery_priceInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    changed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PriceHistoryUncheckedUpdateWithoutGrocery_priceInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    changed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PriceHistoryUncheckedUpdateManyWithoutGrocery_priceInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    changed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    changed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeLineUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    ingredient?: IngredientUpdateOneRequiredWithoutRecipe_linesNestedInput
  }

  export type RecipeLineUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeLineUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreCountOutputTypeDefaultArgs instead
     */
    export type StoreCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateCountOutputTypeDefaultArgs instead
     */
    export type TemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplatePhaseCountOutputTypeDefaultArgs instead
     */
    export type TemplatePhaseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplatePhaseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskCountOutputTypeDefaultArgs instead
     */
    export type TaskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientCountOutputTypeDefaultArgs instead
     */
    export type IngredientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroceryPriceCountOutputTypeDefaultArgs instead
     */
    export type GroceryPriceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroceryPriceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeCountOutputTypeDefaultArgs instead
     */
    export type RecipeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreDefaultArgs instead
     */
    export type StoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateDefaultArgs instead
     */
    export type TemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplatePhaseDefaultArgs instead
     */
    export type TemplatePhaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplatePhaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateTaskDefaultArgs instead
     */
    export type TemplateTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateTaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDependencyDefaultArgs instead
     */
    export type TaskDependencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDependencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MilestoneDefaultArgs instead
     */
    export type MilestoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MilestoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IssueDefaultArgs instead
     */
    export type IssueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IssueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientDefaultArgs instead
     */
    export type IngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroceryPriceDefaultArgs instead
     */
    export type GroceryPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroceryPriceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PriceHistoryDefaultArgs instead
     */
    export type PriceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PriceHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeDefaultArgs instead
     */
    export type RecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeLineDefaultArgs instead
     */
    export type RecipeLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompetitorPriceDefaultArgs instead
     */
    export type CompetitorPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompetitorPriceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FXRateDefaultArgs instead
     */
    export type FXRateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FXRateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationLogDefaultArgs instead
     */
    export type NotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}