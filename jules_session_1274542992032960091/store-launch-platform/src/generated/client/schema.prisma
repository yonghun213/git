// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/client"
}

datasource db {
  provider = "sqlite"
  url      = "file:./store_launch.db"
}

// User & Auth
model User {
  id            String   @id @default(uuid())
  email         String   @unique
  name          String?
  password_hash String
  role          String   // ADMIN, PM, CONTRIBUTOR, VIEWER
  created_at    DateTime @default(now())

  // Relations
  tasks_owned       Task[]        @relation("TaskOwner")
  tasks_collaborating Task[]      @relation("TaskCollaborator") 
  audit_logs        AuditLog[]
}

// Store & Launch Logic
model Store {
  id                String    @id @default(uuid())
  name              String
  country           String    // "MX", "CO", "CA"
  city              String
  address           String?
  timezone          String    // e.g. "America/Mexico_City"
  status            String    // "PLANNING", "ACTIVE", "OPEN", "CANCELLED"
  
  // Anchors - these can be derived or manual. 
  // Milestone table is canonical, but keeping these for easy access is helpful.
  planned_open_date DateTime?
  actual_open_date  DateTime?
  contract_signed_date DateTime?
  
  template_version  String
  
  created_at        DateTime  @default(now())
  updated_at        DateTime  @updatedAt
  
  tasks             Task[]
  milestones        Milestone[]
  issues            Issue[]
  documents         Document[]
}

model Template {
  id          String   @id @default(uuid())
  name        String
  version     String
  is_active   Boolean  @default(true)
  created_at  DateTime @default(now())
  
  phases      TemplatePhase[]
}

model TemplatePhase {
  id          String   @id @default(uuid())
  template_id String
  name        String
  order       Int
  
  template    Template @relation(fields: [template_id], references: [id])
  tasks       TemplateTask[]
}

model TemplateTask {
  id              String   @id @default(uuid())
  phase_id        String
  name            String
  description     String?
  role_responsible String // "PM", "IT", "CONSTRUCTION"
  duration_days   Int
  
  // Scheduling Logic
  anchor_event    String   // "OPEN_DATE", "CONTRACT_SIGNED", "CONSTRUCTION_START", etc.
  offset_days     Int      // Negative = before, Positive = after
  workday_rule    String   @default("CALENDAR_DAYS") // "CALENDAR_DAYS", "BUSINESS_DAYS_MON_FRI"
  is_milestone    Boolean  @default(false)
  
  dependency_indices String? 
  
  phase           TemplatePhase @relation(fields: [phase_id], references: [id])
}

model Task {
  id          String   @id @default(uuid())
  store_id    String
  title       String
  description String?
  phase       String   // Copied from template for easy grouping
  status      String   // "NOT_STARTED", "IN_PROGRESS", "BLOCKED", "DONE"
  priority    String   @default("MEDIUM")
  
  start_date  DateTime?
  due_date    DateTime?
  completed_at DateTime?
  
  role        String?  // "PM", "IT", "CONSTRUCTION", etc.

  // Scheduling & Rescheduling
  manual_override Boolean @default(false)
  locked          Boolean @default(false)
  reschedule_mode String  @default("SHIFT_DOWNSTREAM") // "ONLY_THIS", "SHIFT_DOWNSTREAM", "CUSTOM_SET"
  calendar_rule   String  @default("CALENDAR_DAYS")
  anchor          String? // e.g. "OPEN_DATE", "CONTRACT_SIGNED" - stored for re-baselining
  
  owner_id    String?
  owner       User?    @relation("TaskOwner", fields: [owner_id], references: [id])
  
  store       Store    @relation(fields: [store_id], references: [id])
  
  // Self-relation for dependencies
  dependencies TaskDependency[] @relation("dependency")
  dependents   TaskDependency[] @relation("dependent")
  
  collaborators User[] @relation("TaskCollaborator")

  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt
}

model TaskDependency {
  task_id       String
  depends_on_id String
  
  task          Task @relation("dependency", fields: [task_id], references: [id])
  depends_on    Task @relation("dependent", fields: [depends_on_id], references: [id])

  @@id([task_id, depends_on_id])
}

model Milestone {
  id          String   @id @default(uuid())
  store_id    String
  name        String   // e.g. "Grand Opening"
  type        String   // "OPEN_DATE", "CONTRACT_SIGNED", "CONSTRUCTION_START", "SOFT_OPEN", etc.
  date        DateTime
  status      String   // "PENDING", "ACHIEVED"
  
  store       Store    @relation(fields: [store_id], references: [id])
}

model Issue {
  id          String   @id @default(uuid())
  store_id    String
  title       String
  severity    String   // "LOW", "MEDIUM", "HIGH", "CRITICAL"
  status      String   // "OPEN", "RESOLVED"
  mitigation  String?
  
  store       Store    @relation(fields: [store_id], references: [id])
}

model Document {
  id          String   @id @default(uuid())
  store_id    String
  name        String
  url         String
  type        String   // "DRIVE", "PDF", "LINK"
  
  store       Store    @relation(fields: [store_id], references: [id])
}

// Cost & Pricing Module

model Ingredient {
  id          String   @id @default(uuid())
  name        String
  unit_type   String   // "g", "ml", "unit"
  category    String?
  
  prices      GroceryPrice[]
  recipe_lines RecipeLine[]
}

model GroceryPrice {
  id          String   @id @default(uuid())
  country     String
  retailer    String
  ingredient_id String
  
  package_size Float
  package_unit String // "g", "ml", "kg", "L"
  price        Float
  currency     String
  
  normalized_price_per_unit Float // Calculated field for quick access
  
  as_of       DateTime
  source_url  String?
  
  ingredient  Ingredient @relation(fields: [ingredient_id], references: [id])
  
  history     PriceHistory[]
}

model PriceHistory {
  id              String   @id @default(uuid())
  grocery_price_id String
  price           Float
  changed_at      DateTime @default(now())
  changed_by      String?
  reason          String?
  
  grocery_price   GroceryPrice @relation(fields: [grocery_price_id], references: [id])
}

model Recipe {
  id          String   @id @default(uuid())
  name        String
  menu_item   String // e.g. "Big Burger"
  version     String
  country     String? // If null, global recipe
  
  yield_count Float    @default(1)
  target_cost_pct Float @default(0.30)
  
  // Manual overrides
  manual_price Float?
  
  created_at  DateTime @default(now())
  
  lines       RecipeLine[]
}

model RecipeLine {
  id          String   @id @default(uuid())
  recipe_id   String
  ingredient_id String
  quantity    Float
  unit        String
  
  recipe      Recipe     @relation(fields: [recipe_id], references: [id])
  ingredient  Ingredient @relation(fields: [ingredient_id], references: [id])
}

model CompetitorPrice {
  id          String   @id @default(uuid())
  country     String
  brand       String
  menu_item   String
  price       Float
  currency    String
  as_of       DateTime
}

model FXRate {
  id          String   @id @default(uuid())
  from_currency String
  to_currency   String
  rate          Float
  date          DateTime @default(now())
}

// System Logs

model AuditLog {
  id          String   @id @default(uuid())
  entity_type String
  entity_id   String
  action      String
  changes     String // JSON string of changes
  
  user_id     String?
  user        User?    @relation(fields: [user_id], references: [id])
  
  created_at  DateTime @default(now())
}

model NotificationLog {
  id          String   @id @default(uuid())
  type        String   // "EMAIL_DUE_SOON", "EMAIL_OVERDUE"
  recipient   String
  payload     String
  status      String   // "SENT", "FAILED"
  created_at  DateTime @default(now())
}
